<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BAZINGA</title>
  
  <subtitle>BAZINGA&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://caoyudong.com/"/>
  <updated>2018-09-12T05:56:07.687Z</updated>
  <id>http://caoyudong.com/</id>
  
  <author>
    <name>BAZINGA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>259. 3Sum Smaller</title>
    <link href="http://caoyudong.com/2018/07/17/259-3Sum-Smaller/"/>
    <id>http://caoyudong.com/2018/07/17/259-3Sum-Smaller/</id>
    <published>2018-07-17T21:38:10.000Z</published>
    <updated>2018-09-12T05:56:07.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of n integers nums and a target, find the number of index triplets <code>i, j, k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code>that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong> nums = [-2,0,1,3], and target = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Because there are two triplets which sums  are less than 2:<br>            [-2,0,1]<br>            [-2,0,3]</p></blockquote><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟 3Sum 类似，但是这题只用求count个数。所以当second 和 third满足条件时，<code>[second,third]</code>这个区间都满足条件，于是 计算<code>count += third - second</code>就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>;first&lt;nums.size()<span class="number">-2</span>;first++) &#123;</span><br><span class="line">        <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> third = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(second&lt;third) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[first] + nums[second] + nums[third]&lt;target) &#123;</span><br><span class="line">                count += third - second;</span><br><span class="line">                second ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                third --;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of n integers nums and a target, find the number of index triplets &lt;code&gt;i, j, k&lt;/code&gt; with &lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; n&lt;/code&gt;that satisfy the condition &lt;code&gt;nums[i] + nums[j] + nums[k] &amp;lt; target&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [-2,0,1,3], and target = 2&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;br&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; Because there are two triplets which sums  are less than 2:&lt;br&gt;            [-2,0,1]&lt;br&gt;            [-2,0,3]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>16. 3Sum Closest</title>
    <link href="http://caoyudong.com/2018/07/17/16-3Sum-Closest/"/>
    <id>http://caoyudong.com/2018/07/17/16-3Sum-Closest/</id>
    <published>2018-07-17T20:18:52.000Z</published>
    <updated>2018-09-12T05:56:07.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array <code>nums</code> of n integers and an integer <code>target</code>, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:</p><p>Given array nums = [-1, 2, 1, -4], and target = 1.</p><p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟<a href="http://caoyudong.com/2018/01/23/15-3Sum/">15. 3Sum</a>差不多，把数组排序之后依次比较当前得数和剩下两个数之和。</p><p>唯一的不同就是单独声明一个变量来记录最接近的那个值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>;first &lt; nums.size()<span class="number">-1</span>;first ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> third = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(second &lt; third) &#123;</span><br><span class="line">            <span class="keyword">int</span> curSum = nums[first] + nums[second] + nums[third];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(target - result)&gt;<span class="built_in">abs</span>(target - curSum)) &#123;</span><br><span class="line">                result = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curSum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; target) &#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of n integers and an integer &lt;code&gt;target&lt;/code&gt;, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given array nums = [-1, 2, 1, -4], and target = 1.&lt;/p&gt;
&lt;p&gt;The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>186. Reverse Words in a String II</title>
    <link href="http://caoyudong.com/2018/07/13/186-Reverse-Words-in-a-String-II/"/>
    <id>http://caoyudong.com/2018/07/13/186-Reverse-Words-in-a-String-II/</id>
    <published>2018-07-14T00:50:41.000Z</published>
    <updated>2018-09-12T05:56:07.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an input string , reverse the string word by word. </p><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong>  [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”]<br><strong>Output:</strong> [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”]</p></blockquote><p><strong>Note:</strong></p><ul><li>A word is defined as a sequence of non-space characters.</li><li>The input string does not contain leading or trailing spaces.</li><li>The words are always separated by a single space.</li></ul><p><strong>Follow up:</strong> Could you do it in-place without allocating extra space?</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先把整个数组调换一遍，再根据空格为单位，再分别调换每一个单词就好。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; str,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(end&gt;start) &#123;</span><br><span class="line">        swap(str[start++],str[end--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先把整个数组转换一遍</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = str.size()<span class="number">-1</span>;</span><br><span class="line">    reverse(str,i, j);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//再根据空格转换一遍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; str.size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            end = i<span class="number">-1</span>;</span><br><span class="line">            reverse(str,start, end);</span><br><span class="line">            start = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个单词</span></span><br><span class="line">    end = str.size()<span class="number">-1</span>;</span><br><span class="line">    reverse(str,start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an input string , reverse the string word by word. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A word is defined as a sequence of non-space characters.&lt;/li&gt;
&lt;li&gt;The input string does not contain leading or trailing spaces.&lt;/li&gt;
&lt;li&gt;The words are always separated by a single space.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Could you do it in-place without allocating extra space?&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="http://caoyudong.com/2018/07/08/206-Reverse-Linked-List/"/>
    <id>http://caoyudong.com/2018/07/08/206-Reverse-Linked-List/</id>
    <published>2018-07-08T17:04:38.000Z</published>
    <updated>2018-09-12T05:56:07.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>Output:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>新建一个表头，通过循环依次反转链表指针方向就好。 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> 变成 <code>NULL&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        head-&gt;next = result;</span><br><span class="line">        result = head;</span><br><span class="line">        head = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>之前一直写错成这样是不对的，<code>cur</code>指向<code>head</code>的地址，改变了<code>cur-&gt;next</code>的值相当于改变了<code>head-&gt;next</code>的值，这样写结果只会返回链表第一个值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        cur-&gt;next = result;</span><br><span class="line">        result = cur;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.com/problems/reverse-linked-list/discuss/58130/8ms-C++-Iterative-and-Recursive-Solutions-with-Explanations" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/discuss/58130/8ms-C++-Iterative-and-Recursive-Solutions-with-Explanations</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;206-Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#206-Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;206. Reverse Linked List&quot;&gt;&lt;/a&gt;206. Reverse Linked List&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>53. Maximum Subarray</title>
    <link href="http://caoyudong.com/2018/07/05/53-Maximum-Subarray-1/"/>
    <id>http://caoyudong.com/2018/07/05/53-Maximum-Subarray-1/</id>
    <published>2018-07-06T03:31:04.000Z</published>
    <updated>2018-09-12T05:56:07.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只用记录两个变量，一个局部最优<code>tempSum</code>，一个全局最优<code>maxSum</code>。当局部最优小于零的时候就不考虑之前的数字，直接归零，然后依次得出全局最优。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>只用记录两个变量，一个是区间的临时总和<code>tempSum</code>，一个是和的最大值<code>maxSum</code>，然后遍历一次数组。假设遍历到第<code>n</code>个数，此时<code>tempSum = tempSum + n</code>。但是如果n之前的tempSum的值已经小于0了，我们就不用考虑他，因为下一个值不管是正数还是负数，加上<code>tempSum</code>值会变得更小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN, tempSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums) &#123;</span><br><span class="line">        tempSum = n + (tempSum&gt;<span class="number">0</span>?tempSum:<span class="number">0</span>);</span><br><span class="line">        maxSum = maxSum&gt;tempSum?maxSum:tempSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还在网上看到了动态规划法：</p><p>状态转移方程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">        dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = A[i] + (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Input: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;Output: 6&lt;br&gt;Explanation: [4,-1,2,1] has the largest sum = 6.&lt;br&gt;Follow up:&lt;/p&gt;
&lt;p&gt;If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Hazel部署Electron更新服务器</title>
    <link href="http://caoyudong.com/2018/06/19/%E4%BD%BF%E7%94%A8Hazel%E9%83%A8%E7%BD%B2Electron%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://caoyudong.com/2018/06/19/使用Hazel部署Electron更新服务器/</id>
    <published>2018-06-19T22:13:32.000Z</published>
    <updated>2018-09-12T05:56:07.702Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/zeit/hazel" target="_blank" rel="noopener">Hazel</a>是一款轻量级的Electron 程序更新服务器，可以在<a href="https://zeit.co/now" target="_blank" rel="noopener">Now</a>上免费部署。它会自动从<code>GitHub Releases</code>中拉取更新文件，并且利用 GitHub CDN 的强大性能，下载很快。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先在自己电脑上安装一个 <a href="https://zeit.co/now#get-started" target="_blank" rel="noopener">Now桌面端</a>，然后创建一个账户登录进去。</p><p>然后通过命令行进入到项目更目录下，比如项目文件夹叫<code>app-project</code>，直接输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now zeit/hazel</span><br></pre></td></tr></table></figure><p>然后就根据提示，输入你github的用户名<code>ACCOUNT</code>以及仓库<code>REPOSITORY</code>的名字。</p><p>之后，now会给你一个更新的URL，需要把这个URL记下来，以后用得到，比如我的就是：<code>https://electrontest-xpugzqzjyt.now.sh</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在程序的主线程（main.js）里面添加以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, autoUpdater &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="xml"><span class="tag">&lt;<span class="name">之前的更新URL地址</span>&gt;</span></span></span><br><span class="line"><span class="xml">const feed = `$&#123;server&#125;/update/$&#123;process.platform&#125;/$&#123;app.getVersion()&#125;`</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">autoUpdater.setFeedURL(feed)</span></span><br></pre></td></tr></table></figure><p>然后就可以使用了。</p><h3 id="github端"><a href="#github端" class="headerlink" title="github端"></a>github端</h3><p>在github网页直接发布release就好。</p><p>但是需要注意的是，windows端发布需要直接上传<code>.exe</code>文件和<code>.nupkg</code>文件以及一个<code>RELEASES</code>文件。<strong>直接上传zip压缩文件是没用的！</strong></p><p>可以参考<a href="https://github.com/electron/electron-api-demos/releases" target="_blank" rel="noopener">electron-api-demos的release</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/zeit/hazel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hazel&lt;/a&gt;是一款轻量级的Electron 程序更新服务器，可以在&lt;a href=&quot;https://zeit.co/now&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Now&lt;/a&gt;上免费部署。它会自动从&lt;code&gt;GitHub Releases&lt;/code&gt;中拉取更新文件，并且利用 GitHub CDN 的强大性能，下载很快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Electron" scheme="http://caoyudong.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>Electron autoUpdater 自动更新</title>
    <link href="http://caoyudong.com/2018/06/13/Electron-autoUpdater-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <id>http://caoyudong.com/2018/06/13/Electron-autoUpdater-自动更新/</id>
    <published>2018-06-14T03:54:43.000Z</published>
    <updated>2018-09-12T05:56:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>Electron是一款可以使用 JavaScript，HTML 和 CSS构建跨平台桌面应用的框架。但是当用户获取下一个版本的时候，只能下载重新安装一遍下一个版本，十分僵硬，于是我们需要引入一个Electron自动更新的方法。</p><p>有多种方法可以更新Electron应用. 最简单并且获得官方支持的方法是利用内置的Squirrel框架和Electron的<code>autoUpdater</code>模块。但是目前<code>autoUpdater</code>只有 macOS 和 Window 支持该功能。在 Linux 上没有对自动更新程序的内置支持。</p><p>然而，各种谷歌到的官方文档和博客实在是太坑，感觉讲的都不是很详细，我这里记录汇总并加点自己的观点。</p><a id="more"></a><p>根据官方文档，有两种可以更新的方法：<a href="https://github.com/electron/update.electronjs.org" target="_blank" rel="noopener">update.electronjs.org</a>和<a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a>。但是官方API例子<a href="https://github.com/electron/electron-api-demos" target="_blank" rel="noopener">electron-api-demos</a>使用的是<a href="https://github.com/electron-userland/electron-packager" target="_blank" rel="noopener">electron-packager</a>。这里我都会做讨论。</p><h2 id="平台区别"><a href="#平台区别" class="headerlink" title="平台区别"></a>平台区别</h2><p>目前<code>autoUpdater</code>只有 macOS 和 Window 支持该功能。在 Linux 上没有对自动更新程序的内置支持。</p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>在macOS上, autoUpdater模块建立在 Squirrel.Mac上,也就是说不需要任何别的设置，直接打包就可以用了。</p><p><strong>但是需要注意：macOS自动更新一定要签名！！而且一定要使用苹果开发者证书，自己生成的没有用（看别人博客说的，我自己也没试过）</strong></p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 Windows 上实现自动更新是通过 Squirrel.Windows。但它的处理方式与 OSX 完全不同。</p><p>与 Squirrel.Mac 不同的点在于：Squirrel.Windows 并不需要一个用于检测新版本的 API 路径，它需要的是一个文件服务器。另外，该 Squirrel 更新器并不内置于 Electron，它是一个第三方依赖。也就是说，你必须把打包的Windows应用生成一个安装程序，<strong>安装之后才可以使用！！！直接运行打包好的程序会报错。</strong>（<code>Cannot find module &#39;squirrel&#39;</code>）</p><p><img src="../../../../image/77c4cf93-211e-476a-bc49-ddead2767589.png" alt=""></p><p>打包程序见下文。</p><h2 id="Electron-packager"><a href="#Electron-packager" class="headerlink" title="Electron-packager"></a>Electron-packager</h2><p>Electron-packager 是一款命令行工具以及Node.js库，可以将Electron的应用程序以及所需代码库打包成各个平台可执行文件。</p><p>支持的平台有：</p><ul><li>Windows (32/64 bit)</li><li>OS X (also known as macOS)</li><li>Linux (x86/x86_64)</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要Node.js 4.0 以上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for use in npm scripts</span></span><br><span class="line">npm install electron-packager --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># for use from cli</span></span><br><span class="line">npm install electron-packager -g</span><br></pre></td></tr></table></figure><p>非windows平台上面打包windows可执行程序需要先安装<code>Wine</code>，<strong>但是按照我个人经验，在Mac上打包一次需要超过半小时（windows虚拟机可能会快点），但是同样的程序在Windows上只需要2分钟</strong></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装好之后直接在命令行输入一下命令就可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]</span><br></pre></td></tr></table></figure><p>比如我在<code>package.json</code>里面写的就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"package:mac"</span>: <span class="string">"electron-packager . --overwrite --platform=darwin --arch=x64 --out=out"</span>,</span><br><span class="line">    <span class="string">"package:win"</span>: <span class="string">"electron-packager . --overwrite --platform=win32 --arch=ia32 --out=out"</span>,</span><br><span class="line">    <span class="string">"package:linux"</span>: <span class="string">"electron-packager . --overwrite --platform=linux --arch=x64 --out=out"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样在命令行直接运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run package:win</span><br></pre></td></tr></table></figure><p>就可以打包windows平台的程序了。</p><h3 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h3><p>生成安装包可以使用<a href="https://github.com/electron/windows-installer" target="_blank" rel="noopener">electron-winstaller</a>。</p><p>electron-winstaller 是一个基于<code>Squirrel</code>的生成Windows安装包的 npm 模块，基本的参数说明可以到它官网上查看，这里我只是写下我自己demo的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//windowsInstaller.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> electronInstaller = <span class="built_in">require</span>(<span class="string">'electron-winstaller'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">resultPromise = electronInstaller.createWindowsInstaller(&#123;</span><br><span class="line">    appDirectory: <span class="string">'./out/MyApp-win32-ia32'</span>,</span><br><span class="line">    outputDirectory: <span class="string">'./windows32'</span>,</span><br><span class="line">    authors: <span class="string">'cyd'</span>,</span><br><span class="line">    exe: <span class="string">'MyApp.exe'</span>,</span><br><span class="line">    noMsi: <span class="literal">true</span>,</span><br><span class="line">    outputDirectory: path.join(<span class="string">'./out/'</span>, <span class="string">'windows-installer'</span>),</span><br><span class="line">    setupExe: <span class="string">'ElectronAPIDemosSetup.exe'</span>,</span><br><span class="line">    skipUpdateIcon: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">resultPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"It worked!"</span>), (e) =&gt; <span class="built_in">console</span>.log(<span class="string">`No dice: <span class="subst">$&#123;e.message&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>在使用<code>electron-builder</code>打包之后，通过运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./windowsInstaller.js</span><br></pre></td></tr></table></figure><p>运行这个文件就可以在<code>windows32</code>文件夹下找到名为<code>MyApp.exe</code>的安装包。双击运行就可以自动安装。安装界面如下所示，注意这个方法不能选择安装目录，程序会自动安装到C盘。（可能作者模仿Mac简易的安装方式？</p><p>安装过程会运行一个默认的gif动画。</p><p><img src="https://github.com/cydjohn/cydjohn.github.io/raw/master/image/42892ecc-3408-4c97-8cb5-7c177c1eebd6.gif" alt=""></p><p>如果之前部署过新版程序在服务器上，双击运行程序，没什么问题应该就会看到这个画面，点击restart 就可以运行最新的程序了。</p><h2 id="Electron-builder"><a href="#Electron-builder" class="headerlink" title="Electron-builder"></a>Electron-builder</h2><p><code>electron-builder</code>是一个完整的解决方案，对于Macos、windows、linux下的electron app，它可以提供打包及构建的相关功能。同时，它还提供开箱即用的“自动更新”功能支持。</p><h3 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h3><p><a href="">Hazel</a> – 用于私人或开源应用的更新服务器，可以在 Now 上免费部署。 它从GitHub Releases中拉取更新文件，并且利用 GitHub CDN 的强大性能。</p><p><a href="">使用自己的服务器</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong><em>注意开发的时候不要调用这些代码块，可以使用<a href="https://github.com/sindresorhus/electron-is-dev" target="_blank" rel="noopener">electron-is-dev</a>检查当前的环境</em></strong></p><p><strong><em>以下代码需要添加到<code>main.js</code>中</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, autoUpdater, dialog &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br></pre></td></tr></table></figure><p>然后构建更新服务器的URL并且通知autoUpdater:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="string">'https://your-deployment-url.com'</span></span><br><span class="line"><span class="keyword">const</span> feed = <span class="string">`<span class="subst">$&#123;server&#125;</span>/update/<span class="subst">$&#123;process.platform&#125;</span>/<span class="subst">$&#123;app.getVersion()&#125;</span>`</span></span><br><span class="line">  </span><br><span class="line">autoUpdater.setFeedURL(feed)</span><br></pre></td></tr></table></figure><p>最后，检查更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="comment">//每分钟检查一次</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    autoUpdater.checkForUpdates()</span><br><span class="line">  &#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure><h3 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h3><p>通过<code>autoUpdate</code>的API，可以知道应用更新的状态，然后来通知用户</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line">autoUpdater.on(<span class="string">'update-downloaded'</span>, (event, releaseNotes, releaseName) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dialogOpts = &#123;</span><br><span class="line">      type: <span class="string">'info'</span>,</span><br><span class="line">      buttons: [<span class="string">'Restart'</span>, <span class="string">'Later'</span>],</span><br><span class="line">      title: <span class="string">'Application Update'</span>,</span><br><span class="line">      message: process.platform === <span class="string">'win32'</span> ? releaseNotes : releaseName,</span><br><span class="line">      detail: <span class="string">'A new version has been downloaded. Restart the application to apply the updates.'</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    dialog.showMessageBox(dialogOpts, (response) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (response === <span class="number">0</span>) autoUpdater.quitAndInstall()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>同时要确保错误已经被处理了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line">autoUpdater.on(<span class="string">'error'</span>, message =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'There was a problem updating the application'</span>)</span><br><span class="line">    <span class="built_in">console</span>.error(message)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><hr><p><a href="https://electronjs.org/docs/tutorial/updates" target="_blank" rel="noopener">https://electronjs.org/docs/tutorial/updates</a></p><p><a href="https://electronjs.org/docs/api/auto-updater" target="_blank" rel="noopener">https://electronjs.org/docs/api/auto-updater</a></p><p><a href="https://github.com/sorrycc/blog/issues/26" target="_blank" rel="noopener">https://github.com/sorrycc/blog/issues/26</a></p><p><a href="https://github.com/electron-userland/electron-packager" target="_blank" rel="noopener">https://github.com/electron-userland/electron-packager</a></p><p><a href="https://segmentfault.com/a/1190000010271226" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010271226</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Electron是一款可以使用 JavaScript，HTML 和 CSS构建跨平台桌面应用的框架。但是当用户获取下一个版本的时候，只能下载重新安装一遍下一个版本，十分僵硬，于是我们需要引入一个Electron自动更新的方法。&lt;/p&gt;
&lt;p&gt;有多种方法可以更新Electron应用. 最简单并且获得官方支持的方法是利用内置的Squirrel框架和Electron的&lt;code&gt;autoUpdater&lt;/code&gt;模块。但是目前&lt;code&gt;autoUpdater&lt;/code&gt;只有 macOS 和 Window 支持该功能。在 Linux 上没有对自动更新程序的内置支持。&lt;/p&gt;
&lt;p&gt;然而，各种谷歌到的官方文档和博客实在是太坑，感觉讲的都不是很详细，我这里记录汇总并加点自己的观点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Electron" scheme="http://caoyudong.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>Electron中使用Bootstrap和JQuery</title>
    <link href="http://caoyudong.com/2018/05/01/Electron%E4%B8%AD%E4%BD%BF%E7%94%A8Bootstrap%E5%92%8CJQuery/"/>
    <id>http://caoyudong.com/2018/05/01/Electron中使用Bootstrap和JQuery/</id>
    <published>2018-05-01T22:07:57.000Z</published>
    <updated>2018-09-12T05:56:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>一般网页都可以直接使用<code>bootstrap</code>和<code>JQuery</code> 的CDN来请求<code>bootstrap</code>和<code>JQuery</code>。但是做electron应用的时候希望做成本地的，因为不是每时每刻都可以联网。原以为 <code>npm</code> 安装之后直接用就可以，结果遇到了很多坑，这里记录下。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先使用npm安装bootstrap 和 JQuery</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install bootstrap --save</span><br><span class="line">npm install JQuery --save</span><br></pre></td></tr></table></figure><p>然后就会发现有一行警告</p><blockquote><p>npm WARN <a href="mailto:bootstrap@4.1.1" target="_blank" rel="noopener">bootstrap@4.1.1</a> requires a peer of popper.js@^1.14.3 but none is installed. You must install peer dependencies yourself.</p></blockquote><p>于是还需要安装 <code>popper.js</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install popper.js --save</span><br></pre></td></tr></table></figure><p>安装部分就完成了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>bootstrap 直接从安装文件里面拿就好，地址是 <code>./node_modules/bootstrap/dist/css/bootstrap.min.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./node_modules/bootstrap/dist/css/bootstrap.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JQuery 就很坑了，google了好多资料，electron里面你应该这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不然会报错，很多神奇的错误。</p><hr><h2 id="关于bootstrap-datepicker的一个坑"><a href="#关于bootstrap-datepicker的一个坑" class="headerlink" title="关于bootstrap-datepicker的一个坑"></a>关于bootstrap-datepicker的一个坑</h2><p><del>使用npm安装的bootstrap-datepicker完全没用，我从网上复制粘贴了整个<code>bootstrap-datepicker.js</code> 的代码，本地新建文件，然后<code>&lt;script src = &quot;bootstrap-datepicker.js&quot;&gt;&lt;/script&gt;</code>才可以正常使用</del></p><p>后来发现可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bootstrap-datepicker --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">require</span>(<span class="string">'bootstrap-datepicker'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>菜的抠脚</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般网页都可以直接使用&lt;code&gt;bootstrap&lt;/code&gt;和&lt;code&gt;JQuery&lt;/code&gt; 的CDN来请求&lt;code&gt;bootstrap&lt;/code&gt;和&lt;code&gt;JQuery&lt;/code&gt;。但是做electron应用的时候希望做成本地的，因为不是每时每刻都可以联网。原以为 &lt;code&gt;npm&lt;/code&gt; 安装之后直接用就可以，结果遇到了很多坑，这里记录下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Electron" scheme="http://caoyudong.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>461. Hamming Distance</title>
    <link href="http://caoyudong.com/2018/04/28/461-Hamming-Distance/"/>
    <id>http://caoyudong.com/2018/04/28/461-Hamming-Distance/</id>
    <published>2018-04-28T06:09:26.000Z</published>
    <updated>2018-09-12T05:56:07.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><p>Note:<br>0 ≤ x, y &lt; 2^31 .</p><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong> x = 1, y = 4</p></blockquote><blockquote><p><strong>Output:</strong> 2</p></blockquote><blockquote><p><strong>Explanation:</strong>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1   (0 0 0 1)    </span><br><span class="line">4   (0 1 0 0)    </span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure><blockquote><p>The above arrows point to positions where the corresponding bits are different.</p></blockquote><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目说 y &lt; 2^31 那写一个32次的循环，依次统计一共有多少个1就好。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = x^y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s &amp; <span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result ++;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看到别人思路貌似有个比32次循环更快的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>, n = x ^ y;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ++dist;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;The Hamming distance between two integers is the number of positions at which the corresponding bits are different.&lt;/p&gt;
&lt;p&gt;Given two integers x and y, calculate the Hamming distance.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;0 ≤ x, y &amp;lt; 2^31 .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; x = 1, y = 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1   (0 0 0 1)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4   (0 1 0 0)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ↑   ↑&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;The above arrows point to positions where the corresponding bits are different.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>14. Longest Common Prefix</title>
    <link href="http://caoyudong.com/2018/04/28/14-Longest-Common-Prefix/"/>
    <id>http://caoyudong.com/2018/04/28/14-Longest-Common-Prefix/</id>
    <published>2018-04-28T05:47:33.000Z</published>
    <updated>2018-09-12T05:56:07.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> [“flower”,”flow”,”flight”]<br><strong>Output:</strong> “fl”</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> [“dog”,”racecar”,”car”]<br><strong>Output:</strong> “”</p></blockquote><p><strong>Explanation:</strong> There is no common prefix among the input strings.<br>Note:</p><p>All given inputs are in lowercase letters <code>a-z</code>.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的思路是以第一个字符串为标准设为<code>result</code>，依次寻找每个字符串的公共前缀，如果有不一样的就从<code>result</code>里把不一样的移除，剩下的<code>result</code>就是所求的公共前缀了。</p><p>然后就是看到别人的思路：从0开始依次遍历每一个字符串，如果是公共前缀就加到<code>result</code>里。</p><blockquote><p>貌似我的比他快了一毫秒O(∩_∩)O~</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> result = strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span> s:strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;result.size() &amp;&amp; i&lt;s.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != result[i]) &#123;</span><br><span class="line">                result.erase(i,result.size()-i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result.size()&gt;s.size()) &#123;</span><br><span class="line">            result.erase(s.size(),result.size()-s.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>从0开始依次遍历每一个字符串，如果是公共前缀就加到<code>result</code>里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> prefix = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; strs.size()&gt;<span class="number">0</span>; prefix+=strs[<span class="number">0</span>][idx], idx++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs.size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(idx &gt;= strs[i].size() ||(i &gt; <span class="number">0</span> &amp;&amp; strs[i][idx] != strs[i<span class="number">-1</span>][idx]))</span><br><span class="line">                <span class="keyword">return</span> prefix;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;
&lt;p&gt;If there is no common prefix, return an empty string “”.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [“flower”,”flow”,”flight”]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “fl”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [“dog”,”racecar”,”car”]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; There is no common prefix among the input strings.&lt;br&gt;Note:&lt;/p&gt;
&lt;p&gt;All given inputs are in lowercase letters &lt;code&gt;a-z&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>371. Sum of Two Integers</title>
    <link href="http://caoyudong.com/2018/04/24/371-Sum-of-Two-Integers/"/>
    <id>http://caoyudong.com/2018/04/24/371-Sum-of-Two-Integers/</id>
    <published>2018-04-24T05:34:12.000Z</published>
    <updated>2018-09-12T05:56:07.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator <code>+</code> and <code>-</code>.</p><p><strong>Example:</strong></p><p>Given a = 1 and b = 2, return 3.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不能用 <code>+</code> 号或者 <code>-</code> 号，那就只能用位操作了。位操作有四种：</p><p><code>&amp;</code> 与操作（AND operation）： 2 (0010) &amp; 7 (0111) =&gt; 2 (0010)</p><p><code>|</code> 或操作 （OR operation）： 2 (0010) | 7 (0111) =&gt; 7 (0111)</p><p><code>^</code> 异或操作 （XOR operation）： 2 (0010) ^ 7 (0111) =&gt; 5 (0101)</p><p><code>~</code> 非操作 （NOT operation）： ~2(0010) =&gt; -3 (1101) <code>补码，见文末</code></p><p>其中，最左边一位是符号位，代表正负，比如</p><p>1111 代表 -1 （补码）</p><p>1110 代表 -2</p><p>这题两个位置全为1的地方需要进一位，不全为1的地方直接异或操作就好。于是我们用一个<code>carry</code>来记录进位，每次进位完需要左移一位。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = a &amp; b;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = carry&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSubtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> borrow = (~a) &amp; b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = borrow &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Calculate the sum of two integers a and b, but you are not allowed to use the operator &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a = 1 and b = 2, return 3.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>167. Two Sum II - Input array is sorted</title>
    <link href="http://caoyudong.com/2018/04/23/167-Two-Sum-II-Input-array-is-sorted/"/>
    <id>http://caoyudong.com/2018/04/23/167-Two-Sum-II-Input-array-is-sorted/</id>
    <published>2018-04-24T04:50:01.000Z</published>
    <updated>2018-09-12T05:56:07.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p><p><strong>Input:</strong> numbers={2, 7, 11, 15}, target=9<br><strong>Output:</strong> index1=1, index2=2</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟<code>Two Sum</code>类似，不过这是排好序的，就只用用两个指针，一个指向数组头部，一个指向尾部，然后依次扫描就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = numbers.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[l]+numbers[h]==target) &#123;</span><br><span class="line">            result.push_back(l+<span class="number">1</span>);</span><br><span class="line">            result.push_back(h+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l]+numbers[h]&gt;target) &#123;</span><br><span class="line">            h--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given an array of integers that is already &lt;strong&gt;&lt;em&gt;sorted in ascending order&lt;/em&gt;&lt;/strong&gt;, find two numbers such that they add up to a specific target number.&lt;/p&gt;
&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution and you may not use the same element twice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; numbers={2, 7, 11, 15}, target=9&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; index1=1, index2=2&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>程序员能力矩阵</title>
    <link href="http://caoyudong.com/2018/04/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%83%BD%E5%8A%9B%E7%9F%A9%E9%98%B5/"/>
    <id>http://caoyudong.com/2018/04/22/程序员能力矩阵/</id>
    <published>2018-04-22T20:16:27.000Z</published>
    <updated>2018-09-12T05:56:07.707Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a></p><p>注意:每个层次的知识都是渐增的，位于层次n，也蕴涵了你需了解所有低于层次n的知识。</p><h2 id="计算机科学-Computer-Science"><a href="#计算机科学-Computer-Science" class="headerlink" title="计算机科学 Computer Science"></a>计算机科学 Computer Science</h2><p>Working with someone who has a good topcoder ranking would be an unbelievable piece of luck! </p><p>有一个黑客排行榜排名靠前的同事将会是一件无比幸运的事情。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">不知道数组和链表的差异</td><td style="text-align:center">能够解释和使用数组，链表，字典等，并且能够用于实际的编程任务。</td><td style="text-align:center">了解基本数据结构时间和空间的折中，比如数组vs 链表，能够解释如何实现哈希表和处理冲突，了解优先队列及其实现。</td><td style="text-align:center">高等的数据结构的知识，比如B-树、二项堆、斐波那契堆、AVL树、红黑树、伸展树、跳跃表以及前缀树等。</td></tr><tr><td style="text-align:center">算法</td><td style="text-align:center">不能够找出一个数组各数的平均值(这令人难以置信，但是我的确在应聘者中遇到过)</td><td style="text-align:center">基本的排序，搜索和数据的遍历和检索算法。</td><td style="text-align:center">树，图，简单的贪婪算法和分而治之算法，能够适度了解矩阵该层的含义。</td><td style="text-align:center">能够辨识和编写动态规划方案，良好的图算法知识，良好的数值估算的知识，能够辨别NP问题等。</td></tr><tr><td style="text-align:center">编程体系</td><td style="text-align:center">不知道何为编译器、链接器和解释器。</td><td style="text-align:center">对编译器、链接器、解释器有基本的了解。知道什么是汇编代码以及在硬件层如何工作。有一些虚拟内存和分页知识。</td><td style="text-align:center">了解内核模式vs用户模式,多线程，同步原语以及它们如何实现，能够阅读汇编代码。了解网络如何工作，了解网络协议和socket级别编程。</td><td style="text-align:center">了解整个程序堆栈、硬件(CPU+内存+中断+微码)、二进制代码、汇编、静态和动态链接、编码、解释、JIT（just-in-time）编译、内存碎片回收、堆、栈、存储器编址…</td></tr></tbody></table><a id="more"></a><h2 id="软件工程-Software-Engineering"><a href="#软件工程-Software-Engineering" class="headerlink" title="软件工程 Software Engineering"></a>软件工程 Software Engineering</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">源码版本控制</td><td style="text-align:center">通过日期备份文件夹</td><td style="text-align:center">VSS和初级的CVS/SVN用户</td><td style="text-align:center">熟练地使用CVS和SVN特性。知道如何分支和归并，使用程序库补丁安装特性等</td><td style="text-align:center">有分布式VCS系统的知识。尝试过Bzr/Mercurial/Darcs/Git</td></tr><tr><td style="text-align:center">自动化编译</td><td style="text-align:center">只知道在IDE下编译</td><td style="text-align:center">知道如何编译在命令行下编译系统</td><td style="text-align:center">能够安装一个脚本构建基本的系统</td><td style="text-align:center">能够安装一个脚本来构建系统并且归档，安装程序，生成发布记录和给源码控制中的代码分配标签。</td></tr><tr><td style="text-align:center">自动化测试</td><td style="text-align:center">认为所有的测试都是测试员的工作。</td><td style="text-align:center">能够编写自动化的单元测试，能够为正在编写的代码提出良好的测试用例。</td><td style="text-align:center">按照TDD （Test Driven Development）方式编写代码。</td><td style="text-align:center">了解并且能够有效自动化安装，载入/性能和UI测试</td></tr></tbody></table><h2 id="程序设计-Programming"><a href="#程序设计-Programming" class="headerlink" title="程序设计 Programming"></a>程序设计 Programming</h2><p>This is an often under rated but very critical criteria for judging a programmer. With the increase in outsourcing of programming tasks to places where English is not the native tongue this issue has become more prominent. I know of several projects that failed because the programmers could not understand what the intent of the communication was.</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">问题分解</td><td style="text-align:center">只有直线式的代码，通过复制粘贴来复用</td><td style="text-align:center">能够把问题分散到多个函数中</td><td style="text-align:center">能够想出可复用的函数/对象来解决大题的问题</td><td style="text-align:center">使用适宜的数据结构和算法，写出通用的/面向对象的代码来封装问题的易改变的层面。</td></tr><tr><td style="text-align:center">系统分解</td><td style="text-align:center">想不出比单一的文件/类更好的层面</td><td style="text-align:center">如果不在同一平台或没采用相同的技术，能够把问题空间和设计方案分解。</td><td style="text-align:center">能够设计跨技术/平台的系统。</td><td style="text-align:center">能够在多个产品线和与外部体系一体化中虚拟化和设计复制的系统。同时也能够设计支持系统监视、报告、故障恢复等。</td></tr><tr><td style="text-align:center">交流</td><td style="text-align:center">不能向同伴表达想法/主意。匮乏拼写和语法的能力。</td><td style="text-align:center">同伴能了解你在说什么。有良好的拼写和语法能力。</td><td style="text-align:center">能够和同伴进行高效的交流</td><td style="text-align:center">能够使用清晰的方式了解和交流想法/设计/主意/细则，能适应每种环境的交流</td></tr><tr><td style="text-align:center">同一文件中代码组织</td><td style="text-align:center">同一文件中组织没有依据</td><td style="text-align:center">按照逻辑性或者易接近的方法。</td><td style="text-align:center">代码分块和对于其他源文件来说是易于是释,引用其他源文件时有良好的注释。</td><td style="text-align:center">文档头部有许可声明，总结，良好的注释，一致的空格缩进。文档外观美观。</td></tr></tbody></table><p>The difference between this and the previous item is in the scale of organization, source tree organization relates to the entire set of artifacts that define the system.</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">跨文件代码组织</td><td style="text-align:center">没够想过给代码跨文件组织</td><td style="text-align:center">相关文件按文件夹分组</td><td style="text-align:center">每个物理文件都有独立的目的，比如一个类的定义，一个特性的实现等。</td><td style="text-align:center">代码在物理层组织紧密，在文件名上与设计和外观相匹配，可以通过文件分布方式洞察设计理念。</td></tr><tr><td style="text-align:center">源码树组织</td><td style="text-align:center">一切都放在一个文件夹内</td><td style="text-align:center">初步地将代码分散进对应逻辑的文件夹。</td><td style="text-align:center">没有循环依赖，二进制文件，库，文档，构建，第三方的代码都组织进合适的文件夹内。</td><td style="text-align:center">源码树的物理布局与逻辑层次、组织方式相匹配。可以通过目录名称和组织方式洞察设计理念。</td></tr><tr><td style="text-align:center">代码可读性</td><td style="text-align:center">单音节的名称 （在国内应该是那些类似用汉语拼音命名的习惯）</td><td style="text-align:center">对文件、变量、类、方法等，有良好的命名。</td><td style="text-align:center">没有长函数、注释解释不常规的代码，bug修复,代码假设。</td><td style="text-align:center">代码假设验证使用断言，自然的代码流，没有深层嵌套的条件和方法</td></tr><tr><td style="text-align:center">防御性编码</td><td style="text-align:center">不知道这个概念</td><td style="text-align:center">检查代码中所有的参数，对关键的假设进行断言</td><td style="text-align:center">确保检查了返回值和使代码失败的异常。</td><td style="text-align:center">有自己的库来帮助防御性编程、编写单元测试模拟故障</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">错误处理</td><td style="text-align:center">只给乐观的情形编码</td><td style="text-align:center">基本的代码错误处理，抛出异常/生成错误</td><td style="text-align:center">确保错误/异常留在程序中有良好的状态，资源，连接，内存都有被合适的清理。</td><td style="text-align:center">在编码之前察觉可能出现的异常，在代码的所有层次中维持一致性的异常处理策略，提出整个系统的错误处理准则。</td></tr><tr><td style="text-align:center">IDE</td><td style="text-align:center">IDE大部分用来进行文本编辑</td><td style="text-align:center">了解其周围的接口，能够高效地通过菜单来使用IDE</td><td style="text-align:center">了解最常操作的键盘快捷键</td><td style="text-align:center">编写自定义宏</td></tr><tr><td style="text-align:center">API</td><td style="text-align:center">需要频繁地查阅文档</td><td style="text-align:center">把最频繁使用的API记在脑子里</td><td style="text-align:center">广阔且深入的API知识。</td><td style="text-align:center">为了使实际任务中常用API使用更加便捷，编写过API的上层库，填补API之间的缺口。</td></tr><tr><td style="text-align:center">框架</td><td style="text-align:center">没有使用过主平台外的任何框架</td><td style="text-align:center">听过但没用过平台下流行的可用框架</td><td style="text-align:center">在专业的职位中使用过一个以上的框架，通晓各框架的特色。</td><td style="text-align:center">某框架的作者</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">需求分析</td><td style="text-align:center">接受给定的需求和代码规格</td><td style="text-align:center">能对规格的遗漏提出疑问</td><td style="text-align:center">了解全面情况，提出需要被规格化的整体范围。</td><td style="text-align:center">能够提出更好的可选方案，根据经验的浮现给出需求</td></tr><tr><td style="text-align:center">脚本</td><td style="text-align:center">不具备脚本工具的知识</td><td style="text-align:center">批处理文件/shell脚本</td><td style="text-align:center">Perl/Python/Ruby/VBScript/Powershell</td><td style="text-align:center">写过并且发表过可重用的代码</td></tr><tr><td style="text-align:center">数据库</td><td style="text-align:center">认为Excel就是数据库</td><td style="text-align:center">知道基本的数据库概念，规范化、ACID（原子性Atomicity、一致性Consistency、隔离性Isolation、持久性Durability）、事务化，能够写简单的select语句</td><td style="text-align:center">能够牢记在运行时必要查询中设计良好的规范化数据库模式， 精通用户视图，存储过程，触发器和用户定义类型。知道聚集与非聚集索引之间的差异。精通使用ORM（Object Relational Mapping对象关系映射）工具</td><td style="text-align:center">能做基本的数据库管理，性能优化，索引优化，编写高级的select查询，能够使用相关sql来替换游标，理解数据内部的存储，了解如何镜像、复制数据库。知道两段数据提交如何工作</td></tr></tbody></table><h2 id="经验-Experience"><a href="#经验-Experience" class="headerlink" title="经验 Experience"></a>经验 Experience</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">专业语言经验</td><td style="text-align:center">命令式语言和面向对象语言</td><td style="text-align:center">命令式语言,面向对象语言和说明型语言(SQL),如果了解静态类型vs动态类型，弱类型vs强类型则有加分</td><td style="text-align:center">函数式语言,如果了解延缓求值，局部套用函数，延续则有加分</td><td style="text-align:center">并发语言(Erlang, Oz) 逻辑语言(Prolog)</td></tr><tr><td style="text-align:center">专业平台经验（年）</td><td style="text-align:center">1</td><td style="text-align:center">2-3</td><td style="text-align:center">4-5</td><td style="text-align:center">6+</td></tr><tr><td style="text-align:center">专业经验年龄（年）</td><td style="text-align:center">1</td><td style="text-align:center">2-5</td><td style="text-align:center">6-9</td><td style="text-align:center">10+</td></tr><tr><td style="text-align:center">领域知识</td><td style="text-align:center">没有该领域的知识</td><td style="text-align:center">在该领域中曾经至少为一个产品工作过</td><td style="text-align:center">在同一领域中为多个产品工作过</td><td style="text-align:center">领域专家。在该领域设计和实现数种产品/方案。精通该领域使用的标准条款和协议</td></tr></tbody></table><h2 id="学识-Knowledge"><a href="#学识-Knowledge" class="headerlink" title="学识 Knowledge"></a>学识 Knowledge</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">2^n (Levenl 0)</th><th style="text-align:center">n^2 (Level 1)</th><th style="text-align:center">n(Level 2)</th><th style="text-align:center">log(n) (Level 3) </th></tr></thead><tbody><tr><td style="text-align:center">工具知识</td><td style="text-align:center">仅限于主要的IDE(VS.Net, Eclipse等)</td><td style="text-align:center">知道一些流行和标准工具的备选方案</td><td style="text-align:center">对编辑器、调试器、IDE、开源的备选方案有很好的了解。比如某人了解大多数Scott Hanselman的威力工具列表中的工具，使用过ORM工具。</td><td style="text-align:center">实际地编写过工具和脚本，如果这些被发布则有加分</td></tr><tr><td style="text-align:center">语言接触</td><td style="text-align:center">命令式语言和面向对象语言</td><td style="text-align:center">命令式语言、面向对象语言和说明型语言(SQL),如果了解静态类型vs动态类型、弱类型vs强类型则有加分</td><td style="text-align:center">函数式语言,如果了解延缓求值、局部套用函数、continuations （源于scheme中的一种高级控制结构）则有加分</td><td style="text-align:center">并发语言(Erlang, Oz) 逻辑语言(Prolog)</td></tr><tr><td style="text-align:center">代码库知识</td><td style="text-align:center">从来没有查询过代码库</td><td style="text-align:center">基本的代码层知识，了解如果构建系统</td><td style="text-align:center">良好的代码库工作知识，实现过几次bug修复或者完成了一些细小的特性</td><td style="text-align:center">实现了代码库中多个大型特性，能够轻松地将多数特性的需求变更具体化，从容地处理bug修复。</td></tr><tr><td style="text-align:center">下一代技术知识</td><td style="text-align:center">从来没听说过即将到来的技术</td><td style="text-align:center">听说过某领域即将到来的技术</td><td style="text-align:center">下载过alpha preview/CTP/beta版本，并且读过一些文章和手册</td><td style="text-align:center">试用过预览版而且实际地构建过某物，如果共享给其他人的话则有加分</td></tr><tr><td style="text-align:center">平台内部</td><td style="text-align:center">对平台内部毫无所知</td><td style="text-align:center">有平台基本的内部工作的知识</td><td style="text-align:center">深度的平台内部知识，能够设想平台如何将程序转换成可执行代码。</td><td style="text-align:center">编写过增强平台或者为其平台内部提供信息的工具。比如，反汇编工具，反编译工具，调试工具等。</td></tr><tr><td style="text-align:center">书籍</td><td style="text-align:center">菜鸟系列，21天系列，24小时系列，蠢货系列…</td><td style="text-align:center">《代码大全》(<strong>《Code Complete》</strong>)，《别让我思考》(《Don’t Make me Think》), 《精通正则表达式》(《Mastering Regular Expressions》)</td><td style="text-align:center">《设计模式》（《Design Patterns》），《人件》（《Peopleware》），《代码珠玑》（《Programming Pearls》），《算法设计手册》（《 Algorithm Design Manual》），《程序员修炼之道》（《Pragmatic Programmer》），《人月神话》（《Mythical Man month》）</td><td style="text-align:center">《计算机程序设计与解释》（《Structure and Interpretation of Computer Programs》），《事务处理:概念与技术》(《Concepts Techniques》)，《计算机程序设计模型》（《Models of Computer Programming》），《计算机程序设计艺术》（《 Art of Computer Programming》），《数据库系统导论》 C.J Date版（《Database systems》by C. J Date），《Thinking Forth》 ，《Little Schemer》</td></tr><tr><td style="text-align:center">博客</td><td style="text-align:center">听过但是从来抽不出空去接触</td><td style="text-align:center">阅读一些科技/编程/软件工程的博客，并且经常的收听一些播客</td><td style="text-align:center">维护一些博客的链接，收集博主分享的有用的文章和工具</td><td style="text-align:center">维护一个在编程方面，分享有个人见解和思考的博客</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://sijinjoseph.com/programmer-competency-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programmer Competency Matrix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意:每个层次的知识都是渐增的，位于层次n，也蕴涵了你需了解所有低于层次n的知识。&lt;/p&gt;
&lt;h2 id=&quot;计算机科学-Computer-Science&quot;&gt;&lt;a href=&quot;#计算机科学-Computer-Science&quot; class=&quot;headerlink&quot; title=&quot;计算机科学 Computer Science&quot;&gt;&lt;/a&gt;计算机科学 Computer Science&lt;/h2&gt;&lt;p&gt;Working with someone who has a good topcoder ranking would be an unbelievable piece of luck! &lt;/p&gt;
&lt;p&gt;有一个黑客排行榜排名靠前的同事将会是一件无比幸运的事情。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;2^n (Levenl 0)&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;n^2 (Level 1)&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;n(Level 2)&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;log(n) (Level 3) &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据结构&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不知道数组和链表的差异&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;能够解释和使用数组，链表，字典等，并且能够用于实际的编程任务。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;了解基本数据结构时间和空间的折中，比如数组vs 链表，能够解释如何实现哈希表和处理冲突，了解优先队列及其实现。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;高等的数据结构的知识，比如B-树、二项堆、斐波那契堆、AVL树、红黑树、伸展树、跳跃表以及前缀树等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;算法&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不能够找出一个数组各数的平均值(这令人难以置信，但是我的确在应聘者中遇到过)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;基本的排序，搜索和数据的遍历和检索算法。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;树，图，简单的贪婪算法和分而治之算法，能够适度了解矩阵该层的含义。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;能够辨识和编写动态规划方案，良好的图算法知识，良好的数值估算的知识，能够辨别NP问题等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;编程体系&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不知道何为编译器、链接器和解释器。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对编译器、链接器、解释器有基本的了解。知道什么是汇编代码以及在硬件层如何工作。有一些虚拟内存和分页知识。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;了解内核模式vs用户模式,多线程，同步原语以及它们如何实现，能够阅读汇编代码。了解网络如何工作，了解网络协议和socket级别编程。&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;了解整个程序堆栈、硬件(CPU+内存+中断+微码)、二进制代码、汇编、静态和动态链接、编码、解释、JIT（just-in-time）编译、内存碎片回收、堆、栈、存储器编址…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="杂七杂八" scheme="http://caoyudong.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>292. Nim Game</title>
    <link href="http://caoyudong.com/2018/04/18/292-Nim-Game/"/>
    <id>http://caoyudong.com/2018/04/18/292-Nim-Game/</id>
    <published>2018-04-18T22:44:46.000Z</published>
    <updated>2018-09-12T05:56:07.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>靠脑子想一下子没想出来（菜的抠脚）。</p><p>其实这题倒过来想，什么情况必输。那就是会后一轮剩下的石头总数等于4；那如何保证最后一轮剩下的石头数量等于4呢，就是倒数第二轮剩下的石头有8个……以此类推，得出的结论就是石头数量是4的倍数不可能赢。</p><p>于是判断石头数量是不是4的倍数就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;
&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;
&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>8. String to Integer (atoi)</title>
    <link href="http://caoyudong.com/2018/04/16/8-String-to-Integer-atoi/"/>
    <id>http://caoyudong.com/2018/04/16/8-String-to-Integer-atoi/</id>
    <published>2018-04-17T04:40:00.000Z</published>
    <updated>2018-09-12T05:56:07.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p><strong>Note:</strong> </p><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31 ) is returned.</p><a id="more"></a><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> “42”<br><strong>Output:</strong> 42</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> “&nbsp;&nbsp;&nbsp;&nbsp; -42”<br><strong>Output:</strong> -42<br><strong>Explanation:</strong> The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42.</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p><strong>Input:</strong> “4193 with words”<br><strong>Output:</strong> 4193<br><strong>Explanation:</strong> Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p></blockquote><p><strong>Example 4:</strong></p><blockquote><p><strong>Input:</strong> “words and 987”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p></blockquote><p><strong>Example 5:</strong></p><blockquote><p><strong>Input:</strong> “-91283472332”<br><strong>Output:</strong> -2147483648<br><strong>Explanation:</strong> The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这题太他妈傻逼了！！！！</strong></p><p>题目5个要求：</p><ol><li>string 转 int</li><li>丢弃数字前面的空格</li><li>丢弃数字后面的字符串</li><li>无视字符串后面的数字</li><li>超过INT_MAX (2^31 − 1) 或 INT_MIN (−2^31 )返回边界值</li></ol><p>本来挺简单的，题目写if else就好，但是测试用例里面居然还有<code>+-2</code>,<code>+1</code>这种情况！！ 什么破玩意。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>||str[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i+<span class="number">1</span>] != <span class="string">'-'</span>||str[i+<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                flag = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str[i]&lt;=<span class="string">'9'</span>&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;i&lt;str.size()) &#123;</span><br><span class="line">        result*=<span class="number">10</span>;</span><br><span class="line">        result+=(<span class="keyword">int</span>)str[i] - <span class="number">48</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result *= flag;</span><br><span class="line">    result = result&lt;INT_MIN?INT_MIN:result;</span><br><span class="line">    result = result&gt;INT_MAX?INT_MAX:result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简洁版 https://leetcode.com/problems/string-to-integer-atoi/discuss/4642/8ms-C++-solution-easy-to-understand</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indicator = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.size();)</span><br><span class="line">    &#123;</span><br><span class="line">        i = str.find_first_not_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</span><br><span class="line">            indicator = (str[i++] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            result = result*<span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(result*indicator &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(result*indicator &lt;= INT_MIN) <span class="keyword">return</span> INT_MIN;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result*indicator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;
&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;
&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;
&lt;p&gt;If no valid conversion could be performed, a zero value is returned.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31 ) is returned.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>6. ZigZag Conversion</title>
    <link href="http://caoyudong.com/2018/04/16/6-ZigZag-Conversion/"/>
    <id>http://caoyudong.com/2018/04/16/6-ZigZag-Conversion/</id>
    <published>2018-04-17T01:24:54.000Z</published>
    <updated>2018-09-12T05:56:07.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N  </span><br><span class="line">A P L S I I G  </span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><blockquote><p>string convert(string text, int nRows);</p></blockquote><p><code>convert(&quot;PAYPALISHIRING&quot;, 3)</code> should return <code>&quot;PAHNAPLSIIGYIR&quot;</code>.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题指的<code>zigzag pattern</code>一开始我也不是很明白，看了Discuss之后才搞清楚，大概就是这样：</p><p>n=4的时候，图案是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1    7     13</span><br><span class="line">2  6 8   12 14</span><br><span class="line">3 5  9 11   15</span><br><span class="line">4    10</span><br></pre></td></tr></table></figure><p>3行的时候图案是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1   5   9  12</span><br><span class="line">2 4 6 8 10 13 15</span><br><span class="line">3   7   11 14</span><br></pre></td></tr></table></figure><p>2行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 7  9</span><br><span class="line">2 4 6 8 10</span><br></pre></td></tr></table></figure><p>所以根据上述规律，可以发现第一行和最后一行每个数字之间都是相隔<code>2n-2</code>；然后斜着那条线，字符的位置永远与当前周期的前一个数字相隔<code>2n-2-2i</code>（i是行数），所以在第j个周期的第i行，那个字符的位置应该是<code>j+2n-2-2i</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size()&lt;<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numRows==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numRows;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;s.size();j+=<span class="number">2</span>*numRows<span class="number">-2</span>) &#123;</span><br><span class="line">            result.push_back(s[j]);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=numRows<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">2</span>*numRows<span class="number">-2</span><span class="number">-2</span>*i&lt;s.size()) &#123;</span><br><span class="line">                    result.push_back(s[j+<span class="number">2</span>*numRows<span class="number">-2</span><span class="number">-2</span>*i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;The string &lt;code&gt;&amp;quot;PAYPALISHIRING&amp;quot;&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;P   A   H   N  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A P L S I I G  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Y   I   R&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And then read line by line: “PAHNAPLSIIGYIR”&lt;/p&gt;
&lt;p&gt;Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;string convert(string text, int nRows);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;convert(&amp;quot;PAYPALISHIRING&amp;quot;, 3)&lt;/code&gt; should return &lt;code&gt;&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>458. Poor Pigs</title>
    <link href="http://caoyudong.com/2018/04/16/458-Poor-Pigs/"/>
    <id>http://caoyudong.com/2018/04/16/458-Poor-Pigs/</id>
    <published>2018-04-17T01:23:41.000Z</published>
    <updated>2018-09-12T05:56:07.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour.</p><p>Answer this question, and write an algorithm for the follow-up general case.</p><p><strong>Follow-up:</strong></p><p>If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the “poison” bucket within p minutes? There is exact one bucket with poison.</p><a id="more"></a><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看了别人一个特别吊的思路：<a href="https://leetcode.com/problems/poor-pigs/discuss/94266/Another-explanation-and-solution" target="_blank" rel="noopener">https://leetcode.com/problems/poor-pigs/discuss/94266/Another-explanation-and-solution</a></p><p>假设我们有两只猪，喝了有毒的水之后15分钟死亡，一共有60分钟，那么我们最多可以在25个桶里找到有毒的那一桶。方法如下，将25个桶排列成<code>5X5</code>的一块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4   5</span><br><span class="line">6  7  8  9  10</span><br><span class="line">11 12 13 14 15</span><br><span class="line">16 17 18 19 20</span><br><span class="line">21 22 23 24 25</span><br></pre></td></tr></table></figure><p>然后我们用第一只猪喝每一行的水，第二只猪喝每一列的水。比如，第一只猪喝<code>1,2,3,4,5</code>号桶的水，然后等15分钟，再喝<code>6,7,8,9,10</code> 号桶的水，然后再等15分钟；第二只猪喝<code>1,6,11,16,21</code>号桶的水，等15分钟再喝<code>2,7,12,17,22</code>号桶的水，以此类推。。。</p><p>我们一共有60分钟，毒药发作时间是15分钟，那么我们在规定时间内一共可以测4轮。假设第一只猪第三轮死了，我们可以确定有毒的那桶在第三行，第二只猪第四轮死了，我们就可以确定有毒那桶在第三行第四列，也就是19。</p><p>假设我们有三只猪，我们就可以用一个<code>5x5x5</code>的立方体来测，一共125桶水。</p><p>综上所诉我们可以的到公式</p><p>\[<br>    buckets = (\frac{minutesToTest}{minutesToDie})^{pigs}<br>\]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poorPigs</span><span class="params">(<span class="keyword">int</span> buckets, <span class="keyword">int</span> minutesToDie, <span class="keyword">int</span> minutesToTest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pigs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">pow</span>((minutesToTest/minutesToDie+<span class="number">1</span>),pigs) &lt; buckets) &#123;</span><br><span class="line">        pigs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pigs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour.&lt;/p&gt;
&lt;p&gt;Answer this question, and write an algorithm for the follow-up general case.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the “poison” bucket within p minutes? There is exact one bucket with poison.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <link href="http://caoyudong.com/2018/04/13/5-Longest-Palindromic-Substring/"/>
    <id>http://caoyudong.com/2018/04/13/5-Longest-Palindromic-Substring/</id>
    <published>2018-04-13T05:58:13.000Z</published>
    <updated>2018-09-12T05:56:07.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> “babad”<br><strong>Output:</strong> “bab”<br><strong>Note:</strong> “aba” is also a valid answer.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> “cbbd”<br><strong>Output:</strong> “bb”</p></blockquote><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><p>假设字符串长度为n，那么我们可以用一个大小为<code>dp[n][n]</code>的二维数组来代表字符串状态。其中，<code>dp[i][j]</code>代表<code>i~j</code>区间的字符是否为回文串。</p><ul><li>当i=j时，只有一个字符，肯定是回文串；</li><li>当<code>i=j+1</code>时，说明是相邻字符，只用判断<code>s[i]</code>是否等于<code>s[j]</code>；</li><li>当字符不相邻，也就是<code>i-j&gt;2</code>时，<strong>判断<code>s[i]</code>是否等于<code>s[j]</code>以及<code>dp[i+1][j-1]</code>是否为回文串即可。</strong></li></ul><p>通过上面的分析可以写出递推公式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i, j] = <span class="number">1</span>   <span class="comment">//if i == j</span></span><br><span class="line"></span><br><span class="line">dp[i, j] = s[i] == s[j] <span class="comment">//if j = i + 1</span></span><br><span class="line"></span><br><span class="line">dp[i, j] = s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]     <span class="comment">//if j &gt; i + 1</span></span><br></pre></td></tr></table></figure><p>例如，字符串<code>aabba</code>每一步dp的状态依次如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// aa</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// aab</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// aabb</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// aabba</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Manacher’s-Algorithm-马拉车算法"><a href="#Manacher’s-Algorithm-马拉车算法" class="headerlink" title="Manacher’s Algorithm 马拉车算法"></a>Manacher’s Algorithm 马拉车算法</h3><p><a href="http://www.cnblogs.com/grandyang/p/4475985.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4475985.html</a><br><a href="https://blog.csdn.net/dyx404514/article/details/42061017" target="_blank" rel="noopener">https://blog.csdn.net/dyx404514/article/details/42061017</a></p><p>最逆天的地方在于他把时间复杂度提高到了线性<code>O(n)</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[s.size()][s.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">            dp[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[j][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(left,right-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Manacher’s-Algorithm-马拉车算法-1"><a href="#Manacher’s-Algorithm-马拉车算法-1" class="headerlink" title="Manacher’s Algorithm 马拉车算法"></a>Manacher’s Algorithm 马拉车算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Insert '#'</span></span><br><span class="line">    <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        t += s[i];</span><br><span class="line">        t += <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process t</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.size(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">        p[i] = mx &gt; i ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">            resLen = p[i];</span><br><span class="line">            resCenter = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr((resCenter - resLen) / <span class="number">2</span>, resLen - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; “babad”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “bab”&lt;br&gt;&lt;strong&gt;Note:&lt;/strong&gt; “aba” is also a valid answer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; “cbbd”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “bb”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <link href="http://caoyudong.com/2018/04/12/21-Merge-Two-Sorted-Lists/"/>
    <id>http://caoyudong.com/2018/04/12/21-Merge-Two-Sorted-Lists/</id>
    <published>2018-04-13T04:31:05.000Z</published>
    <updated>2018-09-12T05:56:07.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>Example:</p><blockquote><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为链表是有序的所以依次比较两个链表每个值大小添加到新的链表了就好了。就是归并排序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    ListNode *tail = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) &#123;</span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = l1?l1:l2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法</span></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1) &#123;<span class="keyword">return</span> l2;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!l2) &#123;<span class="keyword">return</span> l1;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val) &#123;</span><br><span class="line">        ListNode* temp =l2;</span><br><span class="line">        temp-&gt;next = mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode* temp =l1;</span><br><span class="line">        temp-&gt;next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://caoyudong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>13. Roman to Integer</title>
    <link href="http://caoyudong.com/2018/04/12/13-Roman-to-Integer/"/>
    <id>http://caoyudong.com/2018/04/12/13-Roman-to-Integer/</id>
    <published>2018-04-13T03:13:15.000Z</published>
    <updated>2018-09-12T05:56:07.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a roman numeral, convert it to an integer.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>罗马数字共有7个，即Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000）。</p><ul><li>重复数次：一个罗马数字重复几次，就表示这个数的几倍。</li><li>右加左减：<ul><li>在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。</li><li>在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。</li><li>左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV<br>但是，左减时不可跨越一个位值。比如，99不可以用IC（ {\displaystyle 100-1} 100-1）表示，而是用XCIX（ {\displaystyle [100-10]+[10-1]} [100-10]+[10-1]）表示。（等同于阿拉伯数字每位数字分别表示。）</li><li>左减数字必须为一位，比如8写成VIII，而非IIX。</li><li>右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。）</li></ul></li></ul><blockquote><p>参考自<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>所以从右往左依次读取每一个字符，比较他们的大小。如果右边一位字符的值大于当前字符的值，就在总结果里面减去当前的值，如果大于或等于当前的值就在总结果加上当前的值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; romanMap = &#123;&#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;,&#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;,&#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = romanMap[s[s.size()<span class="number">-1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(romanMap[s[i]]&gt;=romanMap[s[i+<span class="number">1</span>]]) &#123;</span><br><span class="line">            result+=romanMap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result-=romanMap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
