<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CMMotionActivityManager]]></title>
    <url>%2F2018%2F09%2F24%2FCMMotionActivityManager%2F</url>
    <content type="text"><![CDATA[现在很多应用都需要检测用户的运动情况，而iPhone上有一整套传感器可以帮助开发者确定用户的运动状况例如 气压计，陀螺仪，磁强计，加速度传感器和GPS模块，然而这些传感器模块的数据需要通过CPU计算得到判断得到结果，如果一直在后台运行程序来不断获取数据容易让app变得十分耗电，比如美国的一家新型保险公司root。他们通过app来检测得到用户的驾驶数据，然后通过计算得到用户的驾驶习惯，评估之后会给出用户相应的保险报价。比如这个人加速过快或者转弯过猛就说明这个人驾驶习惯不好，保险费用就会相对来说高一些。然后我下载了这个app之后惊奇的发现，就算半夜我没开车它也一直在后台获取我的数据，导致我手机一晚上耗电百分之十几（新的iPhone 8P，平时一晚上大约掉1%的电） M系列协处理器对于这个问题，苹果有更好的解决办法了。自从2013年的iPhone5s之后每一台iPhone和Apple Watch上都装上了M系列协处理器。通过这个专用硬件系统可以将所有传感器处理工作从CPU上卸载掉，从而减少电量的使用。CMMotionActivityManager 由 Core Motion 框架提供。Core Motion 通过调用M系列协处理器来获取用户运动情况。 CMMotionActivityCMMotionActivity 对每种运动都会有个布尔值属性，并且还有一个设备是否处于静止状态的属性。也就是说用户可能同时处于多个状态，比如开着车突然停在了红灯前，那么 automotive和 stationary都会为 ture。 属性列表如下： 属性 解释 stationary 禁止状态 walking 走路 running 跑步 cycling 自行车 automotive 交通工具（如果是在陆地上可以视为开车，如果是在水里可以视为在坐船） unknown 无法识别 为了方便理解我自己写了个app，放几张截图来解释下，其中红色背景代表熟悉布尔值为false的情况，绿色为true的情况： 这是你在开车 （刚开始开车不会识别，大约行驶1分钟之后显示为在开车）： 这是你开车停到了红灯前： 这是手机放着不动： 这是跑步或者你快速的摇手机： 这是人在走路或者慢慢的摇手机： 核心代码12345678910111213141516171819202122import CoreMotionlet manager = CMMotionActivityManager()manager.startActivityUpdates(to: .main) &#123; (activity) in guard let activity = activity else &#123; return &#125; if activity.walking &#123; print("🚶‍") &#125; if activity.running &#123; print("🏃‍") &#125; if activity.cycling &#123; print("🚴‍") &#125; if activity.automotive &#123; print("🚗") &#125; if activity.stationary &#123; print("🛑") &#125;&#125; https://developer.apple.com/documentation/coremotion/cmmotionactivity]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[259. 3Sum Smaller]]></title>
    <url>%2F2018%2F07%2F17%2F259-3Sum-Smaller%2F</url>
    <content type="text"><![CDATA[题目Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; nthat satisfy the condition nums[i] + nums[j] + nums[k] &lt; target. Example: Input: nums = [-2,0,1,3], and target = 2Output: 2Explanation: Because there are two triplets which sums are less than 2: [-2,0,1] [-2,0,3] 思路跟 3Sum 类似，但是这题只用求count个数。所以当second 和 third满足条件时，[second,third]这个区间都满足条件，于是 计算count += third - second就可以了。 代码123456789101112131415161718192021//C++int threeSumSmaller(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()&lt;3) return 0; int count = 0; sort(nums.begin(),nums.end()); for(int first = 0;first&lt;nums.size()-2;first++) &#123; int second = first + 1; int third = nums.size()-1; while(second&lt;third) &#123; if(nums[first] + nums[second] + nums[third]&lt;target) &#123; count += third - second; second ++; &#125; else &#123; third --; &#125; &#125; &#125; return count;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16. 3Sum Closest]]></title>
    <url>%2F2018%2F07%2F17%2F16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[题目Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 思路跟15. 3Sum差不多，把数组排序之后依次比较当前得数和剩下两个数之和。 唯一的不同就是单独声明一个变量来记录最接近的那个值。 代码1234567891011121314151617181920212223242526int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()&lt;3) return 0; sort(nums.begin(),nums.end()); int result = nums[0] + nums[1] + nums[2]; for(int first = 0;first &lt; nums.size()-1;first ++) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first + 1; int third = nums.size() - 1; while(second &lt; third) &#123; int curSum = nums[first] + nums[second] + nums[third]; if(abs(target - result)&gt;abs(target - curSum)) &#123; result = curSum; &#125; if(curSum == target) &#123; return target; &#125; else if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return result;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[186. Reverse Words in a String II]]></title>
    <url>%2F2018%2F07%2F13%2F186-Reverse-Words-in-a-String-II%2F</url>
    <content type="text"><![CDATA[题目Given an input string , reverse the string word by word. Example: Input: [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”]Output: [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”] Note: A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces. The words are always separated by a single space. Follow up: Could you do it in-place without allocating extra space? 思路先把整个数组调换一遍，再根据空格为单位，再分别调换每一个单词就好。 代码1234567891011121314151617181920212223void reverse(vector&lt;char&gt;&amp; str,int start, int end) &#123; while(end&gt;start) &#123; swap(str[start++],str[end--]); &#125;&#125; void reverseWords(vector&lt;char&gt;&amp; str) &#123; //先把整个数组转换一遍 int i = 0, j = str.size()-1; reverse(str,i, j); int start = 0, end = 0; //再根据空格转换一遍 for(int i = 0; i&lt; str.size();i++) &#123; if(str[i] == ' ') &#123; end = i-1; reverse(str,start, end); start = i+1; &#125; &#125; // 最后一个单词 end = str.size()-1; reverse(str,start, end);&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2F2018%2F07%2F08%2F206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[206. Reverse Linked List题目Reverse a singly linked list. Example: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? 思路新建一个表头，通过循环依次反转链表指针方向就好。 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 变成 NULL&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5 代码12345678910ListNode* reverseList(ListNode* head) &#123; ListNode* result = NULL; while(head) &#123; ListNode* cur = head-&gt;next; head-&gt;next = result; result = head; head = cur; &#125; return result;&#125; 之前一直写错成这样是不对的，cur指向head的地址，改变了cur-&gt;next的值相当于改变了head-&gt;next的值，这样写结果只会返回链表第一个值： 1234567891011//C++ListNode* reverseList(ListNode* head) &#123; ListNode* result = NULL; while(head) &#123; ListNode* cur = head; cur-&gt;next = result; result = cur; head = head-&gt;next; &#125; return result;&#125; https://leetcode.com/problems/reverse-linked-list/discuss/58130/8ms-C++-Iterative-and-Recursive-Solutions-with-Explanations]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53. Maximum Subarray]]></title>
    <url>%2F2018%2F07%2F05%2F53-Maximum-Subarray-1%2F</url>
    <content type="text"><![CDATA[题目Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 思路只用记录两个变量，一个局部最优tempSum，一个全局最优maxSum。当局部最优小于零的时候就不考虑之前的数字，直接归零，然后依次得出全局最优。 代码只用记录两个变量，一个是区间的临时总和tempSum，一个是和的最大值maxSum，然后遍历一次数组。假设遍历到第n个数，此时tempSum = tempSum + n。但是如果n之前的tempSum的值已经小于0了，我们就不用考虑他，因为下一个值不管是正数还是负数，加上tempSum值会变得更小。 123456789//C++int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxSum = INT_MIN, tempSum = 0; for(int n:nums) &#123; tempSum = n + (tempSum&gt;0?tempSum:0); maxSum = maxSum&gt;tempSum?maxSum:tempSum; &#125; return maxSum;&#125; 然后还在网上看到了动态规划法： 状态转移方程为： 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; 1234567891011121314//Javapublic int maxSubArray(int[] A) &#123; int n = A.length; int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i]; dp[0] = A[0]; int max = dp[0]; for(int i = 1; i &lt; n; i++)&#123; dp[i] = A[i] + (dp[i - 1] &gt; 0 ? dp[i - 1] : 0); max = Math.max(max, dp[i]); &#125; return max;&#125; https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hazel部署Electron更新服务器]]></title>
    <url>%2F2018%2F06%2F19%2F%E4%BD%BF%E7%94%A8Hazel%E9%83%A8%E7%BD%B2Electron%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Hazel是一款轻量级的Electron 程序更新服务器，可以在Now上免费部署。它会自动从GitHub Releases中拉取更新文件，并且利用 GitHub CDN 的强大性能，下载很快。 安装首先在自己电脑上安装一个 Now桌面端，然后创建一个账户登录进去。 然后通过命令行进入到项目更目录下，比如项目文件夹叫app-project，直接输入 1now zeit/hazel 然后就根据提示，输入你github的用户名ACCOUNT以及仓库REPOSITORY的名字。 之后，now会给你一个更新的URL，需要把这个URL记下来，以后用得到，比如我的就是：https://electrontest-xpugzqzjyt.now.sh 使用代码在程序的主线程（main.js）里面添加以下代码： 123456const &#123; app, autoUpdater &#125; = require('electron')const server = &lt;之前的更新URL地址&gt;const feed = `$&#123;server&#125;/update/$&#123;process.platform&#125;/$&#123;app.getVersion()&#125;`autoUpdater.setFeedURL(feed) 然后就可以使用了。 github端在github网页直接发布release就好。 但是需要注意的是，windows端发布需要直接上传.exe文件和.nupkg文件以及一个RELEASES文件。直接上传zip压缩文件是没用的！ 可以参考electron-api-demos的release]]></content>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron autoUpdater 自动更新]]></title>
    <url>%2F2018%2F06%2F13%2FElectron-autoUpdater-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Electron是一款可以使用 JavaScript，HTML 和 CSS构建跨平台桌面应用的框架。但是当用户获取下一个版本的时候，只能下载重新安装一遍下一个版本，十分僵硬，于是我们需要引入一个Electron自动更新的方法。 有多种方法可以更新Electron应用. 最简单并且获得官方支持的方法是利用内置的Squirrel框架和Electron的autoUpdater模块。但是目前autoUpdater只有 macOS 和 Window 支持该功能。在 Linux 上没有对自动更新程序的内置支持。 然而，各种谷歌到的官方文档和博客实在是太坑，感觉讲的都不是很详细，我这里记录汇总并加点自己的观点。 根据官方文档，有两种可以更新的方法：update.electronjs.org和electron-builder。但是官方API例子electron-api-demos使用的是electron-packager。这里我都会做讨论。 平台区别目前autoUpdater只有 macOS 和 Window 支持该功能。在 Linux 上没有对自动更新程序的内置支持。 macOS在macOS上, autoUpdater模块建立在 Squirrel.Mac上,也就是说不需要任何别的设置，直接打包就可以用了。 但是需要注意：macOS自动更新一定要签名！！而且一定要使用苹果开发者证书，自己生成的没有用（看别人博客说的，我自己也没试过） Windows在 Windows 上实现自动更新是通过 Squirrel.Windows。但它的处理方式与 OSX 完全不同。 与 Squirrel.Mac 不同的点在于：Squirrel.Windows 并不需要一个用于检测新版本的 API 路径，它需要的是一个文件服务器。另外，该 Squirrel 更新器并不内置于 Electron，它是一个第三方依赖。也就是说，你必须把打包的Windows应用生成一个安装程序，安装之后才可以使用！！！直接运行打包好的程序会报错。（Cannot find module &#39;squirrel&#39;） 打包程序见下文。 Electron-packagerElectron-packager 是一款命令行工具以及Node.js库，可以将Electron的应用程序以及所需代码库打包成各个平台可执行文件。 支持的平台有： Windows (32/64 bit) OS X (also known as macOS) Linux (x86/x86_64) 安装需要Node.js 4.0 以上 12345# for use in npm scriptsnpm install electron-packager --save-dev# for use from clinpm install electron-packager -g 非windows平台上面打包windows可执行程序需要先安装Wine，但是按照我个人经验，在Mac上打包一次需要超过半小时（windows虚拟机可能会快点），但是同样的程序在Windows上只需要2分钟 使用安装好之后直接在命令行输入一下命令就可以： 1electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 比如我在package.json里面写的就是 12345"scripts": &#123; "package:mac": "electron-packager . --overwrite --platform=darwin --arch=x64 --out=out", "package:win": "electron-packager . --overwrite --platform=win32 --arch=ia32 --out=out", "package:linux": "electron-packager . --overwrite --platform=linux --arch=x64 --out=out", &#125;, 这样在命令行直接运行 1npm run package:win 就可以打包windows平台的程序了。 生成安装包生成安装包可以使用electron-winstaller。 electron-winstaller 是一个基于Squirrel的生成Windows安装包的 npm 模块，基本的参数说明可以到它官网上查看，这里我只是写下我自己demo的参数。 123456789101112131415161718//JavaScript//windowsInstaller.jsvar electronInstaller = require('electron-winstaller');const path = require('path')resultPromise = electronInstaller.createWindowsInstaller(&#123; appDirectory: './out/MyApp-win32-ia32', outputDirectory: './windows32', authors: 'cyd', exe: 'MyApp.exe', noMsi: true, outputDirectory: path.join('./out/', 'windows-installer'), setupExe: 'ElectronAPIDemosSetup.exe', skipUpdateIcon: true &#125;);resultPromise.then(() =&gt; console.log("It worked!"), (e) =&gt; console.log(`No dice: $&#123;e.message&#125;`)); 在使用electron-builder打包之后，通过运行 1node ./windowsInstaller.js 运行这个文件就可以在windows32文件夹下找到名为MyApp.exe的安装包。双击运行就可以自动安装。安装界面如下所示，注意这个方法不能选择安装目录，程序会自动安装到C盘。（可能作者模仿Mac简易的安装方式？ 安装过程会运行一个默认的gif动画。 如果之前部署过新版程序在服务器上，双击运行程序，没什么问题应该就会看到这个画面，点击restart 就可以运行最新的程序了。 Electron-builderelectron-builder是一个完整的解决方案，对于Macos、windows、linux下的electron app，它可以提供打包及构建的相关功能。同时，它还提供开箱即用的“自动更新”功能支持。 部署服务器Hazel – 用于私人或开源应用的更新服务器，可以在 Now 上免费部署。 它从GitHub Releases中拉取更新文件，并且利用 GitHub CDN 的强大性能。 使用自己的服务器 代码注意开发的时候不要调用这些代码块，可以使用electron-is-dev检查当前的环境 以下代码需要添加到main.js中 12//JavaScriptconst &#123; app, autoUpdater, dialog &#125; = require('electron') 然后构建更新服务器的URL并且通知autoUpdater: 12345//JavaScriptconst server = 'https://your-deployment-url.com'const feed = `$&#123;server&#125;/update/$&#123;process.platform&#125;/$&#123;app.getVersion()&#125;` autoUpdater.setFeedURL(feed) 最后，检查更新 12345//JavaScript//每分钟检查一次setInterval(() =&gt; &#123; autoUpdater.checkForUpdates() &#125;, 60000) 应用更新通过autoUpdate的API，可以知道应用更新的状态，然后来通知用户 1234567891011121314//JavaScriptautoUpdater.on('update-downloaded', (event, releaseNotes, releaseName) =&gt; &#123; const dialogOpts = &#123; type: 'info', buttons: ['Restart', 'Later'], title: 'Application Update', message: process.platform === 'win32' ? releaseNotes : releaseName, detail: 'A new version has been downloaded. Restart the application to apply the updates.' &#125; dialog.showMessageBox(dialogOpts, (response) =&gt; &#123; if (response === 0) autoUpdater.quitAndInstall() &#125;) &#125;) 同时要确保错误已经被处理了: 12345//JavaScriptautoUpdater.on('error', message =&gt; &#123; console.error('There was a problem updating the application') console.error(message) &#125;) https://electronjs.org/docs/tutorial/updates https://electronjs.org/docs/api/auto-updater https://github.com/sorrycc/blog/issues/26 https://github.com/electron-userland/electron-packager https://segmentfault.com/a/1190000010271226]]></content>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron中使用Bootstrap和JQuery]]></title>
    <url>%2F2018%2F05%2F01%2FElectron%E4%B8%AD%E4%BD%BF%E7%94%A8Bootstrap%E5%92%8CJQuery%2F</url>
    <content type="text"><![CDATA[一般网页都可以直接使用bootstrap和JQuery 的CDN来请求bootstrap和JQuery。但是做electron应用的时候希望做成本地的，因为不是每时每刻都可以联网。原以为 npm 安装之后直接用就可以，结果遇到了很多坑，这里记录下。 安装首先使用npm安装bootstrap 和 JQuery 12npm install bootstrap --savenpm install JQuery --save 然后就会发现有一行警告 npm WARN bootstrap@4.1.1 requires a peer of popper.js@^1.14.3 but none is installed. You must install peer dependencies yourself. 于是还需要安装 popper.js 1npm install popper.js --save 安装部分就完成了。 使用bootstrap 直接从安装文件里面拿就好，地址是 ./node_modules/bootstrap/dist/css/bootstrap.min.css 1&lt;link rel="stylesheet" href="./node_modules/bootstrap/dist/css/bootstrap.min.css"&gt; JQuery 就很坑了，google了好多资料，electron里面你应该这么写： 1&lt;script&gt;window.$ = window.jQuery = require('jquery');&lt;/script&gt; 不然会报错，很多神奇的错误。 关于bootstrap-datepicker的一个坑使用npm安装的bootstrap-datepicker完全没用，我从网上复制粘贴了整个bootstrap-datepicker.js 的代码，本地新建文件，然后&lt;script src = &quot;bootstrap-datepicker.js&quot;&gt;&lt;/script&gt;才可以正常使用 后来发现可以这样： 1npm install bootstrap-datepicker --save 然后 1&lt;script&gt; require('bootstrap-datepicker');&lt;/script&gt; 菜的抠脚]]></content>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[461. Hamming Distance]]></title>
    <url>%2F2018%2F04%2F28%2F461-Hamming-Distance%2F</url>
    <content type="text"><![CDATA[题目The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 2^31 . Example: Input: x = 1, y = 4 Output: 2 Explanation: 1231 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. 思路题目说 y &lt; 2^31 那写一个32次的循环，依次统计一共有多少个1就好。 代码123456789101112//C++int hammingDistance(int x, int y) &#123; int result = 0; int s = x^y; for(int i = 0;i&lt;32;i++) &#123; if(s &amp; 1 == 1) &#123; result ++; &#125; s = s&gt;&gt;1; &#125; return result;&#125; 然后看到别人思路貌似有个比32次循环更快的方法： 123456789//C++int hammingDistance(int x, int y) &#123; int dist = 0, n = x ^ y; while (n) &#123; ++dist; n &amp;= n - 1; &#125; return dist;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[14. Longest Common Prefix]]></title>
    <url>%2F2018%2F04%2F28%2F14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[题目Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [“flower”,”flow”,”flight”]Output: “fl” Example 2: Input: [“dog”,”racecar”,”car”]Output: “” Explanation: There is no common prefix among the input strings.Note: All given inputs are in lowercase letters a-z. 思路我的思路是以第一个字符串为标准设为result，依次寻找每个字符串的公共前缀，如果有不一样的就从result里把不一样的移除，剩下的result就是所求的公共前缀了。 然后就是看到别人的思路：从0开始依次遍历每一个字符串，如果是公共前缀就加到result里。 貌似我的比他快了一毫秒O(∩_∩)O~ 代码1234567891011121314151617181920212223//C++string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() == 0) &#123; return ""; &#125; string result = strs[0]; for(string s:strs) &#123; if(s.size()==0) &#123; return ""; &#125; for(int i = 0;i&lt;result.size() &amp;&amp; i&lt;s.size();i++) &#123; if(s[i] != result[i]) &#123; result.erase(i,result.size()-i); break; &#125; &#125; if(result.size()&gt;s.size()) &#123; result.erase(s.size(),result.size()-s.size()); &#125; &#125; return result;&#125; 从0开始依次遍历每一个字符串，如果是公共前缀就加到result里。 123456789//C++ string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = ""; for(int idx=0; strs.size()&gt;0; prefix+=strs[0][idx], idx++) for(int i=0; i&lt;strs.size(); i++) if(idx &gt;= strs[i].size() ||(i &gt; 0 &amp;&amp; strs[i][idx] != strs[i-1][idx])) return prefix; return prefix;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[371. Sum of Two Integers]]></title>
    <url>%2F2018%2F04%2F24%2F371-Sum-of-Two-Integers%2F</url>
    <content type="text"><![CDATA[题目Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Given a = 1 and b = 2, return 3. 思路不能用 + 号或者 - 号，那就只能用位操作了。位操作有四种： &amp; 与操作（AND operation）： 2 (0010) &amp; 7 (0111) =&gt; 2 (0010) | 或操作 （OR operation）： 2 (0010) | 7 (0111) =&gt; 7 (0111) ^ 异或操作 （XOR operation）： 2 (0010) ^ 7 (0111) =&gt; 5 (0101) ~ 非操作 （NOT operation）： ~2(0010) =&gt; -3 (1101) 补码，见文末 其中，最左边一位是符号位，代表正负，比如 1111 代表 -1 （补码） 1110 代表 -2 这题两个位置全为1的地方需要进一位，不全为1的地方直接异或操作就好。于是我们用一个carry来记录进位，每次进位完需要左移一位。 代码C++123456789101112131415//C++int getSum(int a, int b) &#123; if(a==0) &#123; return b; &#125; if(b==0) &#123; return a; &#125; while(b!=0) &#123; int carry = a &amp; b; a = a ^ b; b = carry&lt;&lt;1; &#125; return a;&#125; 扩展减法12345678910//C++int getSubtract(int a, int b) &#123; while (b != 0) &#123; int borrow = (~a) &amp; b; a = a ^ b; b = borrow &lt;&lt; 1; &#125; return a;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[167. Two Sum II - Input array is sorted]]></title>
    <url>%2F2018%2F04%2F23%2F167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[题目Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 思路跟Two Sum类似，不过这是排好序的，就只用用两个指针，一个指向数组头部，一个指向尾部，然后依次扫描就可以了。 代码12345678910111213141516171819//C++vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int l = 0, h = numbers.size()-1; vector&lt;int&gt; result; while(l&lt;h) &#123; if(numbers[l]+numbers[h]==target) &#123; result.push_back(l+1); result.push_back(h+1); break; &#125; else if(numbers[l]+numbers[h]&gt;target) &#123; h--; &#125; else &#123; l++; &#125; &#125; return result;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员能力矩阵]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%83%BD%E5%8A%9B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[转自Programmer Competency Matrix 注意:每个层次的知识都是渐增的，位于层次n，也蕴涵了你需了解所有低于层次n的知识。 计算机科学 Computer ScienceWorking with someone who has a good topcoder ranking would be an unbelievable piece of luck! 有一个黑客排行榜排名靠前的同事将会是一件无比幸运的事情。 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 数据结构 不知道数组和链表的差异 能够解释和使用数组，链表，字典等，并且能够用于实际的编程任务。 了解基本数据结构时间和空间的折中，比如数组vs 链表，能够解释如何实现哈希表和处理冲突，了解优先队列及其实现。 高等的数据结构的知识，比如B-树、二项堆、斐波那契堆、AVL树、红黑树、伸展树、跳跃表以及前缀树等。 算法 不能够找出一个数组各数的平均值(这令人难以置信，但是我的确在应聘者中遇到过) 基本的排序，搜索和数据的遍历和检索算法。 树，图，简单的贪婪算法和分而治之算法，能够适度了解矩阵该层的含义。 能够辨识和编写动态规划方案，良好的图算法知识，良好的数值估算的知识，能够辨别NP问题等。 编程体系 不知道何为编译器、链接器和解释器。 对编译器、链接器、解释器有基本的了解。知道什么是汇编代码以及在硬件层如何工作。有一些虚拟内存和分页知识。 了解内核模式vs用户模式,多线程，同步原语以及它们如何实现，能够阅读汇编代码。了解网络如何工作，了解网络协议和socket级别编程。 了解整个程序堆栈、硬件(CPU+内存+中断+微码)、二进制代码、汇编、静态和动态链接、编码、解释、JIT（just-in-time）编译、内存碎片回收、堆、栈、存储器编址… 软件工程 Software Engineering 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 源码版本控制 通过日期备份文件夹 VSS和初级的CVS/SVN用户 熟练地使用CVS和SVN特性。知道如何分支和归并，使用程序库补丁安装特性等 有分布式VCS系统的知识。尝试过Bzr/Mercurial/Darcs/Git 自动化编译 只知道在IDE下编译 知道如何编译在命令行下编译系统 能够安装一个脚本构建基本的系统 能够安装一个脚本来构建系统并且归档，安装程序，生成发布记录和给源码控制中的代码分配标签。 自动化测试 认为所有的测试都是测试员的工作。 能够编写自动化的单元测试，能够为正在编写的代码提出良好的测试用例。 按照TDD （Test Driven Development）方式编写代码。 了解并且能够有效自动化安装，载入/性能和UI测试 程序设计 ProgrammingThis is an often under rated but very critical criteria for judging a programmer. With the increase in outsourcing of programming tasks to places where English is not the native tongue this issue has become more prominent. I know of several projects that failed because the programmers could not understand what the intent of the communication was. 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 问题分解 只有直线式的代码，通过复制粘贴来复用 能够把问题分散到多个函数中 能够想出可复用的函数/对象来解决大题的问题 使用适宜的数据结构和算法，写出通用的/面向对象的代码来封装问题的易改变的层面。 系统分解 想不出比单一的文件/类更好的层面 如果不在同一平台或没采用相同的技术，能够把问题空间和设计方案分解。 能够设计跨技术/平台的系统。 能够在多个产品线和与外部体系一体化中虚拟化和设计复制的系统。同时也能够设计支持系统监视、报告、故障恢复等。 交流 不能向同伴表达想法/主意。匮乏拼写和语法的能力。 同伴能了解你在说什么。有良好的拼写和语法能力。 能够和同伴进行高效的交流 能够使用清晰的方式了解和交流想法/设计/主意/细则，能适应每种环境的交流 同一文件中代码组织 同一文件中组织没有依据 按照逻辑性或者易接近的方法。 代码分块和对于其他源文件来说是易于是释,引用其他源文件时有良好的注释。 文档头部有许可声明，总结，良好的注释，一致的空格缩进。文档外观美观。 The difference between this and the previous item is in the scale of organization, source tree organization relates to the entire set of artifacts that define the system. 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 跨文件代码组织 没够想过给代码跨文件组织 相关文件按文件夹分组 每个物理文件都有独立的目的，比如一个类的定义，一个特性的实现等。 代码在物理层组织紧密，在文件名上与设计和外观相匹配，可以通过文件分布方式洞察设计理念。 源码树组织 一切都放在一个文件夹内 初步地将代码分散进对应逻辑的文件夹。 没有循环依赖，二进制文件，库，文档，构建，第三方的代码都组织进合适的文件夹内。 源码树的物理布局与逻辑层次、组织方式相匹配。可以通过目录名称和组织方式洞察设计理念。 代码可读性 单音节的名称 （在国内应该是那些类似用汉语拼音命名的习惯） 对文件、变量、类、方法等，有良好的命名。 没有长函数、注释解释不常规的代码，bug修复,代码假设。 代码假设验证使用断言，自然的代码流，没有深层嵌套的条件和方法 防御性编码 不知道这个概念 检查代码中所有的参数，对关键的假设进行断言 确保检查了返回值和使代码失败的异常。 有自己的库来帮助防御性编程、编写单元测试模拟故障 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 错误处理 只给乐观的情形编码 基本的代码错误处理，抛出异常/生成错误 确保错误/异常留在程序中有良好的状态，资源，连接，内存都有被合适的清理。 在编码之前察觉可能出现的异常，在代码的所有层次中维持一致性的异常处理策略，提出整个系统的错误处理准则。 IDE IDE大部分用来进行文本编辑 了解其周围的接口，能够高效地通过菜单来使用IDE 了解最常操作的键盘快捷键 编写自定义宏 API 需要频繁地查阅文档 把最频繁使用的API记在脑子里 广阔且深入的API知识。 为了使实际任务中常用API使用更加便捷，编写过API的上层库，填补API之间的缺口。 框架 没有使用过主平台外的任何框架 听过但没用过平台下流行的可用框架 在专业的职位中使用过一个以上的框架，通晓各框架的特色。 某框架的作者 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 需求分析 接受给定的需求和代码规格 能对规格的遗漏提出疑问 了解全面情况，提出需要被规格化的整体范围。 能够提出更好的可选方案，根据经验的浮现给出需求 脚本 不具备脚本工具的知识 批处理文件/shell脚本 Perl/Python/Ruby/VBScript/Powershell 写过并且发表过可重用的代码 数据库 认为Excel就是数据库 知道基本的数据库概念，规范化、ACID（原子性Atomicity、一致性Consistency、隔离性Isolation、持久性Durability）、事务化，能够写简单的select语句 能够牢记在运行时必要查询中设计良好的规范化数据库模式， 精通用户视图，存储过程，触发器和用户定义类型。知道聚集与非聚集索引之间的差异。精通使用ORM（Object Relational Mapping对象关系映射）工具 能做基本的数据库管理，性能优化，索引优化，编写高级的select查询，能够使用相关sql来替换游标，理解数据内部的存储，了解如何镜像、复制数据库。知道两段数据提交如何工作 经验 Experience 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 专业语言经验 命令式语言和面向对象语言 命令式语言,面向对象语言和说明型语言(SQL),如果了解静态类型vs动态类型，弱类型vs强类型则有加分 函数式语言,如果了解延缓求值，局部套用函数，延续则有加分 并发语言(Erlang, Oz) 逻辑语言(Prolog) 专业平台经验（年） 1 2-3 4-5 6+ 专业经验年龄（年） 1 2-5 6-9 10+ 领域知识 没有该领域的知识 在该领域中曾经至少为一个产品工作过 在同一领域中为多个产品工作过 领域专家。在该领域设计和实现数种产品/方案。精通该领域使用的标准条款和协议 学识 Knowledge 2^n (Levenl 0) n^2 (Level 1) n(Level 2) log(n) (Level 3) 工具知识 仅限于主要的IDE(VS.Net, Eclipse等) 知道一些流行和标准工具的备选方案 对编辑器、调试器、IDE、开源的备选方案有很好的了解。比如某人了解大多数Scott Hanselman的威力工具列表中的工具，使用过ORM工具。 实际地编写过工具和脚本，如果这些被发布则有加分 语言接触 命令式语言和面向对象语言 命令式语言、面向对象语言和说明型语言(SQL),如果了解静态类型vs动态类型、弱类型vs强类型则有加分 函数式语言,如果了解延缓求值、局部套用函数、continuations （源于scheme中的一种高级控制结构）则有加分 并发语言(Erlang, Oz) 逻辑语言(Prolog) 代码库知识 从来没有查询过代码库 基本的代码层知识，了解如果构建系统 良好的代码库工作知识，实现过几次bug修复或者完成了一些细小的特性 实现了代码库中多个大型特性，能够轻松地将多数特性的需求变更具体化，从容地处理bug修复。 下一代技术知识 从来没听说过即将到来的技术 听说过某领域即将到来的技术 下载过alpha preview/CTP/beta版本，并且读过一些文章和手册 试用过预览版而且实际地构建过某物，如果共享给其他人的话则有加分 平台内部 对平台内部毫无所知 有平台基本的内部工作的知识 深度的平台内部知识，能够设想平台如何将程序转换成可执行代码。 编写过增强平台或者为其平台内部提供信息的工具。比如，反汇编工具，反编译工具，调试工具等。 书籍 菜鸟系列，21天系列，24小时系列，蠢货系列… 《代码大全》(《Code Complete》)，《别让我思考》(《Don’t Make me Think》), 《精通正则表达式》(《Mastering Regular Expressions》) 《设计模式》（《Design Patterns》），《人件》（《Peopleware》），《代码珠玑》（《Programming Pearls》），《算法设计手册》（《 Algorithm Design Manual》），《程序员修炼之道》（《Pragmatic Programmer》），《人月神话》（《Mythical Man month》） 《计算机程序设计与解释》（《Structure and Interpretation of Computer Programs》），《事务处理:概念与技术》(《Concepts Techniques》)，《计算机程序设计模型》（《Models of Computer Programming》），《计算机程序设计艺术》（《 Art of Computer Programming》），《数据库系统导论》 C.J Date版（《Database systems》by C. J Date），《Thinking Forth》 ，《Little Schemer》 博客 听过但是从来抽不出空去接触 阅读一些科技/编程/软件工程的博客，并且经常的收听一些播客 维护一些博客的链接，收集博主分享的有用的文章和工具 维护一个在编程方面，分享有个人见解和思考的博客]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[292. Nim Game]]></title>
    <url>%2F2018%2F04%2F18%2F292-Nim-Game%2F</url>
    <content type="text"><![CDATA[题目You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 思路靠脑子想一下子没想出来（菜的抠脚）。 其实这题倒过来想，什么情况必输。那就是会后一轮剩下的石头总数等于4；那如何保证最后一轮剩下的石头数量等于4呢，就是倒数第二轮剩下的石头有8个……以此类推，得出的结论就是石头数量是4的倍数不可能赢。 于是判断石头数量是不是4的倍数就可以了。 代码1234//C++bool canWinNim(int n) &#123; return n % 4;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8. String to Integer (atoi)]]></title>
    <url>%2F2018%2F04%2F16%2F8-String-to-Integer-atoi%2F</url>
    <content type="text"><![CDATA[题目Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31 ) is returned. Example 1: Input: “42”Output: 42 Example 2: Input: “&nbsp;&nbsp;&nbsp;&nbsp; -42”Output: -42Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42. Example 3: Input: “4193 with words”Output: 4193Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit. Example 4: Input: “words and 987”Output: 0Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: “-91283472332”Output: -2147483648Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 思路这题太他妈傻逼了！！！！ 题目5个要求： string 转 int 丢弃数字前面的空格 丢弃数字后面的字符串 无视字符串后面的数字 超过INT_MAX (2^31 − 1) 或 INT_MIN (−2^31 )返回边界值 本来挺简单的，题目写if else就好，但是测试用例里面居然还有+-2,+1这种情况！！ 什么破玩意。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//C++int myAtoi(string str) &#123; int flag = 1; double result = 0; int i = 0; while(str[i] == ' ') &#123; i++; &#125; if(str[i] == '-'||str[i] == '+') &#123; if(str[i+1] != '-'||str[i+1] != '-') &#123; if(str[i] == '-') &#123; flag = -1; &#125; i++; &#125; else &#123; return 0; &#125; &#125; while(str[i]&lt;='9'&amp;&amp;str[i]&gt;='0'&amp;&amp;i&lt;str.size()) &#123; result*=10; result+=(int)str[i] - 48; i++; &#125; result *= flag; result = result&lt;INT_MIN?INT_MIN:result; result = result&gt;INT_MAX?INT_MAX:result; return result;&#125;//简洁版 https://leetcode.com/problems/string-to-integer-atoi/discuss/4642/8ms-C++-solution-easy-to-understandint myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(' '); if(str[i] == '-' || str[i] == '+') indicator = (str[i++] == '-')? -1 : 1; while('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; result = result*10 + (str[i++]-'0'); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6. ZigZag Conversion]]></title>
    <url>%2F2018%2F04%2F16%2F6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[题目The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H N A P L S I I G Y I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 思路这题指的zigzag pattern一开始我也不是很明白，看了Discuss之后才搞清楚，大概就是这样： n=4的时候，图案是这样： 12341 7 132 6 8 12 143 5 9 11 154 10 3行的时候图案是这样： 1231 5 9 122 4 6 8 10 13 153 7 11 14 2行： 121 3 5 7 92 4 6 8 10 所以根据上述规律，可以发现第一行和最后一行每个数字之间都是相隔2n-2；然后斜着那条线，字符的位置永远与当前周期的前一个数字相隔2n-2-2i（i是行数），所以在第j个周期的第i行，那个字符的位置应该是j+2n-2-2i。 代码12345678910111213141516171819202122//C++string convert(string s, int numRows) &#123; if(s.size()&lt;2) &#123; return s; &#125; if(numRows==1) &#123; return s; &#125; string result; for(int i = 0;i&lt;numRows;i++) &#123; for(int j = i;j&lt;s.size();j+=2*numRows-2) &#123; result.push_back(s[j]); if(i!=0 &amp;&amp; i!=numRows-1) &#123; if(j+2*numRows-2-2*i&lt;s.size()) &#123; result.push_back(s[j+2*numRows-2-2*i]); &#125; &#125; &#125; &#125; return result;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[458. Poor Pigs]]></title>
    <url>%2F2018%2F04%2F16%2F458-Poor-Pigs%2F</url>
    <content type="text"><![CDATA[题目There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up: If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the “poison” bucket within p minutes? There is exact one bucket with poison. 思路看了别人一个特别吊的思路：https://leetcode.com/problems/poor-pigs/discuss/94266/Another-explanation-and-solution 假设我们有两只猪，喝了有毒的水之后15分钟死亡，一共有60分钟，那么我们最多可以在25个桶里找到有毒的那一桶。方法如下，将25个桶排列成5X5的一块： 123451 2 3 4 56 7 8 9 1011 12 13 14 1516 17 18 19 2021 22 23 24 25 然后我们用第一只猪喝每一行的水，第二只猪喝每一列的水。比如，第一只猪喝1,2,3,4,5号桶的水，然后等15分钟，再喝6,7,8,9,10 号桶的水，然后再等15分钟；第二只猪喝1,6,11,16,21号桶的水，等15分钟再喝2,7,12,17,22号桶的水，以此类推。。。 我们一共有60分钟，毒药发作时间是15分钟，那么我们在规定时间内一共可以测4轮。假设第一只猪第三轮死了，我们可以确定有毒的那桶在第三行，第二只猪第四轮死了，我们就可以确定有毒那桶在第三行第四列，也就是19。 假设我们有三只猪，我们就可以用一个5x5x5的立方体来测，一共125桶水。 综上所诉我们可以的到公式 \[ buckets = (\frac{minutesToTest}{minutesToDie})^{pigs}\] 代码12345678//C++int poorPigs(int buckets, int minutesToDie, int minutesToTest) &#123; int pigs = 0; while(pow((minutesToTest/minutesToDie+1),pigs) &lt; buckets) &#123; pigs++; &#125; return pigs;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5. Longest Palindromic Substring]]></title>
    <url>%2F2018%2F04%2F13%2F5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[题目Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example 2: Input: “cbbd”Output: “bb” 思路动态规划法假设字符串长度为n，那么我们可以用一个大小为dp[n][n]的二维数组来代表字符串状态。其中，dp[i][j]代表i~j区间的字符是否为回文串。 当i=j时，只有一个字符，肯定是回文串； 当i=j+1时，说明是相邻字符，只用判断s[i]是否等于s[j]； 当字符不相邻，也就是i-j&gt;2时，判断s[i]是否等于s[j]以及dp[i+1][j-1]是否为回文串即可。 通过上面的分析可以写出递推公式如下： 12345dp[i, j] = 1 //if i == jdp[i, j] = s[i] == s[j] //if j = i + 1dp[i, j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1] //if j &gt; i + 1 例如，字符串aabba每一步dp的状态依次如下: 12345678910111213141516171819202122232425262728293031323334// a1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 // aa1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 // aab1 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 // aabb1 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 // aabba1 1 0 0 0 0 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 1 Manacher’s Algorithm 马拉车算法http://www.cnblogs.com/grandyang/p/4475985.htmlhttps://blog.csdn.net/dyx404514/article/details/42061017 最逆天的地方在于他把时间复杂度提高到了线性O(n)。 代码动态规划1234567891011121314151617//C++string longestPalindrome(string s) &#123; int dp[s.size()][s.size()] = &#123;0&#125;; int left =0,right=0,len=0; for (int j = 0; j &lt; s.size(); ++j) &#123; for (int i = 0; i &lt; j; ++i) &#123; dp[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])); if (dp[i][j] &amp;&amp; len &lt; j - i + 1) &#123; len = j - i + 1; left = i; right = j; &#125; &#125; dp[j][j] = 1; &#125; return s.substr(left,right-left+1);&#125; Manacher’s Algorithm 马拉车算法12345678910111213141516171819202122232425//C++string Manacher(string s) &#123; // Insert '#' string t = "$#"; for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += "#"; &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123; p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (t[i + p[i]] == t[i - p[i]]) ++p[i]; if (mx &lt; i + p[i]) &#123; mx = i + p[i]; id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return s.substr((resCenter - resLen) / 2, resLen - 1);&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F04%2F12%2F21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[题目Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路因为链表是有序的所以依次比较两个链表每个值大小添加到新的链表了就好了。就是归并排序。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//C++/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode head(-1); ListNode *tail = &amp;head; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val&lt;l2-&gt;val) &#123; tail-&gt;next = l1; l1=l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1?l1:l2; return head.next;&#125;//递归法ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) &#123;return l2;&#125; if(!l2) &#123;return l1;&#125; if(l1-&gt;val&gt;l2-&gt;val) &#123; ListNode* temp =l2; temp-&gt;next = mergeTwoLists(l1,l2-&gt;next); return temp; &#125; else &#123; ListNode* temp =l1; temp-&gt;next = mergeTwoLists(l1-&gt;next,l2); return temp; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13. Roman to Integer]]></title>
    <url>%2F2018%2F04%2F12%2F13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[题目Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 思路罗马数字共有7个，即Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000）。 重复数次：一个罗马数字重复几次，就表示这个数的几倍。 右加左减： 在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。 在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。 左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV但是，左减时不可跨越一个位值。比如，99不可以用IC（ {\displaystyle 100-1} 100-1）表示，而是用XCIX（ {\displaystyle [100-10]+[10-1]} [100-10]+[10-1]）表示。（等同于阿拉伯数字每位数字分别表示。） 左减数字必须为一位，比如8写成VIII，而非IIX。 右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。） 参考自维基百科 所以从右往左依次读取每一个字符，比较他们的大小。如果右边一位字符的值大于当前字符的值，就在总结果里面减去当前的值，如果大于或等于当前的值就在总结果加上当前的值。 代码1234567891011121314//C++int romanToInt(string s) &#123; map&lt;char,int&gt; romanMap = &#123;&#123;'I',1&#125;,&#123;'V',5&#125;,&#123;'X',10&#125;,&#123;'L',50&#125;,&#123;'C',100&#125;,&#123;'D',500&#125;,&#123;'M',1000&#125;&#125;; int result = romanMap[s[s.size()-1]]; for(int i = s.size()-2;i&gt;=0;i--) &#123; if(romanMap[s[i]]&gt;=romanMap[s[i+1]]) &#123; result+=romanMap[s[i]]; &#125; else &#123; result-=romanMap[s[i]]; &#125; &#125; return result;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[9. Palindrome Number]]></title>
    <url>%2F2018%2F04%2F12%2F9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[题目Determine whether an integer is a palindrome. Do this without extra space. 思路声明一个临时变量sum，辗转相除以及辗转相乘，然后比较sum和输入量的大小即可。 代码12345678910111213//C++bool isPalindrome(int x) &#123; if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) &#123; return false; &#125; int sum=0; while(x&gt;sum) &#123; sum*=10; sum+=x%10; x/=10; &#125; return (sum==x)||(x==sum/10);&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国航空航天博物馆分管--史蒂文·乌德沃尔哈齐中心]]></title>
    <url>%2F2018%2F04%2F07%2F%E7%BE%8E%E5%9B%BD%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%8D%9A%E7%89%A9%E9%A6%86%E5%88%86%E7%AE%A1-%E5%8F%B2%E8%92%82%E6%96%87%C2%B7%E4%B9%8C%E5%BE%B7%E6%B2%83%E5%B0%94%E5%93%88%E9%BD%90%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[大部分去华盛顿玩的人都知道美国航空航天博物馆就在市中心的独立大道上，白宫南草坪旁边，去华盛顿的人都会去那里玩（好像女生除外）。 但是！！！！在华盛顿西北的杜勒斯国际机场其实还有一个分馆，绝对不容错过！ 新馆建于2003年，考虑到市中心的博物馆面积太小，很多展品没法放进去，而美国航空工业又是吊打全世界，这么小一个博物馆实在是不够炫耀，于是新建了这座博物馆。 博物馆名叫 史蒂文·乌德沃尔哈齐中心（Steven F. Udvar-Hazy Center） 位于 华盛顿杜勒斯国际机场 地址是:14390 Air and Space Museum Pkwy, Chantilly, VA 20151。 博物馆免费，但是每辆车收15块钱停车费。由于离市区太远你必须开车去，相当于每车人15块钱吧。 SR-71一进去首先看到的就是著名的黑鸟SR-71，在《变形金刚2》中出现，天火的原型！！ 尾部特写 B-29B-29超级堡垒轰炸机，亦称B-29超级空中堡垒，不仅是二次大战时各国空军中最大型的飞机，同时亦是当时集各种新科技的最先进的武器之一。总生产量为3,900架左右。但是这一架不一样！！ 这一架的名字叫做Enola Gay，没错就是当年在广岛上空扔下原子弹那架 艾诺拉·盖（Enola Gay）是一架隶属于美国陆军航空军第509混合飞行大队的B-29超级堡垒轰炸机，“艾诺拉·盖”这命名源自该机机长保罗·蒂贝茨（Paul Tibbets）母亲的名字——Enola Gay Tibbets。此飞机执行了于日本时间1945年8月6日早上8点15分，在广岛上空掷下“小男孩”原子弹的任务。 应该是老飞行员在和游客介绍这架飞机 F4U 海盗据美国海军统计，第二次世界大战中F4U的击落比率为11:1，即每击落11架敌机才有1架被击落，拥有着傲人战绩；所以也让部分日本飞行员认为海盗式是二战中美军最强悍的战机。《皇牌空战》里的轰炸机啊，满满的回忆~ 米格15 和 F86佩刀米格15， 抗美援朝的工程，中国人口中的歼五，五爷。 旁边就是米格15 的死对头F-86佩刀，从朝鲜打到金门。 米格21 和 F4 鬼怪也是两个死对头 F14是根据美国海军20世纪70年代至80年代舰队防空和护航的要求研制的双座双发超音速多用途舰载战斗机, F4的代替品。 看过《壮志凌云》的同学一定不会陌生！！不过这款飞机已经退役了。 F35 闪电美国的第四代飞机，由洛克希德马丁公司研发，F22的辅助机种，美国空军海军未来的机种。 发现号航天飞机最厉害的是博物馆里还塞了架航天飞机！！ 美国是世界上第一个拥有与实际操作航天飞机、并是唯一成功以航天飞机进行过载人任务的国家，也是机队阵容最庞大的国家。其中，挑战者号在发射过程中爆炸，哥伦比亚号在返回地球时解体。 这架发现号航天飞机，于2011年3月9日退役，完成了39次飞行任务。 如果你是航空迷，来华盛顿一定不能错过这个博物馆。博物馆仍在不停地安置展品，截止2008年11月，已经有163架飞机和154艘飞船陈列。最终计划安放200余架飞机~]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121. Best Time to Buy and Sell Stock]]></title>
    <url>%2F2018%2F02%2F06%2F121-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[题目Say you have an array for which the i^th element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: 1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: 1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 思路遍历一遍数组，不断地更新最小值和利润的的值就好。 代码12345678910111213int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int profit = 0; int min = INT_MAX; for(int i:prices) &#123; if(i&lt;min) &#123; min = i; &#125; else if(i-min&gt;profit)&#123; profit = i - min; &#125; &#125; return profit;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F01%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法是最基本最常用的算法，是算法与数据结构的基础，也是面试中常见的一类问题。 插入排序 Insertion sort插入排序方法类似于我们整理手上的扑克牌，在数据量小的时候是一种高效的的排序算法。 插入排序通常只需要用到O(1)的额外空间： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 伪代码升序 示例代码1234567891011void insertionSort(vector&lt;int&gt; &amp;a) &#123; for(int j = 1;j&lt;a.size();j++) &#123; int key = a[j]; int i = j - 1; while (i&gt;=0 &amp;&amp; a[i]&gt;key) &#123; a[i+1] = a[i]; i-- ; &#125; a[i+1] = key; &#125;&#125; 归并排序归并排序是分治法的一个实现： Divide： 把长度为n的序列分成两个长度为n/2的子序列 Conquer：递归的使用归并排序将子序列排序 Combine：将两个排好序的子序列合并成一个序列 伪代码：归并操作： 例如上图所示，归并操作将A分成L和R两个数组，然后根据每个元素的大小依次将元素重新填入到A中。 归并排序： 代码1234567891011121314151617181920212223242526272829303132333435363738//C++void merage(vector&lt;int&gt; &amp;A,int p, int q, int r) &#123; int n1 = q - p +1; int n2 = r - q; vector&lt;int&gt; L(n1+1), R(n2+1); for (int i = 0; i &lt; n1; i++) &#123; L[i] = A[p+i-1]; &#125; for (int j = 0; j &lt; n2; j++) &#123; R[j] = A[q + j]; &#125; L[n1+1] = INT_MAX; R[n1+1] = INT_MAX; int i = 0; int j = 0; for(int k = p;k&lt;r;k++) &#123; if(L[i]&lt;=R[j]) &#123; A[k] = L[i]; i++; &#125; else &#123; A[k] = R[j]; j++; &#125; &#125;&#125;void merage_sort(vector&lt;int&gt; &amp;A,int p, int r) &#123; if (p&lt;r) &#123; int q = int((p+r-0.5)/2); merage_sort(A, p, q); merage_sort(A, q+1, r); merage(A, p, q, r); &#125;&#125; 冒泡排序冒泡排序是一种简单的排序方法，通过重复的走访需要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 冒泡排序的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 伪代码 代码123456789void bubbleSort(vector&lt;int&gt; &amp;a) &#123; for (int i = 0; i&lt;a.size(); i++) &#123; for(int j = a.size()-1;j&gt;i+1;j--) &#123; if (a[i]&gt;a[j]) &#123; swap(a[i], a[j]); &#125; &#125; &#125;&#125; 参考资料： Introduction to Algorithms Thomas H. Cormen https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. 3Sum]]></title>
    <url>%2F2018%2F01%2F23%2F15-3Sum%2F</url>
    <content type="text"><![CDATA[题目Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路为了避免重复的情况，数组需要先排序一下。 固定一个数字，然后再用两个指针，依次遍历整个数组（类似于two sum），找出符合条件的三个数字。 比如排好序以后的数字是 a b c d e f, 那么第一次固定a, 在剩下的 b c d e f 中进行2sum, 完了以后第二次枚举b, 只需要在 c d e f 中进行2sum，这样就避免了重复。 代码1234567891011121314151617181920212223242526272829//C++ Solutionvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; result; for(int i = 0;i&lt;nums.size();i++) &#123; while(i&gt;0 &amp;&amp; (nums[i]==nums[i-1])) &#123; ++i; &#125; int l = i + 1; int h = nums.size() -1; while(l&lt;h) &#123; int sum = nums[i] + nums[l] + nums[h]; if(sum == 0) &#123; result.push_back(&#123;nums[i] , nums[l] , nums[h]&#125;); while (nums[l]==nums[l+1]) ++l; while (nums[h]==nums[h-1]) --h; ++l; --h; &#125; else if(sum &gt; 0) &#123; --h; &#125; else &#123; ++l; &#125; &#125; &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031323334//Java Solutionpublic List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; results = new LinkedList&lt;&gt;(); for(int i=0;i&lt;nums.length;i++) &#123; int start = i+1; int end = nums.length-1; while(start&lt;end) &#123; if(-nums[i]&lt;nums[start]+nums[end]) &#123; end--; &#125; else if(-nums[i]&gt;nums[start]+nums[end]) &#123; start++; &#125; else &#123; results.add(Arrays.asList(nums[i], nums[start], nums[end])); while(start&lt;end &amp;&amp; nums[start] == nums[start+1]) &#123; start++; &#125; while(start&lt;end &amp;&amp; nums[end] == nums[end-1]) &#123; end--; &#125; start++; end--; &#125; &#125; while(i&lt;nums.length-1 &amp;&amp; nums[i+1]==nums[i]) &#123; i++; &#125; &#125; return results;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2018%2F01%2F18%2F2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[题目You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路一开始没看清题目还卡了一下，后来仔细一看他输入的数字是倒过来放的。于是用一个新链表把结果存起来就好了。 代码1234567891011121314C++ SolutionListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int temp = 0; while(l1||l2||temp) &#123; int sum = (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + temp; p-&gt;next = new ListNode(sum%10); temp = sum/10; p = p-&gt;next; l1 = l1?l1-&gt;next:l1; l2 = l2?l2-&gt;next:l2; &#125; return preHead.next;&#125; 123456789101112131415//Java Solutionpublic ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode p = head; int temp=0; while(l1!=null || l2!=null || temp!=0) &#123; int sum = (l1!=null?l1.val:0) + (l2!=null?l2.val:0)+temp; temp = sum/10; p.next = new ListNode(sum%10); p = p.next; l1=l1!=null?l1.next:l1; l2=l2!=null?l2.next:l2; &#125; return head.next;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[146. LRU Cache]]></title>
    <url>%2F2018%2F01%2F14%2F146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[题目Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 / capacity / ); cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 思路设计一个LRU算法。 操作系统中进行内存管理中时采用一些页面置换算法，如LRU、LFU和FIFO等。其中LRU应用较为广泛。LRU的全称是Least Recently Used，即最近最少使用算法。当访问数据时，如缓存中有数据，则将该数据移动至链表的顶端；没有该数据则在顶端加入该数据，并移除链表中的最不常使用的数据。 这题应该用双链表来实现，使用Queue的话会超时因为Queue的查找使用了O(n)，双链表可以在O(1)完成get(key)`put(key)`操作。 Cache 使用一个HashMap来达到O(1)的查找效果。 Get 用一个双链表，自定义一个Node，里面有key，value，preNode，nextNode。 假如miss，返回-1（rise exception？） 假如 hit： 记录当前节点的value 在双链表中删除这个Node 链表头部加入这个Node Set 假如miss： 假如List.Size()&lt;Capacity： 添加新节点到队头 增加新节点到map 假如 List.Size()&gt;Capacity： 删掉队尾节点 增加新节点到map 添加新节点到队头 假如 hit： 更新vaule值 节点移到队头 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class LRUCache &#123; class Node &#123; int key; int value; Node pre; Node next; public Node(int key, int value) &#123; this.key = key; this.value = value; &#125;&#125; HashMap&lt;Integer, Node&gt; map; int capacity, count; Node head, tail; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;Integer, Node&gt;(); head = new Node(0,0); tail = new Node(0,0); head.next = tail; head.pre = null; tail.pre = head; tail.next = null; count = 0; &#125; private void removeNode(Node node) &#123; node.pre.next = node.next; node.next.pre = node.pre; &#125; private void addNodeToHead(Node node) &#123; node.next = head.next; node.next.pre = node; node.pre = head; head.next = node; &#125; public int get(int key) &#123; Node node = map.get(key); if(node !=null) &#123; int result = node.value; removeNode(node); addNodeToHead(node); return result; &#125; else &#123; return -1; &#125; &#125; public void put(int key, int value) &#123; if(map.get(key)!=null) &#123; Node node = map.get(key); node.value = value; removeNode(node); addNodeToHead(node); &#125; else &#123; Node node = new Node(key,value); map.put(key,node); if(count&lt;capacity) &#123; count++; &#125; else &#123; map.remove(tail.pre.key); removeNode(tail.pre); &#125; addNodeToHead(node); &#125; &#125;&#125; 12345678910111213141516171819202122232425```Java里面有个数据结构叫`LinkedHashMap`，刚好可以满足LRU算法，不过面试的时候应该不会让你用吧，不然对我们这种C++选手太不公平了！```java//Java Solutionpublic class LRUCache &#123; private LinkedHashMap&lt;Integer, Integer&gt; map; private final int CAPACITY; public LRUCache(int capacity) &#123; CAPACITY = capacity; map = new LinkedHashMap&lt;Integer, Integer&gt;(capacity, 0.75f, true)&#123; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; CAPACITY; &#125; &#125;; &#125; public int get(int key) &#123; return map.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; map.put(key, value); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[374. Guess Number Higher or Lower]]></title>
    <url>%2F2018%2F01%2F14%2F374-Guess-Number-Higher-or-Lower%2F</url>
    <content type="text"><![CDATA[题目We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower1 : My number is higher0 : Congrats! You got it! Example: n = 10, I pick 6. Return 6. 思路实现一个二分搜索就好了。。 代码12345678910111213141516int guessNumber(int n) &#123; int start = 1, end = n, mid = (end-start)/2+start; int g = guess(mid); while(g!=0) &#123; if(g==-1) &#123; end = mid-1; &#125; else &#123; start = mid+1; &#125; mid = (end-start)/2+start; g = guess(mid); &#125; return mid; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[345. Reverse Vowels of a String]]></title>
    <url>%2F2018%2F01%2F14%2F345-Reverse-Vowels-of-a-String%2F</url>
    <content type="text"><![CDATA[题目Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Given s = “hello”, return “holle”. Example 2: Given s = “leetcode”, return “leotcede”. Note: The vowels does not include the letter “y”. 思路用两个index 分别记录头和尾的位置，然后一一交换元音字母就好。 代码1234567891011121314151617181920212223242526272829303132bool judge(char a) &#123; switch(a) &#123; case 'a': case 'e': case 'i': case 'o': case 'u': case 'A': case 'E': case 'I': case 'O': case 'U': return true; default: return false; &#125; &#125; string reverseVowels(string s) &#123; int start = 0, end = s.size()-1; while(end&gt;start) &#123; if(!judge(s[start])) &#123; start++; &#125; else if(!judge(s[end])) &#123; end--; &#125; else &#123; swap(s[start++],s[end--]); &#125; &#125; return s;&#125; 12345678910111213141516171819202122232425262728293031323334353637//Java Solution boolean judge(char a) &#123; switch(a) &#123; case 'a': case 'e': case 'i': case 'o': case 'u': case 'A': case 'E': case 'I': case 'O': case 'U': return true; default: return false; &#125;&#125;public String reverseVowels(String s) &#123; int start = 0, end = s.length()-1; char[] chars = s.toCharArray(); while(end&gt;start) &#123; if(!judge(chars[start])) &#123; start++; &#125; else if(!judge(chars[end])) &#123; end--; &#125; else &#123; char temp = chars[start]; chars[start] = chars[end]; chars[end] = temp; start++; end--; &#125; &#125; return new String(chars);&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[231. Power of Two]]></title>
    <url>%2F2018%2F01%2F14%2F231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[题目Given an integer, write a function to determine if it is a power of two. 思路循环除以2看是否等于1。 或者 整型的范围是-2147483648 (-2^31) ~ 2147483647 (2^31-1)，用最大的整型 2^30(1073741824)去除它看是否能除尽。 代码12345678//C++ Solutionbool isPowerOfTwo(int n) &#123; if(n==1) return true; if(n==0||n%2!=0) return false; else &#123; return isPowerOfTwo(n/2); &#125;&#125; 12345//C++ Solutionbool isPowerOfTwo(int n) &#123; if(n&lt;=0) return false; return 1073741824%n==0;&#125; Bit OperationDiscuss 上还有一种位操作的方法： 如果n是2的X次方，那么： n = 2 ^ 0 = 1 = 0b0000…00000001, and (n - 1) = 0 = 0b0000…0000.n = 2 ^ 1 = 2 = 0b0000…00000010, and (n - 1) = 1 = 0b0000…0001.n = 2 ^ 2 = 4 = 0b0000…00000100, and (n - 1) = 3 = 0b0000…0011.n = 2 ^ 3 = 8 = 0b0000…00001000, and (n - 1) = 7 = 0b0000…0111. 于是我们可以得出 n &amp; (n-1) == 0b0000…0000 == 0 `c++ bool isPowerOfTwo(int n) { return (n&gt;0)&amp;&amp;((n &amp; (n-1))==0); }]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[326. Power of Three]]></title>
    <url>%2F2018%2F01%2F13%2F326-Power-of-Three%2F</url>
    <content type="text"><![CDATA[题目Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 思路如果一个数是3的X次方，那么把这个数循环除以3一定会等于1，所以写个循环就好。 代码1234567//C++ Solutionbool isPowerOfThree(int n) &#123; while(n&gt;0&amp;&amp;n%3==0) &#123; n = n/3; &#125; return n == 1;&#125; 看到题目说不能用递归，顺便想了下用递归怎么做（我也不能理解我这脑回路 12345678//C++ Solutionbool isPowerOfThree(int n) &#123; if(n == 1) return true; if(n%3!=0||n&lt;=0) return false; else &#123; return isPowerOfThree(n/3); &#125;&#125; 然后还看到了Discuss上两种神奇的解法： 任何一个3的x次方一定能被int型里最大的3的x次方整除1162261467 是3^19,3^20 比int大 1234//C++ Solutionbool isPowerOfThree(int n) &#123; return n&gt;0?!(1162261467 % n):0; &#125; log函数如果N是3的X次方： 那么 3^N == N 那么 log (3^X) == log N 那么 X log 3 == log N 那么 X == (log N) / (log 3) 根据题目，X必须是个整数，所以只用判断X是不是整数就好 但是由于计算机存储数字的方式，log(N)不可能被精确的存下来，所以判断的方式需要这样实现： 12345//C++ Solutionbool isPowerOfThree(int n) &#123; double x = log(n)/log(3); return abs(x-rint(x))&lt;=0.00000000000001;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[463. Island Perimeter]]></title>
    <url>%2F2018%2F01%2F13%2F463-Island-Perimeter%2F</url>
    <content type="text"><![CDATA[题目You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example: [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image &gt; below: 思路给定一个二维数组，其中1表示岛屿，0表示水，求岛的周长。 一种解法是遍历一遍，如果遇到岛屿(1)看周围是不是水(0)，如果是的话周长++。 然后还有一种比较巧的解法是记录岛屿的数量和每个岛屿下方以及右方岛屿的数量（邻居数）。这样周长就可以由一个公式得到： \[ 周长=4\times岛屿数-2\times邻居数\] 代码123456789101112131415161718//C++ Solutionint islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int islands = 0, neighbors = 0; for(int i=0;i&lt;grid.size();i++) &#123; for(int j = 0;j&lt;grid[0].size();j++) &#123; if(grid[i][j] == 1) &#123; islands++; if(i&lt;grid.size()-1&amp;&amp;grid[i+1][j]==1) &#123; neighbors ++; &#125; if(j&lt;grid[0].size()-1&amp;&amp;grid[i][j+1]==1) &#123; neighbors ++; &#125; &#125; &#125; &#125; return islands*4-neighbors*2;&#125; 123456789101112131415161718//Java Solutionpublic int islandPerimeter(int[][] grid) &#123; int islands=0, neighbors = 0; for(int i = 0;i&lt;grid.length;i++) &#123; for(int j=0;j&lt;grid[0].length;j++) &#123; if(grid[i][j]==1) &#123; islands++; if(i&lt;grid.length-1&amp;&amp;grid[i+1][j]==1) &#123; neighbors ++; &#125; if(j&lt;grid[0].length-1&amp;&amp;grid[i][j+1]==1) &#123; neighbors ++; &#125; &#125; &#125; &#125; return islands*4-neighbors*2;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2F2018%2F01%2F13%2F155-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. 思路题目要求在O(1)时间内实现，所以用一个Stack应该是不可能的，于是这题应该是用两个Stack，一个当做正常的Stack，一个专门用来储存最小值。 不过后面看了Discuss，有人用一个栈就做出来了…… 代码1234567891011121314151617181920212223242526272829303132333435363738//C++ Solutionclass MinStack &#123; /** initialize your data structure here. */private: stack&lt;int&gt; nor; stack&lt;int&gt; min;public: void push(int x) &#123; if(min.empty()||x&lt;=min.top()) &#123; min.push(x); &#125; nor.push(x); &#125; void pop() &#123; if(nor.top()==min.top()) &#123; min.pop(); &#125; nor.pop(); &#125; int top() &#123; return nor.top(); &#125; int getMin() &#123; return min.top(); &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 123456789101112131415161718192021222324252627282930//Java Solutionclass MinStack &#123; /** initialize your data structure here. */ Stack&lt;Integer&gt; nor = new Stack&lt;&gt;(); Stack&lt;Integer&gt; min = new Stack&lt;&gt;(); public MinStack() &#123; &#125; public void push(int x) &#123; if(min.isEmpty()||x&lt;=min.peek()) &#123; min.push(x); &#125; nor.push(x); &#125; public void pop() &#123; if(nor.peek() == min.peek()) &#123; min.pop();&#125; nor.pop(); &#125; public int top() &#123; return nor.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125; 一个栈的方法12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; long min; Stack&lt;Long&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; public void push(int x) &#123; if (stack.isEmpty())&#123; stack.push(0L); min=x; &#125;else&#123; stack.push(x-min);//Could be negative if min value needs to change if (x&lt;min) min=x; &#125; &#125; public void pop() &#123; if (stack.isEmpty()) return; long pop=stack.pop(); if (pop&lt;0) min=min-pop;//If negative, increase the min value &#125; public int top() &#123; long top=stack.peek(); if (top&gt;0)&#123; return (int)(top+min); &#125;else&#123; return (int)(min); &#125; &#125; public int getMin() &#123; return (int)min; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[66. Plus One]]></title>
    <url>%2F2018%2F01%2F12%2F66-Plus-One%2F</url>
    <content type="text"><![CDATA[题目Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 思路弄个临时变量记进位，从第n-1位按照加法开始依次加就好了。 代码1234567891011121314151617181920//C++ Solutionvector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int flag = 1; for(int i = digits.size()-1;i&gt;=0;i--) &#123; int temp = digits[i] + flag; if(temp&lt;10) &#123; digits[i] = temp; flag = 0; break; &#125; else &#123; digits[i] = temp%10; flag = 1; &#125; &#125; if(flag == 1) &#123; digits.insert(digits.begin(),1); &#125; return digits; &#125; 然后Discuss看到了个比较吊的 1234567891011121314151617181920//C++ Solutionvoid plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Valid Parentheses]]></title>
    <url>%2F2018%2F01%2F12%2F20-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[题目Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. 思路用一个栈依次压入或者抛出相应的括号。 代码123456789101112131415161718//c++ Solutionclass Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; result; for(char a:s) &#123; switch(a) &#123; case '(': case '[': case '&#123;':result.push(a);break; case ')':if(!result.empty()&amp;&amp;result.top()=='(') &#123;result.pop();&#125; else &#123;return false;&#125;;break; case ']':if(!result.empty()&amp;&amp;result.top()=='[') &#123;result.pop();&#125; else &#123;return false;&#125;;break; case '&#125;':if(!result.empty()&amp;&amp;result.top()=='&#123;') &#123;result.pop();&#125; else &#123;return false;&#125;;break; &#125; &#125; return result.empty(); &#125;&#125;; 1234567891011121314151617//Java Solutionclass Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; result = new Stack&lt;Character&gt;(); for(char a:s.toCharArray()) &#123; switch(a) &#123; case '(': case '[': case '&#123;': result.push(a); break; case ')': if(!result.empty()&amp;&amp;result.pop()=='(')&#123;break;&#125; else&#123;return false;&#125; case ']': if(!result.empty()&amp;&amp;result.pop()=='[')&#123;break;&#125; else&#123;return false;&#125; case '&#125;': if(!result.empty()&amp;&amp;result.pop()=='&#123;')&#123;break;&#125; else&#123;return false;&#125; &#125; &#125; return result.empty(); &#125;&#125; Java 和 C++ 的 Stack类 用法：Java 方法 描述 boolean empty() 测试堆栈是否为空 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象 Object push(Object element) 把项压入堆栈顶部 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数 C++ 方法 描述 bool empty() 堆栈为空则返回真 pop() 移除栈顶元素 push() 在栈顶增加元素 size() 返回栈中元素数目 top() 返回栈顶元素]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[657. Judge Route Circle]]></title>
    <url>%2F2018%2F01%2F12%2F657-Judge-Route-Circle%2F</url>
    <content type="text"><![CDATA[题目Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example 1: Input: “UD”Output: true Example 2: Input: “LL”Output: false 思路设置两个变量代表x,y轴坐标，然后对应操作就好。最后查看x，y是否还等于0。 代码1234567891011121314151617181920class Solution &#123;public: bool judgeCircle(string moves) &#123; int x = 0,y=0; for(auto m:moves) &#123; switch(m) &#123; case 'L':x--;break; case 'R':x++;break; case 'U':y++;break; case 'D':y--;break; &#125; &#125; if(x == 0 &amp;&amp; y == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8皇后问题]]></title>
    <url>%2F2018%2F01%2F11%2F8%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：如何能够在8×8的国际象棋棋盘上放置8个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。 因为在国际象棋中，皇后可以横、直或者斜着走，格数不限，所以棋盘中任意2个皇后都不能在同一行、同一列以及同一斜线。 思路：依次检测同一行、同一列以及同一斜线有没有皇后，如果没有就检测下一行。累计检测满八个皇后就记一种解法。 一个皇后q(x,y)能被满足以下条件的皇后q(row,col)吃掉： x=row(在纵向不能有两个皇后) y=col（横向） col + row = y+x;（斜向正方向） col - row = y-x;（斜向反方向） 我们用 queen[x]来表示 第x个皇后在第几列。 递归法123456789101112131415161718192021222324252627282930#-*- coding:utf-8 -*-# python Solution# 检查有没有在同一列或者同一斜线# 同一行不用检测因为后面皇后的行数是递增的def available(row,col): for x in range(row): if queen[x]==col or x - queen[x] == row - col or queen[x] + x == row + col: return False return Truedef find(row):# 如果不冲突就记下当前的row和queen[row]（列）# 然后检查下一行 global count,queen if row == 8: count += 1 else: for col in range(8): if available(row,col): queen[row] = col # 递归 find(row+1) if __name__ == '__main__': global count,queen count = 0 queen = [-1]*8 find(0) print count 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Java Solutionpublic class Queen8 &#123; int[] queen = new int[8]; int count = 0; public Queen8() &#123; find(0); System.out.println(count); &#125;// 检查有没有在同一列或者同一斜线// 同一行不用检测因为后面皇后的行数是递增的 public boolean avaliable(int row,int col) &#123; for (int x = 0;x&lt;row;x++)&#123; if (queen[x]==col || x-queen[x]==row-col || x+queen[x]==row+col) &#123; return false; &#125; &#125; return true; &#125; public void find(int row) &#123; if (row == 8) &#123; count++; &#125; else &#123; for (int col = 0;col&lt;8;col++) &#123; if (avaliable(row, col)) &#123; queen[row] = col; // 递归 find(row+1); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Queen8 queen8 = new Queen8(); &#125; &#125; 非递归(回溯法)回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 算法描述如下： 开始时清空棋盘，将当前行设为第零行，当前列设为第零列。 判断当前位置是否合法，若不合法到第4步。 当前位置合法，则在当前位置放置一棋子。 若当前行为最后一行，则记录一个解。 若当前列是最后一列，当前行设为前一行，当前列设为当前行对应列的下一列。 若当前列不是最后一列，当前列设为下一列. 若当前行不是最后一行，则将当前行设为下一行，当前列设为第零列。回至第2步。 当前位置不合法。 若当前列不是最后最后一列，则当前列设为下一列，回到第2步。 若当前列是最后一列 若当前行为第零行，结束 若当前不是第零行，当前行设为前一行，当前列设为当前行对应列的下一列。回至第2步。 123456789101112131415161718192021222324252627282930#-*- coding:utf-8 -*-def available(row,col): for x in range(row): if queen[x]==col or x - queen[x] == row - col or queen[x] + x == row + col: return False return Truedef find(): count = 0 row = 0 global queen queen[row] = 0 while row&gt;=0: #当前行为 -1 时结束 if row &lt; 8 and queen[row] &lt; 8: #当前行、当前列均为到达最后 if available(row,queen[row]): #当前位置合法，则探索下一行 row += 1 queen[row] = 0 else: queen[row] += 1 else: #当前位置不合法，探测当前行的下一个位置 if row&gt;=8: #当前行、当前列均到了最后，记录一个解 count+=1 row -= 1 # 返回上一行，继续探索 queen[row] += 1 return countif __name__ == '__main__': global queen queen = [-1]*9 print find() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Queen8 &#123; int[] queen = new int[9]; public Queen8() &#123; System.out.println(find()); &#125; public boolean avaliable(int row,int col) &#123; for (int x = 0;x&lt;row;x++)&#123; if (queen[x]==col || x-queen[x]==row-col || x+queen[x]==row+col) &#123; return false; &#125; &#125; return true; &#125; public int find() &#123; int count = 0; int row = 0; queen[row] = 0; while (row &gt;= 0) &#123; if (row&lt;8 &amp;&amp; queen[row]&lt;8) &#123; if (avaliable(row, queen[row])) &#123; row++; queen[row] = 0; &#125; else &#123; queen[row]++; &#125; &#125; else &#123; if (row&gt;=8) &#123; count++; &#125; row--; System.out.println(row); if (row&gt;=0) &#123; queen[row]++; &#125; &#125; &#125; return count; &#125; public static void main(String[] args) &#123; Queen8 q = new Queen8(); &#125; &#125; 参考:http://www.cnblogs.com/jillzhang/archive/2007/10/21/922830.htmlhttps://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95https://github.com/zhsj/nqueen/blob/master/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.md]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[760 Find Anagram Mappings]]></title>
    <url>%2F2018%2F01%2F11%2F760-Find-Anagram-Mappings%2F</url>
    <content type="text"><![CDATA[题目Given two lists Aand B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A. We want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j. These lists A and B may contain duplicates. If there are multiple answers, output any of them. For example, given A = [12, 28, 46, 32, 50]B = [50, 12, 32, 46, 28] We should return [1, 4, 3, 2, 0] as P[0] = 1 because the 0th element of A appears at B[1], and P[1] = 4 because the 1st element of A appears at B[4], and so on. Note: A, B have equal lengths in range [1, 100]. A[i], B[i] are integers in range [0, 10^5]. 思路用一个Map把B里面的元素和它的位置存起来，然后便利一遍A就好 代码1234567891011121314// Java Solutionclass Solution &#123; public int[] anagramMappings(int[] A, int[] B) &#123; Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;B.length;i++) &#123; m.put(B[i],i); &#125; int[] result = new int[A.length]; for (int i=0;i&lt;A.length;i++) &#123; result[i] = m.get(A[i]); &#125; return result; &#125;&#125; 12345678910111213141516//C++ Solutionclass Solution &#123;public: vector&lt;int&gt; anagramMappings(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; map&lt;int,int&gt; a; int counter = 0; for(int i:B) &#123; a[i] = counter++; &#125; vector&lt;int&gt; result; for(int i:A) &#123; result.push_back(a[i]); &#125; return result; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纽约上州枫叶季四天自驾游]]></title>
    <url>%2F2017%2F10%2F11%2F%E7%BA%BD%E7%BA%A6%E4%B8%8A%E5%B7%9E%E6%9E%AB%E5%8F%B6%E5%AD%A3%E5%9B%9B%E5%A4%A9%E8%87%AA%E9%A9%BE%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[纽约上州枫叶季四天自驾游本来去年就想去看枫叶了，但是由于种种原因（屌丝单身狗约不到人，租不到车）就去没去。然后今年暑假依靠实习攒了点钱，开学骗了个女朋友，前几天就趁着哥伦布节三天假期去看了次枫叶。 枫叶报告可以从这个网站上看，清楚的写了纽约州枫叶的情况。http://www.iloveny.com/seasons/fall/foliage-report/。看到纽约北部枫叶差不多红了，于是定了四天行程，从新泽西Hoboken出发，第一天到 Lake George，第二天和第三天在 Lake Placid，第四天回新泽西。 枫叶之行，最理想的车型应该是一辆红色的保时捷911，因为法拉利座位太硬，迈凯轮太高调，兰博基尼太吵，所以911最合适，哪一年的车型不重要因为从1964至今样子就没怎么变过，加上本来也没什么钱，所以这次租了辆凯美瑞。 早上11点从新泽西出发，中途路上随便找了个地方吃午饭，大概下午四点就到Lake George了。但是比较可惜的是 Lake George 的枫叶红的不多，而且天比较冷在下雨，基本上不能爬山，我们就只能开车绕着Lake George小镇绕一圈。很宁静的地方，适合养老，湖边的餐厅景色很赞，可惜去晚了不能坐窗边。但是吃的就比较美国了，不好看，也不好吃。 第二天本来是安排转一下Lake George的几个地方，但是由于枫叶没红，就决定直接去Lake Placid。但是半路又想来都来了，还是随便逛一下，于是去了Prospect Mountain. 每辆车10刀的门票，你可以去几乎是Lake George的最高点看小镇全景，如果枫叶都红了应该会很好看。不过还好这次带了妹子，虽然枫叶没红，但是风景依然是一流的～～ 一流的风景 一流的风景 一流的风景 之后就去了，一路向北，越往北走枫叶红的越多，越来越漂亮。Lake Placid 以举办1932年冬季奥林匹克运动会、1980年冬季奥林匹克运动会而闻名，不过美国人记得这个小村是因为1980年在这里进行的一场美国对苏联的冰球比赛，后来被称作冰上的奇迹（Miracle on Ice）。一群美国大学生和业余球员4-3击败了大热门苏联国家冰球队，并在两天后赢得了奥运会金牌。这次胜利经常被列为美国体育史上最伟大的胜利。埃里克·海登在这里夺得5块奥运会金牌。1972年冬季世界大学生运动会也在此举行。 Lake Placid离Lake George很近，一个半小时车程。当然由于是休闲游，一路上走走停停拍照，到了Lake Placid之后天就差不多黑了，什么也看不见，只知道自己住在湖边，小镇很宁静，然后就直接休息了。第二天早上起来看到了这般景象： 十分漂亮，漫山遍野全是红色或者黄色的叶子。酒店叫Best Western Saranac Lake，位置是 487 Lake Flower Avenue, Saranac Lake, NY 12983， 强烈推荐！！ 对于我这样一个只在昆明广州洛杉矶这些南方城市生活过的人来说，这是我这辈子第一次见到这么多不是绿色叶子的树。但是比较坑的是那一天在下雨，而且雨很大，所有爬山的行程全部走不了，所以又临时改了下，变成了绕湖自驾游。临时行程改的很随意，路线也很随意：只要是湖边的路顺着走就好了，于是开着车就开始穿梭各种林间小路。 说是说林间小路，其实我感觉应该是别人家，因为要不是地图上表示，没人会找得到这种路，入口及其隐蔽，每走几分钟就有一户人家。然后我们也冒雨，在雨稍微小一点的时候拍了点照片～～ 第四天返程回纽约，刚好赶上上课～ 虽然这次自驾游基本上和计划的完全不一样，还遇到了下雨天，但总的来说体验还是相当不错的（毕竟有妹子陪着玩～～]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-navigation和react-native-navigation]]></title>
    <url>%2F2017%2F10%2F04%2Freact-navigation%E5%92%8Creact-native-navigation%2F</url>
    <content type="text"><![CDATA[写项目的时候肯定会遇到实现类似于iOS 的Navigation Controller或者Tab bar之类的界面。官方只有一个NavigatorIOS的控件可以用，但是这个控件只能用在iOS平台，安卓的要另外重写，十分鸡肋。所以官方还提供了两个控件可以选择：react-navigation 和 react-native-navigation。这两个的区别我感觉网上写的很少，所以写这篇博客来记下两个区别。。。 当然如果懒得看完，可以直接用这个结论：用 react-navigation！！！好用的多！！！ react-native-navigationreact-native 版本需要大于 0.43，nmp 版本大于 3.0 安装1yarn add react-native-navigation@latest iOS 安装通过 /iOS/.xcodeproj 打开项目 Libraries-&gt;Add files to [project name] 添加(Add) ./node_modules/react-native-navigation/ios/ReactNativeNavigation.xcodeproj 点击Build Phases，在 Link Binary With Libraries里添加 libReactNativeNavigation.a 点击Build Settings，在Header Search Paths里添加 $(SRCROOT)/../node_modules/react-native-navigation/ios，确保是recursive模式。 修改AppDelegate.m如下 1234567891011121314151617181920212223242526272829303132333435- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSURL *jsCodeLocation;#ifdef DEBUG // jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;]; jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil];#else jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];#endif // ********************************************** // *** DON&apos;T MISS: THIS IS HOW WE BOOTSTRAP ***** // ********************************************** self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; [[RCCManager sharedInstance] initBridgeWithBundleURL:jsCodeLocation launchOptions:launchOptions]; /* // original RN bootstrap - remove this part RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;example&quot; initialProperties:nil launchOptions:launchOptions]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *rootViewController = [UIViewController new]; rootViewController.view = rootView; self.window.rootViewController = rootViewController; [self.window makeKeyAndVisible]; */ return YES;&#125; Android 安装在android/settings.gradle里面添加： 12include ':react-native-navigation' project(':react-native-navigation').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-navigation/android/app/') 更新android/app/build.gradle文件如下： 123456789101112android &#123; compileSdkVersion 25 buildToolsVersion "25.0.1" ...&#125;dependencies &#123; compile fileTree(dir: "libs", include: ["*.jar"]) compile "com.android.support:appcompat-v7:23.0.1" compile "com.facebook.react:react-native:+" compile project(':react-native-navigation')&#125; 修改 android/app/src/main/java/com/yourproject/MainActivity.java文件，MainActivity 应该继承 com.reactnativenavigation.controllers.SplashActivity 而不是 ReactActivity 12345import com.reactnativenavigation.controllers.SplashActivity; public class MainActivity extends SplashActivity &#123; &#125; MainApplication.java文件添加以下内容 1234567891011121314151617181920212223import com.reactnativenavigation.NavigationApplication;public class MainApplication extends NavigationApplication &#123; @Override public boolean isDebug() &#123; // Make sure you are using BuildConfig from your own application return BuildConfig.DEBUG; &#125; protected List&lt;ReactPackage&gt; getPackages() &#123; // Add additional packages you require here // No need to add RnnPackage and MainReactPackage return Arrays.&lt;ReactPackage&gt;asList( // eg. new VectorIconsPackage() ); &#125; @Override public List&lt;ReactPackage&gt; createAdditionalReactPackages() &#123; return getPackages(); &#125;&#125; 更新 AndroidManifest.xml 把 android:name 的值改成 .MainApplication 1234&lt;application android:name=".MainApplication" .../&gt; 用法这里我们实现三个页面来介绍react-native-navigation的用法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//FirstTabScreen.jsimport React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View, StyleSheet, Button &#125; from 'react-native';export default class FirstTabScreen extends Component &#123; onPushAnother = () =&gt; &#123; this.props.navigator.push(&#123; screen: 'example.PushedScreen', title: 'Pushed Screen' &#125;); &#125;; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Button onPress=&#123;this.onPushAnother&#125; title="Push Another Screen" /&gt; &lt;Text style=&#123;styles.content&#125;&gt;first screen&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: 'center', justifyContent: 'center' &#125;, content: &#123; textAlign: 'center', marginTop: 10, &#125;,&#125;);//SecondTabScreen.js &amp;&amp; PushedScreen.js(改下&lt;Text&gt;里面的文字就好)import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View, StyleSheet &#125; from 'react-native';export default class SecondTabScreen extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.content&#125;&gt;second screen&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: 'center', justifyContent: 'center' &#125;, content: &#123; textAlign: 'center', marginTop: 10, &#125;,&#125;); 以及 index.js，这是react-native-navigation中最重要的部分，没有之一。注意看这里的操作，通过Navigation.registerComponent方法注册所有的页面，每个页面手动分了一个id，比如example.FirstTabScreen就是“example.FirstTabScreen”，之后如果用到页面就通过这个id把它调出来。而 registerScreens()方法只能调用一次就是说你要把你项目中所有的页面全部在这里写一遍！！！当时我也很震惊，哪有这么写框架的，一点也不优雅，但是它真是这么干的，而且官方的例子也是这么写的: 12345678910111213//index.jsimport &#123; Navigation &#125; from 'react-native-navigation';import FirstTabScreen from './FirstTabScreen';import SecondTabScreen from './SecondTabScreen';import PushedScreen from './PushedScreen';// register all screens of the app (including internal ones)export function registerScreens() &#123; Navigation.registerComponent('example.FirstTabScreen', () =&gt; FirstTabScreen); Navigation.registerComponent('example.SecondTabScreen', () =&gt; SecondTabScreen); Navigation.registerComponent('example.PushedScreen', () =&gt; PushedScreen);&#125; 以上页面放到一个screen文件夹中。 然后index.ios.js加入以下代码： 123456789101112131415161718192021import &#123; Navigation &#125; from 'react-native-navigation';import &#123; registerScreens &#125; from './screens';registerScreens(); // this is where you register all of your app's screens// start the appNavigation.startTabBasedApp(&#123; tabs: [ &#123; label: 'One', screen: 'example.FirstTabScreen', // this is a registered name for a screen title: 'Screen One' &#125;, &#123; label: 'Two', screen: 'example.SecondTabScreen', title: 'Screen Two' &#125; ]&#125;); 效果 react-navigation这个是airbnb团队开发的，个人感觉比react-native-navigation好用，强烈推荐 安装1npm install --save react-navigation or 1yarn add react-navigation 修改index.ios.js代码： 12345678910111213141516171819202122import React from 'react';import &#123; AppRegistry, Text,&#125; from 'react-native';import &#123; StackNavigator &#125; from 'react-navigation';class HomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Welcome', &#125;; render() &#123; return &lt;Text&gt;Hello, Navigation!&lt;/Text&gt;; &#125;&#125;export default const SimpleApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;,&#125;);// if you are using create-react-native-app you don't need this lineAppRegistry.registerComponent('SimpleApp', () =&gt; SimpleApp); 就可以了，十分方便 用法这里我们同样用三个页面来介绍react-navigation的用法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//FirstTabScreen.jsimport React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View, StyleSheet, Button &#125; from 'react-native';import &#123; StackNavigator &#125; from 'react-navigation';import PushedScreen from './PushedScreen'class Fcreen extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Button onPress=&#123;() =&gt; this.props.navigation.navigate('Pushed', &#123;name: 'Pushed Screen'&#125;)&#125; title="Push Another Screen" /&gt; &lt;Text style=&#123;styles.content&#125;&gt;first screen&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class FirstTabScreen extends Component &#123; render() &#123; FPage = StackNavigator(&#123; FirstTabScreen: &#123; screen: Fcreen, &#125;, Pushed: &#123; navigationOptions: (&#123; navigation &#125;) =&gt; (&#123; title: 'Pushed Screen', &#125;), screen: PushedScreen, &#125;, &#125;); return &lt;FPage/&gt; &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: 'center', justifyContent: 'center' &#125;, content: &#123; textAlign: 'center', marginTop: 10, &#125;,&#125;);//SecondTabScreen.js 和 PushedScreen.js(改改字符串)import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View, StyleSheet &#125; from 'react-native';export default class SecondTabScreen extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.content&#125;&gt;second screen&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: 'center', justifyContent: 'center' &#125;, content: &#123; textAlign: 'center', marginTop: 10, &#125;,&#125;); 以及index.ios.js 或 index.android.js 1234567891011121314151617181920212223242526272829303132333435363738import React from 'react';import &#123; AppRegistry, Text,&#125; from 'react-native';import &#123; StackNavigator, TabNavigator &#125; from 'react-navigation';import FirstTabScreen from './view/FirstTabScreen'import SecondTabScreen from './view/SecondTabScreen'class HomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Welcome', &#125;; render() &#123; return &lt;Text&gt;Hello, Navigation!&lt;/Text&gt;; &#125;&#125;const test = TabNavigator(&#123; First: &#123; screen: FirstTabScreen, &#125;, Second: &#123; screen: SecondTabScreen, &#125;,&#125;, &#123; tabBarPosition: 'bottom', animationEnabled: true, tabBarOptions: &#123; activeTintColor: '#e91e63', &#125;,&#125;);// if you are using create-react-native-app you don't need this lineAppRegistry.registerComponent('test', () =&gt; test); 效果]]></content>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在华尔街实习是种怎样的体验]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%9C%A8%E5%8D%8E%E5%B0%94%E8%A1%97%E5%AE%9E%E4%B9%A0%E6%98%AF%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[好吧我承认我是标题党，我实习的公司其实是在水街（Water Street），离华尔街还有几十米，具体位置可以看地图： 虽然公司在水街，但是公司不是水公司。我自己是学计算机的，不是金融相关专业，之所以能有一个在华尔街实习的机会，完全是因为我 之前投了Facebook和Google，然后Google直接拒掉了我的简历，Facebook面试又没过，实在是去不了硅谷，菜的抠脚只能随便找个离家近的地方实习 平时努力读书，认真总结各方面的知识，外加自己一口流利的口语本来不会讲英语的我莫名其妙开了无双状态和高贵冷艳的外表被几个面试官吓成面瘫直接征服了面试官。 霍博肯是棒球起源地 我住在新泽西霍博肯（Hoboken），因为离学校近，每天从家到公司大约需要45分钟。每天早上我大约6:30起床，玩半个小时手机，然后洗漱，吃个早餐出门。我租的公寓每天早上有免费的大巴把我接到Path Station（相当于地铁站），坐新泽西到纽约的地铁，在世贸中心下车，然后走5分钟就到公司了。2001年，世贸中心遭到恐怖袭击，世贸双塔收到4架飞机撞击后倒塌，现在其中一座塔被修成了新的世贸中心，另一个被修成了一个购物中心，每天上班我都要经过这里。比较巧的是，我这个实习公司办公室当时在世贸中心的101楼到105楼，也就是遭到撞击的那一层，那天公司损失了658名员工，占了员工总数的68%，是整个恐怖袭击中损失最惨的一家公司。 世贸中心Shopping Mall 实习公司很蛋疼，有Dress Code，不能乱穿衣服上班，每天都要穿衬衫西裤皮鞋。这对我们程序员就很伤，因为对于程序员来说，标准的服饰应该是牛仔裤冲锋衣洞洞鞋，或者短裤拖鞋T恤衫。如果哪个程序员去面试穿的非常正式，西装革履，那不用想了，这个人技术一定不行，甚至可能只会开机。但是这里不一样，HR每两周发一次邮件提醒你Dress Code，注意形象，别乱穿衣服。这规定我觉得得改改，对于程序猿这种职业，穿那么正式是没有灵感的，严重影响工作效率，我经常一个简单的问题要想半天，肯定就是因为这身衣服，如果让我穿睡衣，肯定早就写出来了，一行bug没有。 我面试的时候，4个面试官轮着问了我快一小时iOS开发的问题，从“hello world”到苹果商店上架都问了，几乎囊括了iOS开发的方方面面。我当时觉得我实习的时候肯定是在写iOS了，虽然我一直想找个后台开发的工作，但是投了一百多份简历都没回信，好不容易找到了个移动端的工作，那就凑合做吧。结果我来公司报道的第一天，发现二十几个实习生，分了几个组负责不同的东西，我比较奇葩，一个人一组，开发部老大直接带我。老大让我看Xamarin，说他们准备写个app，看完之后告诉他这个大概要怎么实现，因为他也不太懂。我一听就知道是个坑啊，C#怎么写APP？当年弄Xamarin的hello word都弄了半天。于是就赶紧跟他说这是个深坑，千万碰不得，有个稍微浅一点的坑叫做react-native，要不我用那个吧。老大就说好听你的。我从来没有想过一个那么大的公司会这么随便，毕竟这个公司全球十几个国家都有分部，随便一个实习生一句话就能让这个公司换个技术？！！ 但是，我根本不会react-native。我是2月份面试完的，面试之前只是听说过react，面试之后几个月每天花几小时学了下react，谁知道我实习的时候真的用上了，难道这就是命？然后之后几天，我跟老大说App几个功能需要后台支持，但是我们没有后台，老大就让我顺便把后台也写了。我比较熟悉轻量级的Node.js，但是公司不同意，一定要用.NET，于是我又要重新入门.NET。上一次写.NET程序还是三年前在冯玉祥老师的课上，三天刷夜搞了个航空订票系统，之后就再也没有碰过。的网上很多人都说，华尔街工作强度大，每天只能睡四小时。我感觉如果我这几个月没有每天看一点的话，我也是每天睡四小时的节奏。现在还好，至少懂一点，大大增加了我的睡眠时间，每天可以睡四个半小时。……以前我妈老说，等你自己挣钱了，就知道挣钱多么不容易，就会省着花了。但是事实上，爸妈给的钱花起来还有点心虚，瞻前顾后。自己挣的钱拿到的工资，花起来根本不眨眼，我特么不甩花往死里花都对不起我平常吃的苦！ 布鲁克林大桥 公司是一家传统金融公司，金融气氛十分浓厚，我的位置靠着一群交易员，每天听着他们对着电话fuck来fuck去，与他们的西装革履格格不入，完全是一群衣冠禽兽。虽然公司没有摩根斯坦利那么大，但是也不是家创业公司，全球很多国家都有分部，总部在伦敦。然而这个公司对程序员是真的不友好，开发环境是windows，还只给了我一小个屏幕。而且配置环境就花了一个多星期，陪好之后我惊奇的发现我只有2G的硬盘空间了，完全没有办法做任何的开发，于是我只能每天背着自己的电脑去上班。但是有什么办法，企业做大了，老板的每一个行为，都有人负责把它解释得合理。我跟我主管提了这个，他每次都可以用不同的理由告诉我，公司这么做是对的。一开始老大并不同意我用自己的电脑开发，直到有一次他想看下我做的一小个demo，用公司电脑花了大约一小时编译运行完，我电脑只用了5分钟，于是他终于理解了自己公司电脑有多坑，同意我用自己的电脑编程。我实习10周要做的工作，大概涵盖了安卓开发，苹果iOS开发，以及后台开发，只有我一个人做。哪怕一个创业公司，都会至少招三个人做这些事情。目前的感受是： 这个公司的软件开发流程不太规范，有点像创业公司。如果这种级别的公司在华尔街都那么不规范，感觉大部分金融公司的软件开发都不是按照标准流程的。所以在金融公司上班会过的很蛋疼，工作不会很愉快，Boss很有没有灵性，基本上需求都没确定就让你开始做，然后改改改，改到头皮发麻。所以尽量试试谷歌亚马逊微软IBM，在纽约都有分公司。找工作也尽量找内核开发，人工智能之类的工作，至少同事都是搞这个的，特别好交流，可以开心的做开发。 比如人生赢家Joe，在亚马逊就过的特别开心，项目高大上，月入过万，最重要的是还有女朋友，真是羡慕嫉妒恨。。。 每天九点上班，下午5点下班，实习生不允许加班。但是所谓不允许加班只是说你没有加班工资，该做完的事你还是要做完。公司不提供午饭，明天只能去外面吃。上了两周班之后我惊奇的发现，堂堂华尔街居然只能吃汉堡炸鸡披萨！！！有一天鼓起勇气试了下路边摊的纽约传统美食：“Chicken over Rice”鸡肉饭，发现鸡肉还能吃，饭有一股柴油味，就再也没吃过。办公室大部分人都是忙一早上，中文匆忙的去弄个三明治来啃了，然后继续忙，尤其是坐我对面那群交易员，每天水都没时间喝，怎一个惨字了得。小时候曾经有过一个愿望：能每天吃麦当劳就好，现在愿望实现之后发现小时候自己脑子真是进水了，明明隔壁有卤面炒饭吃什么汉堡。（后来公司又来了个新实习生，一年前在华尔街实习过，韩国欧巴，轻车熟路，带我去了个各种小巷子的餐馆，吃的巨好，也很便宜，要不是见过世面我肯定直接一句“擦浪嘿”就出来了。） 实习了十周的感觉就是：华尔街没那么神，也不是每个人都是精英，甚至有一大批混日子没理想的瓜皮。他们能这样肯定是一百年来资本积累的结果，感觉只要再给中国十几年，超越他们也不是不可能！！！ 相传华尔街的人说的话只能信20%，剩下80%全是谎言！不过我不一样，我是个老实人，只会写代码，只是在资本主义老巢呆了几天受了点影响，所以这篇文章应该有95%的可信度吧～😄 午餐推荐：Open Kitchen: 自选食品然后称重付款，大约10刀一顿还可以，有一种肉类似叉烧特别好吃！！。也可以去旁边点餐，味道都还行~ 地址：123 William St, New York, NY 10005 Open Market: 也是自选。 地址：15 William St, New York, NY 10005 55 Fulton Market：自选 地址：55 Fulton St, New York, NY 10038 另外听说法拉盛的中餐馆每天会送一小批东西到世贸大厦一楼，中餐，特别抢手需要预定。我也不是很清楚怎么操作，有知道的小伙伴补充下吗？ 华尔街傍晚 公司在哈佛俱乐部组织的实习生party 华尔街（是真的很破，放中国就是某栋高楼后面扔垃圾的小巷子 纽约证劵交易所]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现navigationController渐变]]></title>
    <url>%2F2017%2F01%2F14%2F%E5%AE%9E%E7%8E%B0navigationController%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[效果 实现思路先观察NavigationBar的结构图： 可以发现navigationBar后面是有个imageView的，只要把它设置为无图就可以看到透明，设置backgroundColor就不可以 需要注意的是navigationBar还有另一个imageView，其实那个是导航栏下面的那一根细线。 实现直接获取那张ImageView,然后设置他的透明度它其实就在subviews的第一个,即,我们可以这样 1234//Objective-CUIView barImageView = new UIView()barImageView = self.navigationController.navigationBar.subviews.firstObject 1234//swift // var barImageView = UIView()barImageView = (navigationController?.navigationBar.subviews.first)! 然后设置它透明 12//swiftnavigationController?.navigationBar.setBackgroundImage(UIImage(), for: UIBarPosition.top, barMetrics: UIBarMetrics.default) 然后在scrollViewDidScroll方法里面根据偏移量来动态改变barImageView颜色就好 123456789101112131415161718192021//swiftoverride func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; let offsetY:CGFloat = scrollView.contentOffset.y if (offsetY &gt;= 44) &#123; let alpha:CGFloat = min(0.95, 1 - ((50 + 64 - offsetY) / 64)) //50 可以任意改变，控制你的tableView拉到什么样子的时候他才变成不透明 barImageView.backgroundColor = UIColor.white.withAlphaComponent(alpha) if alpha &gt; 0.95 &#123; // setNavigationBarTextBlack() //导航栏被拉下来 &#125; &#125; else &#123; barImageView.backgroundColor = UIColor.white.withAlphaComponent(0.0) // setNavigationBarTextClear() // 导航栏在初始位置状态 &#125;&#125; 补充代码改变导航栏标题颜色和返回键颜色 123//swiftself.navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName:UIColor.white]self.navigationController?.navigationBar.tintColor = UIColor.white 需要重写viewWillAppear和viewWillDisappear 123456789101112//override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.tableView.delegate = self; self.navigationController?.navigationBar.shadowImage = UIImage()&#125;override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) self.tableView.delegate = nil; setNavigationBarTextBlack()&#125; 不然你返回到上一个界面的时候会发现导航栏很奇怪 如果懒得自己写可以试下这个轮子： https://github.com/ltebean/LTNavigationBar/tree/master]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国F1身份申请德国签证攻略]]></title>
    <url>%2F2017%2F01%2F10%2F%E7%BE%8E%E5%9B%BDF1%E8%BA%AB%E4%BB%BD%E7%94%B3%E8%AF%B7%E5%BE%B7%E5%9B%BD%E7%AD%BE%E8%AF%81%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[先介绍下背景，刚来美国3个月，英语不溜只会点菜那种，无驾照，无SSN，无工作，F1签证。 一般有美国签证申请德国签证是不会被拒签的，除非你的材料有大问题，所以认真准备都是可以过的 去欧洲玩是个很仓促的决定，所以我是提前一个月才开始申请的，请不要学我，一般要提前三个月。 如果可以，不要申请德国签证！！ 如果可以，不要申请德国签证！！ 如果可以，不要申请德国签证！！ 建议，如果可以，去申请法国的签证，德国的实在是太坑爹了！！ 如果申请人将要前往一个申根国（仅一个），申请人必须在特定国家的相应大使馆或领事馆申请。如果申请人计划前往两个或更多申根国，强烈建议申请者在将要停留时间最久的国家（即“主要目的地”）的大使馆或领事馆申请签证。如果没有主要目的地，只是随机访问几个申根国家，那么申请人必须在其行程中首个抵达的国家的大使馆或领事馆申请签证。当确定在哪个大使馆或领事馆申请签证之后，申请人将要在对自己居住地拥有管辖权的国家的大使馆/领事馆申请签证。 我这次行程在德国呆的最久，所以预约的德国的。其实是时间太急只能预约德国的申根签了，法国签证排到了明年，西班牙的据说效率低不想去，所以强行多安排了几天德国行程…… 预约首先上这个网站预约（这是纽约领事馆，不同地方的领事馆不一样，可以自己看下）。 预约很简单，填下自己的基本信息选个时间就好。 然后就是要填写VIDEX表，专门有个网页是用来填这个表的，一次写不完可以第二次写。只是他不能在线保存，都是存为XML格式的放在本地。VIDEX网页链接 材料 预约的 email 确认信； 签证表（VIDEX）和 declaration letter. 网上填写然后打印即可； 两张申根签证照片。规格必须是45*35mm； 护照。注意美国签证在旅行结束之后要有 3 个月有效期； 护照和美国签证的复印件，F-1 签证要准备 I-20 和复印件（一定要带）； 过去三个月银行账单。最好有 200 刀每天的钱，越多越好； 申根特别要求的医保证明。 我先是给她看了我们学校的保险，由于没有具体的赔偿额度没有过，还好我另外买了一个保险，上面明确写了有50K刀的美国境外保险，过了～； Reference letter. 找学校开就好（看都没看）； 机票酒店预约信，以及复印件； Utility bill: 水、电、手机、电视、网络等账单或者驾照等能证明你居住地的材料。 面签面签过程很纠结，着实感受了一把德国人的严谨： 先是找德国大使馆，本来想着应该很好找，联合国大楼对面，川普家旁边，谷歌地图上长这样： 但是进去之后有个人问我是不是签证，我说是啊。然后他说这里不是签证的地方，你出门左拐在左拐理发店旁边有个门你进去，那个才是签证的地方。 我：…… 然后找了半天找到了理发店旁边的门，进去，还是刚才那个人，笑着跟我说：“Hello again！”。我真是一万个白眼，你直接把我带过来会死啊…… 预约的是12点但是由于下午学校有个career fair我就11点到了，心想着可以提前结束。然而提前到并不能提前签证，德国人表示还是要按预约的时间来，我就只能坐在那里等。 于是就等到了12点。先把我的所有材料拿了过去看了一遍，问我是不是在德国呆最长时间，我说是啊。 然后她就开始拿张纸，拿支笔，认认真真的对着我的材料，把我在每个国家的每一天都列出来，最后得出的结论就是我的确是在德国呆最长时间。 我本以为可以过了，没想到她直接说了句：“好了，现在来背下你的行程吧…………”。十五天的行程！！！！还好签证前小伙伴提醒了我可能会这么搞我，我提前背了点，勉强过了。 背完之后就开始问我想怎么拿我的签证，邮寄还是自己来拿，我是对美国邮政深恶痛绝，决定自己来拿。 时间 我是7号去的大使馆，14号拿到的护照，17号下午的飞机飞伦敦，时间特别紧张，估计我是第一个这么干的人，请不要学我…… 然后德国人给了我一个月的签证，无限次往返，每次逗留时间不超过十五天。。 但是！！一起签证的小伙伴，法签，多的拿了一年的无限次往返，少的拿了半年。同样的材料，同样的时间！！ 所以 如果可以，不要申请德国签证！！ 如果可以，不要申请德国签证！！ 如果可以，不要申请德国签证！！]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用iOS Homekit控制树莓派]]></title>
    <url>%2F2017%2F01%2F10%2F%E4%BD%BF%E7%94%A8iOS-Homekit%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[使用iOS Homekit控制树莓派HomeKit 就是苹果官方的智能家居平台解决方案，包括移动设备 SDK，智能家居硬件通信协议 (HAP: HomeKit Accessory Protocol) 、以及 MFi(Made for iPhone/iPod/iPad) 认证等等。通过 WiFi 或蓝牙连接智能家居设备（或 bridge 设备），也可以利用 Apple TV(4代) 或闲家中的置 iPad 实现设备的远程控制（HAP over iCloud）。 但是 HAP 协议部分是需要加入 MFi Program 才能获取文档，而且 MFi Program 无法以个人开发者身份加入。 好在有好心人（大牛）逆向了 HAP 的服务端协议，给了我们折腾党一个机会～ 为了实现这个，我们需要用到一个库，叫做Homebridge。Homebridge是一个用Node.js实现的轻量级后台，能够在局域网内与苹果的Homekit API对接，并且支持插件。 然后我们用到的插件叫做Homebridge GPIO WiringPi，用来控制树莓派上的GPIO。 安装先安装 Homebridge 1npm install -g homebridge 再安装Homebridge GPIO WiringPi插件 1npm install -g homebridge-gpio-wpi 创建config.json文件在根目录下，进入 .homebridge 文件夹 1cd ~/.homebridge/ 新建 config.json文件 1vim config.json 然后文件内容如下： 123456789101112131415161718192021222324252627282930&#123; "bridge": &#123; "name": "Homebridge", "username": "CC:22:3D:E3:CE:32", "port": 51826, "pin": "031-45-155" &#125;, "description": "This has some fake accessories", "accessories": [ &#123; "accessory": "GPIO", "name": "Yellow Light", "pin": 27 &#125;, &#123; "accessory": "GPIO", "name": "Red Light", "pin": 22 &#125;, &#123; "accessory": "GPIO", "name": "Green Light", "pin": 17 &#125; ], "platforms": []&#125; 其中 bridge字段表示这个设备的基本信息，username可以随便写，pin是链接时候需要用到的一串数字，等下会看到。accessories是声明GPIO，其中，里面的pin是GPIO引脚的编号（BCM），accessory必须写GPIO。 引脚信息如下： BCM wPi Name Mode V Physical V Mode Name wPi BCM 3.3v 1 2 5v 2 8 SDA.1 OUT 0 3 4 5V 3 9 SCL.1 IN 1 5 6 0v 4 7 GPIO. 7 IN 1 7 8 1 ALT0 TxD 15 14 0v 9 10 1 ALT0 RxD 16 15 17 0 GPIO. 0 OUT 0 11 12 1 IN GPIO. 1 1 18 27 2 GPIO. 2 OUT 0 13 14 0v 22 3 GPIO. 3 OUT 0 15 16 0 IN GPIO. 4 4 23 3.3v 17 18 0 IN GPIO. 5 5 24 10 12 MOSI IN 0 19 20 0v 9 13 MISO IN 0 21 22 0 IN GPIO. 6 6 25 11 14 SCLK IN 0 23 24 1 IN CE0 10 8 0v 25 26 1 IN CE1 11 7 0 30 SDA.0 IN 1 27 28 1 IN SCL.0 31 1 5 21 GPIO.21 IN 1 29 30 0v 6 22 GPIO.22 IN 1 31 32 0 IN GPIO.26 26 12 13 23 GPIO.23 IN 0 33 34 0v 19 24 GPIO.24 IN 0 35 36 0 IN GPIO.27 27 16 26 25 GPIO.25 IN 0 37 38 0 IN GPIO.28 28 20 0v 39 40 0 IN GPIO.29 29 21 BCM wPi Name Mode V Physical V Mode Name wPi BCM 之后保存文件。 连接电路注意GPIO引脚的编号，我们用的是BCM编号，三个引脚分别为17，27，22，如图： 运行Homebridge直接在终端输入命令即可 1homebridge 打开手机的Homekit，按照提示连接到树莓派上，如下： 然后就可以控制灯泡了。。。 可以尝试用Siri控制下开关，试试 Turn on the Red Light 很神奇～ 可能遇到的问题1. /usr/local/lib/node_modules/homebridge-gpio-wpi/index.js:33 throw new Error(‘Pin ‘ + this.pin + ‘ is not readable (‘ + currentPinStatus.error.code + ‘). Did you run gpio export as the right user?’); 可能是引脚的问题，尝试在终端运行，注意替换引脚的编号 123gpio -g mode 22 out gpio -g mode 22 down gpio export 22 out]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年总结]]></title>
    <url>%2F2017%2F01%2F05%2F2016%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[过去一年，发生了很多事，有些事很不顺，甚至让我怀疑我自己是不是早生了一年其实2016年才是我的本命年。 首先是年初，当时为了几千块钱接了一个外包，过年的那一个月全部用在了写“美奥诊所”APP上，甚至过年那几天都在写，一个月差不多写完。我当时也不知道自己可以写那么快，算是自己技术上的一个里程碑吧。那是我写的第三个iOS app。当然，大四这一年也没找家里要什么钱，自己实习+各种外包的钱足够让我在广州活得相当滋润，跟小伙伴出去吃个火锅，去下酒吧也是负担得起的，大一大二不敢这么干，当然那时也没人约我这么干…… 然后就开始自己学校的申请，要说自己也挺菜的托福GRE都没考多少分，虽然大三开挂努力一年拿了次奖学金，但是大一大二挂科又重修，没多少优势。虽然项目做的多如牛毛，范围也很广，从手机app到windows应用程序到后台服务器到单片机物联网都有，但其实每个项目都没啥技术含量，内行人一看就知道。所以一开始申请的十所学校，一所都没要我，然后开始补申。补申的时候找老师签字，院长直接跟我说：“你申请这事搞得我很烦，你这样申请不到学校会影响我名声的！”。当时相当不爽，我又不是故意影响他老人家名声，虽然我也不知道他有啥名声。后差不多4月份补申了才能到sit，很不甘心但是有啥办法，自己明显不可能去mit嘛。 之后就大学毕业了，8月份到了美帝，由于之前没有租到房子直接住了一个月的喜来登，酒店房间特别好，每天早上起来都可以看到哈德逊河和对面的曼哈顿。之后抱国学大师舍友大腿租到了公寓，学会了写银行支票，学会了自己做饭，也开始尝试主动和别人交流。当然像大四那样生活是不可能了，曼哈顿片区的生活费真是贵的离谱，就算我每个月做个外包也只够交房租，没办法对自己太好直接住了最贵的片区。然后我就想办法开始省钱，但是发现省不了多少钱，毕竟一顿饭最少要花个6美元吧，吃上省钱太为难我这个吃货了。然后就换了个新的思路：多选课。学校每学期选3门和选4门课收一样的钱，一门课4大概4000多刀，这样一算一学期可以赚不少。这样过了一个学期，累的要死。尤其是有一门课，每周上三小时课，然后要看6小时的补充视频，然后运气好的话花20几个小时把代码写了就可以交了，有时候遇到莫名其妙的bug可能还要更多的时间。这学期过的十分疲惫，似乎学会了JAVAEE，似乎学会了Node.js 写后台，似乎学会了基本网页开发，似乎学会了基础人工智能知识，说似乎学会是因为我感觉自己啥也没学到，因为这些东西里面的原理，为什么这样写，我都没有深究，我觉得这是不行的。毕竟随便用个框架搭个服务器是个人都会，我觉得我之后需要学的更深入。 最累的其实是11～12月份，11月初收到了一个不可抗拒的邀请：到欧洲旅游。然后这个月各种final，各种deadline，加上实习公司的面试我题没刷多少，这个月差点没把我累死。当然结果还可以，我顺利搞到了英国的签证和德国的签证，然后过了两个期末考试以及4个project（其中有3个是拖到最后一周做的，该死的拖延症）。但是我简历被Google拒了，拿到了Facebook的面试但是第一轮跪了。说明自己还是需要加倍努力，还是有太多东西没学，尤其是深入的学习。计算机科学并不是会用框架就可以了，需要搞懂每个框架里的原理，需要阅读非常非常多的文档。 之后就是欧洲行了，非常梦幻，先后去了英国，法国，丹麦，挪威，德国，路线诡异，行程紧张，持续了20天。感谢父母强大的财政支持，感谢收留我的5位小伙伴，特别感谢其中的一个邀请人～ 元旦其实是一个很有趣的时刻——新的一页日历翻过去，你突然有一种脱离过去一年的轻松感，以及新的一年被交付的强大感。不过——过去其实没法结束：你要减的肉还在身上，你欠下的书还在书架，你做过的结果依然在增值。未来其实也没法开启：如果你没有真正搞清楚过去为什么不好，未来恐怕也不会有什么区别。 最后希望2017年可以有个女朋友。。 本来元旦就想写的但是前几天玩high了每天都很累，今晚刚好有时间写了个。。 – 2017.1.4 于慕尼黑]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伦敦]]></title>
    <url>%2F2016%2F12%2F24%2F%E4%BC%A6%E6%95%A6%2F</url>
    <content type="text"><![CDATA[伦敦这次行程比较紧张，毕竟出发前一周都不知道护照能不能到我手上，但是依然相信德国人的办事效率以及自己的人品，强行定了欧洲的机票和酒店。 从纽瓦克机场起飞，经过12小时的飞行，早上一早就降落到希思罗机场。这里强烈推荐下维珍亚特兰大航空，经济舱可以选很多种酒类，吃的也贼好，简直媲美海南航空。 早上8点到希思罗机场，海关几乎没人排队，问了我来英国干嘛的，我说来玩的就放我过了。 然后就尝试在机场打车，结果惊奇的发现，准备来欧洲玩二十几天的我居然只带了美元和人民币……还好Uber可以用美元结账。不过第一次去希思罗机场的同学要特别注意，这个机场有个异常奇葩的设计，Uber APP让我在机场的level 3 上车，但是所谓level 3其实是2楼。。。我一共打了3次车，到了第三次才有司机打电话跟我说了这个问题，然后接到我了，之前的司机一直在不停地绕圈，然后取消订单，扣我的钱，白白浪费了我10英镑。 机场内随处可见的华为广告 大英博物馆之后就去了大英博物馆。作为世界上历史最悠久的博物馆之一，大英博物馆成立于1753年，已经有261年的历史，藏品超过800万件，应该是去伦敦的必去景点。 然而著名的大英博物馆，说实话，真的令我失望，完全比不上纽约大都会，或者巴黎卢浮宫，里面光线很暗，藏品残缺不缺而且还看不清楚的，哪里像纽约大都会博物馆，连乾隆老爷子的金马鞍都有。 我逛了大约半小时就出来了，现在想想可能是小伙伴带我走错门了？或者是在整修？或者我在倒时差产生了幻觉？或者我撸多了眼花了？反正下次有机会我会好好去看下的。 伦敦塔桥和伦敦塔时差都没倒好就去了伦敦塔桥，主要是为了帮我国学大师室友送东西给妹子。大师就是大师，我本科的时候完全不敢想想这种操作：在纽约买个包包，让自己室友带上然后横跨大西洋送给一个刚好去伦敦玩的妹子……工科学校限制了我的想象力，下辈子高考我一定选个文科学校。 伦敦塔桥(Tower Bridge)是英国伦敦泰晤士河口的第一座桥，也是泰晤士河上15座桥梁中最知名的一座，是伦敦的象征，有“伦敦正门”之称。造型古典，十分漂亮。 然后就去了隔壁的景点，伦敦塔。伦敦塔的官方名称是“女王陛下的宫殿与城堡“(Her Majesty’s Palace and Fortress, The Tower of London)。一开始我们也不知道这中英文名字可以差得那么大，只记得一直找不到伦敦塔在哪，然后去了一个”名字很长不记得怎么拼写的“城堡。 伦敦塔修建于11世纪，是诸多历史事件发生地，1988年被列为世界文化遗产。它曾作为伦敦的军事要塞、军械库、国库、铸币厂、宫殿、刑场、公共档案办公室、天文台、避难所和监狱，特别是关押皇室、贵族等重要人物的监狱。最有名的囚犯当属亨利八世的第二任王后安·柏林（关于亨利八世和他的五个王后。伊丽莎白一世在其姐姐玛丽一世统治时曾在此入狱一段时间；伦敦塔最后一次作为监狱使用是在第二次世界大战期间，关押鲁道夫·赫斯。 城堡里面有很多穿着古代衣服的工作人员，在里面浏览别有一番风味。 大本钟和威斯敏斯特宫 威斯敏斯特宫，也就是英国的国会大厦，大本钟是国会大厦的钟楼，建于1859年伦敦泰晤士河畔，是伦敦著名古钟和标志性建筑之一。出现在了无数部电影里面，旁边的桥东里面好像还有007的秘密基地以及全新的阿斯顿马丁，当然我之后去看了下发现没有…… 钟楼高95米，钟直径9英尺，重13.5吨。从1859年开始大本钟便开始为伦敦报时，至今已有一个多世纪。大本钟也是英国人庆祝新年的重要场所。然而我去的那天威斯敏斯特宫在施工，没能进去参观。 西敏寺西敏寺， 又叫威斯敏斯特大教堂，始建于公元960 年，1045年进行了扩建，1065年建成，1220年至1517年进行了重建。它既是英国国教的礼拜堂，又是历代国王加冕及王室成员举行婚礼的地方，威廉王子的婚礼于2011年在此举行。它可以说是英国地位最高的教堂，除了王室成员以外，很多名人都安葬于此，并被视为至高无上的荣誉，其中包括牛顿、达尔文和丘吉尔等。所以有人说，人们去威斯敏斯特教堂，不是瞻仰国君，而是那些对国家有过贡献的人。整个教堂的建筑是哥特式风格的代表，既富丽堂皇又庄严静谧，阳光透过彩色的玻璃呈现出斑斓的色彩。 西敏寺 伦敦眼伦敦眼（The London Eye）是世界上第一座摩天轮，又称千禧之轮。一共有32个座舱，每个座舱可以坐25人，转一圈需要半小时。可以看到伦敦市全景，是不可多得的观景点。 一般建议傍晚十分去坐伦敦眼，因为那个时候刚好可以看到伦敦的晚霞，特别浪漫有情调，也十分适合特殊场合。好像可口可乐冠名之后土豪可以出钱直接包厢，工作人员会提前在座舱里面准备好你预定的酒，是表白求婚的好地方。（当然我也只是听说，具体操作我也不知道）。但是那天由于人太多，排队排到了天黑，没有办法，只能看到伦敦夜景了。但是不得不说夜景也是十分漂亮的。泰晤士河对岸的威斯敏斯特宫以及大本钟，国会大厦后面的西敏寺，远处的圣彼得堡以及伦敦塔桥都看得见。 贝克街221b作为福尔摩斯的死忠粉，贝克街221b是一定要去的。 其实贝克街221b却是一个不存在的地址，但是人们为了纪念这位神探，1930年使其成为可用地址。现今该地址被分配给夏洛克·福尔摩斯博物馆使用。 门口有一个维多利亚时期的警察 旁边是纪念品商店，一切跟福尔摩斯有关的东西都可以在里面买到。 这次表遗憾的是因为计划不周MI6的总部没去，Top Gear的演播厅没参观，国会大厦没参观，圣彼得堡教堂没参观以及大英博物馆没好好看。。。最最重要的是，白金汉宫没去成！计划下次去英国可以有个自驾游，把这些景点补上]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. Two Sum]]></title>
    <url>%2F2016%2F12%2F15%2F1-Two-Sum%2F</url>
    <content type="text"><![CDATA[原题 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. UPDATE (2016/2/13):The return format had been changed to zero-based indices.Please read the above updated description carefully. 思路用一个map，存入target-nums[i]的值和当前下标，也就是与当前元素配对的值和下标。如果遇到map里面已经有的值就返回map里的下标和当前下标就好～ 代码12345678910111213141516171819//C++class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; map; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (map.find(nums[i]) != map.end()) &#123; result.push_back(map[nums[i]]); result.push_back(i); return result; &#125; map[target - nums[i]] = i; &#125; return result; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[283. Move Zeroes]]></title>
    <url>%2F2016%2F12%2F15%2F283-Move-Zeroes%2F</url>
    <content type="text"><![CDATA[原题 Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: 1. You must do this in-place without making a copy of the array.2. Minimize the total number of operations. 思路直接把不是0的数往前移，然后把剩下的位置用零代替，这样只用遍历一遍数组。 代码1234567891011121314151617//C++class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int count =0; for(int i = 0;i&lt;nums.size();i++) &#123; if(!nums[i]==0)&#123; nums[count]=nums[i]; count ++; &#125; &#125; while(count&lt;nums.size())&#123; nums[count] = 0; count ++; &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国F1身份申请英国签证攻略]]></title>
    <url>%2F2016%2F12%2F02%2F%E7%BE%8E%E5%9B%BDF1%E8%BA%AB%E4%BB%BD%E7%94%B3%E8%AF%B7%E8%8B%B1%E5%9B%BD%E7%AD%BE%E8%AF%81%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[先介绍下背景，刚来美国3个月，英语不溜只会点菜那种，无驾照，无SSN，无工作，F1签证。 一般有美国签证申请英国签证是不会被拒签的，除非你的材料有大问题，所以认真准备都是可以过的 去英国玩是个很仓促的决定，所以我是提前一个月才开始申请的，请不要学我，一般要提前三个月 预约首先登陆英国签证网站 然后注册一个账号 然后网上填写申请表格，填过DS160的对这个无压力啦。 这个表很长，可以边填边保存 有一项英国期间逗留地址和联系方式可以填宾馆的地址，或者你朋友家地址（我比较害羞不敢问朋友家地址，填的是宾馆的地址……） 住宿最好提前预定，可以上http://www.booking.com/ 预定，免费取消 你预计在英国停留时间必须和你预定的宾馆的时间一定要对上。做假做的像一点，拿到签证后你爱住几天住几天 然后付钱，申请费我付了110刀，貌似降价了（有加急的，我心比较大，没有预约加急的）。 付完钱之后就可以选择预约去Application Support Center的时间，这个地方很多，每个城市都有，可以选择离自己最近的。离我最近的在曼哈顿，但是时间已经排到明年1月8号了，所以只能预约布鲁克林那个。预约主要是为了录取你的指纹然后给你拍一张照片，美名曰：录取生物信息。 然后返回申请的网站，会有一系列文件要你打印，把它们全部下载打印出来，都会用到的。其中有一个叫Appointment Confirmation的很重要，你录取生物信息的时候会用到。 录指纹根据预约的时间你要去Application Support Center录取指纹。 布鲁克林的Application Support Center长这样，要不是有谷歌地图我绝对找不到： 我选的时间是中午12点，但是我11点就到了，然而因为排长队我两点钟才弄完，所以建议各位去早一点。 另外，这个center里面手机是没信号的，而且不准玩手机，如果玩手机工作人员会凶你……提前带本书啥的去看吧。 布鲁克林这个Application Support Center很有意思，那一片全是犹太人。我那天见到的人都是这样的： 和这样的 我当时不知道是犹太人，以为是某黑手党地盘，所以只能偷拍几张： 请无视我的拍照技术，当时还是很害怕的，只敢偷拍。。 寄材料一旦取好指纹后，你必须在两周内把所有签证的材料寄出，我由于很急，当天就寄出了，这是我的材料清单： 护照 护照复印件 美国visa 旅行计划（酒店订单，机票等 在读证明 住址证明（银行账单） 酒店订单 I-94 两张照片 英国签证申请表 取指纹的表 往返机票 预付费信封 I-20 其中有几个要注意的地方： 旅行计划我自己也不知道我要去英国玩多久（小伙伴做的旅游攻略，我只是负责拎包），所以我当时预约的时候写了13天，全在伦敦。。这就比较蛋疼了，因为你要编13天的旅行计划。 所以为了凑够天数，我几乎写上了伦敦所有足球俱乐部，我旅行计划是这样的： 阿森纳（Arsenal）切尔西（Chelsea）富勒姆（Fulham）托特纳姆热刺（Tottenham Hotspur ）西汉姆联（West Ham United）House of parliament伦敦塔桥 Tower Bridge白金汉宫 Buckingham PlaceBig benwestminster AbbeyLondon EyeBritish Museum 2dayRoyal Observatory GreenwichNational GalleryHyde ParkThe Sherlock Holmes Museum 当然，我现在也不知道我到底要玩那些地方。。 在读证明在读证明找学校的register center要就好了，一般一两天就给你 银行账单这个……越多越好，我这次用的账单只有3K刀，也过了。另外我的存款证明只有三个月。 I-94这个表上网下载就好，就是你入境的时候填的表 https://i94.cbp.dhs.gov/I94/#/home 两张照片照片规格必须是45*35mm 往返机票当时我也不知道能不能过，也没定，于是找了万能的淘宝，然后淘宝帮我做了一个假的机票行程，80RMB，包括欧洲五国半个月的所有航班。 建议别这样，估计这假的行程只有英国人会信，或者让店小二给你做的真一点。 预付费信封我用UPS寄的，跟他们说你要个return label，然后一起放到寄的材料里面。 另附一个英国大使馆地址，当时找了好久。 时间我是11月18日录完指纹 11月18日寄出所有材料 11月21号UPS显示寄到 11月22号大使馆说受到了材料 11月30号说我签证通过 12月2号也就是今天拿到的签证 然后过几天7号要去面签德国签证，很虚。。 签证长这个样子 这里要吐槽下美国快递，真是垃圾。 我寄过去领事馆用的是UPS Ground，9刀 回来的时候我要求用Next Day，31刀，但是送了2天，目前正在研究怎么找他们麻烦。 然后今天收到的材料是这样的，我交的所有的材料他们都退回给我了，check list没有划勾，在读证明也没有打开。总的来说，他们啥材料都没看……]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53.Maximum Subarray]]></title>
    <url>%2F2016%2F11%2F29%2F53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[原题 Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. More practice:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 思路非常典型的DP问题。 子数组只会有两种操作： 如果总和比之前大就不停的添加新成员 如果总和比之前一次变小了就清空成员重新计数 于是只用记住历史最大值和数组总和最大值就好 代码12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxValue = INT_MIN; int tempMax = 0; for(int x:nums)&#123; tempMax = max(tempMax + x,x); maxValue = max(maxValue,tempMax); &#125; return maxValue; &#125; &#125;;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35. Search Insert Position]]></title>
    <url>%2F2016%2F11%2F27%2F35-Search-Insert-Position%2F</url>
    <content type="text"><![CDATA[题目 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 思路这个应该算easy吧……不是很懂难度划分 找到大于等于target的数字返回下标就好。 代码暴力……123456789101112131415//C++class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i=0;i&lt;nums.size();i++)&#123; if(nums[i]&gt;=target)&#123; return i; &#125; else if(i==nums.size()-1)&#123; return i+1; &#125; &#125; return 0; &#125;&#125;; 二分法：1234567891011121314151617181920212223//C++class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size()-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target)&#123; return mid; &#125; else if(nums[mid]&lt;target)&#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return right + 1; &#125;&#125;;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 画柱状图]]></title>
    <url>%2F2016%2F10%2F26%2F%E7%94%BB%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[数据统计是科研中很重要的一部分，所以我们老师老是让我搞各种数据可视化的工作………… 首先要安装matplotlib 1pip install matplotlib 基本柱状图（使用hist函数）12345678910111213import matplotlib.pyplot as pltimport numpy as np# Learn about API authentication here: https://plot.ly/python/getting-started# Find your api_key here: https://plot.ly/settings/apigaussian_numbers = np.random.randn(1000)plt.hist(gaussian_numbers)plt.title("Gaussian Histogram")plt.xlabel("Value")plt.ylabel("Frequency")plt.show() 多个数据集的柱状图123456789import pylab as pltimport plotly.plotly as pyfig = plt.figure()x = 200 + 25*plt.randn(1000)y = 150 + 25*plt.randn(1000)n, bins, patches = plt.hist([x, y])plt.show() 概率密度函数12345678910111213141516171819202122232425import numpy as npimport matplotlib.mlab as mlabimport matplotlib.pyplot as pltimport plotly.plotly as py # tools to communicate with Plotly's serverfig = plt.figure()# example datamu = 100 # mean of distributionsigma = 15 # standard deviation of distributionx = mu + sigma * np.random.randn(10000)num_bins = 50# the histogram of the datan, bins, patches = plt.hist(x, num_bins, normed=1, facecolor='green', alpha=0.5)# add a 'best fit' liney = mlab.normpdf(bins, mu, sigma)plt.plot(bins, y, 'r--')plt.xlabel('Smarts')plt.ylabel('Probability')# Tweak spacing to prevent clipping of ylabelplt.subplots_adjust(left=0.15)plt.show() https://plot.ly/matplotlib/histograms/http://matplotlib.org/api/pyplot_api.html]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作Mongodb]]></title>
    <url>%2F2016%2F10%2F26%2Fpython%E6%93%8D%E4%BD%9CMongodb%2F</url>
    <content type="text"><![CDATA[先安装pymongo 1pip install pymongo from pymongo import MongoClient1from pymongo import MongoClient 创建链接1client = MongoClient() 1client = MongoClient("mongodb://mongodb0.example.net:27017") 连接到指定的database和collection12db = client.test_dbcollection = db.test_collection 也可以像这样 12db = client["test_db"]collection = db["test_collection"] 两种代码是等价的 其中collection相当于关系型数据库的表。 增删查改操作插入12345678data = &#123;"name":"John","age":23,"sex":"male"&#125;collection.insert(data)collection.insert_one(data)#inser_many()必须为数组dataList = []dataList.append(data)collection.insert_many(dataList) 删除123collection.remove(temp) #即便该temp不存在也不会报错collection.delete_one(temp)collection.delete_many(temp) #与 .insert_many() 不同，在temp不是list类型时也不会报错 查询空查询： 12#返回collection所有记录collection.find(&#123;&#125;) find_one()显示满足条件的第一个collection，而find()这是所有满足查询条件的一个数组。 123#返回所有名字叫lucy的人for data in collection.find(&#123;"name":"Lucy"&#125;) print data 查询指定条件的collection，可以指定一个活多个条件： 12collection.find_one(&#123;“name”:”Lucy”&#125;)collection.find_one(&#123;“name”:”Lucy”, “sex”:”female”&#125;) .count()统计结果总条数： 1collection.find(&#123;“name”:”Lucy”&#125;).count() 指定大于小于等于条件查询： 1collection.find(&#123;“age”: &#123;“$lt”: 30&#125;&#125;) 这样的查询符号有 $lt（小于）， $gt（大于）， $lte（小于等于）， $gte（大于等于）， $ne（不等于），这与原生 MongoDB 中相同。 将查询结果按条件排序： 123collection.find().sort("age") #默认，升序collection.find().sort("age", pymongo.ASCENDING) #升序collection.find().sort("age", pymongo.DESCENDING) #降序 更新12345temp = collection.find_one(&#123;"name":"Lucy"&#125;)temp2 = temp.copy()temp["name"] = "Jordan"collection.save(temp) #或 .update() ，注意参数形式collection.update(temp, temp2) #将temp更新为temp2 如果直接输出查询结果，会发现输出的是一“团”连续的，没有锁进的JSON数据，完全没有办法看，这时可以通过下面这行代码来输出格式化的JSON数据： 123import json# item 是你要输出的数据print json.dumps(item, indent=4, sort_keys=True) http://xitongjiagoushi.blog.51cto.com/9975742/1657096http://api.mongodb.org/python/current/tutorial.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip和easy_install]]></title>
    <url>%2F2016%2F09%2F28%2Fpip%E5%92%8Ceasy-install%2F</url>
    <content type="text"><![CDATA[pip和easy_install有句话这么说的： Don’t use easy_install, unless you like stabbing yourself in the face. Use pip. easy_install诞生于2004年，用于安装PyPI上的各种程序包以及它们的依赖，是一种自动化的包管理工具。 pip诞生于2008年，是easy_install的升级版。 具体区别如下： pip easy_install Installs from Wheels Yes No Uninstall Packages Yes (pip uninstall) No Dependency Overrides Yes (Requirements Files) No List Installed Packages Yes (pip list and pip freeze) No PEP 438 Support Yes No Installation format ‘Flat’ packages with egg-info metadata. Encapsulated Egg format sys.path modification No Yes Installs from Eggs No Yes pylauncher support No Yes Multi-version Installs No Yes Exclude scripts during install No Yes 总之，就是把几乎把easy_install的功能都包含进去了，还附加了许多新功能，尤其是uninstall 卸载功能以及安装失败不会对你的系统环境不会有什么影响。 [1] http://stackoverflow.com/questions/3220404/why-use-pip-over-easy-install [2] https://packaging.python.org/pip_easy_install/ 当然，也不是一定只能用pip，今天就有个很蛋疼的事。为了做Machine Learning的作业，我需要安装pydot等包。使用pip之后包被成功安装在/Library/Python/2.7/site-packages文件夹下，但是程序报错说ImportError: No module named pydot。然后我先后尝试了： 把/Library/Python/2.7/site-packages路径加入 ~/.bash_profile python -m pip install pydot 删除pydot然后冲洗安装 重新安装python 升级pip …… 等操作，都没有什么卵用，于是我打算重装系统了。 后来，在最绝望的时候，某个一直为情所困的女同志发消息说她好了，因为课业太重了，没功夫纠结。我就突然想到貌似可以用个东西代替pip，也就是easy_install。然后试了下，easy_install刚好也是把pydot装在/Library/Python/2.7/site-packages/目录下，然而程序可以运行了…… 真是神奇的不行]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过公钥登录阿里云]]></title>
    <url>%2F2016%2F09%2F17%2F%E9%80%9A%E8%BF%87%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[好久没写博客了，因为中间发生了很多事，心情很乱，没有心思写博客，改写日记。。。现在又来了美帝开始读研究生，感觉博客还是要继续写。虽然这写东西并不能称作为博客，因为自己写的几乎就是照搬网上的一些东西，更像是一堆技术笔记。不过管他的，反正除了我自己又没人看…… 之前登录阿里云都是像这样： 1ssh username@IP 然后这几天上课，发现教授要求用公钥私钥登录，免去了写密码的步骤，感觉十分方便（虽然是老技术，自己之前也知道，但是从来都没折腾过，所以一直用着密码登录，真是没有一点点求知欲）。 具体操作如下： 创建~/.ssh/autorized_keys文件我的阿里云用的是Ubuntu，没有~/.ssh/autorized_keys，所以要自己手动创建一个 首先登录到客户端，根目录下： 1mkdir ~/.ssh 给~/.ssh文件夹赋予权限 1chmod 700 ~/.ssh 常用修改权限的命令： chmod 600 ××× （只有所有者有读和写的权限） chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限） chmod 700 ××× （只有所有者有读和写以及执行的权限） chmod 666 ××× （每个人都有读和写的权限） chmod 777 ××× （每个人都有读和写以及执行的权限） 然后通过新建一个autorized_keys文件 1vim ~/.ssh/autorized_keys 修改/etc/ssh/sshd_config通过vim打开/etc/ssh/sshd_config文件 1vim /etc/ssh/sshd_config 取消这一行的注释 然后重启ssh服务 1service ssh restart 添加自己的公钥公钥可以自己生成一个，然后自己保管好私钥就好。由于我的电脑是Mac，就直接用自己的了。 我的公钥在自己电脑的~/.ssh/目录下，通过SCP命令上传到自己的服务器，注意IP后面有个冒号！！ 12#本地命令scp id_rsa.pub username@IP: 然后回到服务器根目录，通过命令，将公钥添加到 ~/.ssh/authorized_keys文件里 12#服务器命令cat *.pub &gt;&gt; ~/.ssh/authorized_keys 然后就可以直接通过命令登录了，不再需要输入密码。 1ssh username@IP 对于亚马逊云（AWS）的Amazon Linux，这个Linux里面以及有了~/.ssh/authorized_keys文件，无需创建，直接添加公钥就好～ 这个学校明明那么有钱，却不给学生租点服务器，要学生自己去租亚马逊云。。。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdfMiner UnicodeEncodeError]]></title>
    <url>%2F2016%2F05%2F22%2FpdfMiner-UnicodeEncodeError%2F</url>
    <content type="text"><![CDATA[pdfMiner UnicodeEncodeError用pdfMiner读取中文pdf内容的时候，会遇到这个错误 UnicodeEncodeError: ‘ascii’ codec can’t encode character u’\xe9’ in position 0: ordinal not in range(128) 解决这个问题需要修改一点官方源码使得它可以读取中文字符。 下面是我读取PDF文件的函数，使用时将PDF文件路径传进去即可，函数会返回PDF中所有的内容。 1234567891011121314151617181920212223def convert_pdf_to_txt(path): rsrcmgr = PDFResourceManager() retstr = StringIO() codec = 'utf-8' laparams = LAParams() device = TextConverter(rsrcmgr, retstr, codec=codec, laparams=None) fp = file(path, 'rb') interpreter = PDFPageInterpreter(rsrcmgr, device) password = "" maxpages = 0 caching = True pagenos=set() for page in PDFPage.get_pages(fp, pagenos, maxpages=maxpages, password=password,caching=caching, check_extractable=True): interpreter.process_page(page) text = retstr.getvalue() print text fp.close() device.close() retstr.close() return text 需要修改源码convert.py文件167行，将 1self.outfp.write(u"é") 改为 1self.outfp.write(u"é".encode('utf-8')) 否则会有以下报错信息报错： 1234567891011121314Traceback (most recent call last): File "/Users/Administer/Desktop/pdfReader.py", line 33, in &lt;module&gt; convert_pdf_to_txt('document1.pdf') File "/Users/Administer/Desktop/pdfReader.py", line 13, in convert_pdf_to_txt device = TextConverter(rsrcmgr, retstr, codec=codec, laparams=None) File "/Library/Python/2.7/site-packages/pdfminer/converter.py", line 180, in __init__ PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams) File "/Library/Python/2.7/site-packages/pdfminer/converter.py", line 167, in __init__ self.outfp.write(u"é")UnicodeEncodeError: 'ascii' codec can't encode character u'\xe9' in position 0: ordinal not in range(128)[Finished in 0.2s with exit code 1]Administer[shell_cmd: python -u "/Users/Administer/Desktop/pdfReader.py"][dir: /Users/Administer/Desktop][path: /usr/bin:/bin:/usr/sbin:/sbin]]]></content>
      <tags>
        <tag>python</tag>
        <tag>pdfMiner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS接入XMPPFrameWork]]></title>
    <url>%2F2016%2F04%2F15%2FiOS%E6%8E%A5%E5%85%A5XMPPFrameWork%2F</url>
    <content type="text"><![CDATA[XMPP(Extensible Messaging and Presence Protocol 可扩展通讯和表示协议)，是一种基于标记语言的子集XML的协议，以Jabber协议为基础，而Jabber是即时通讯中常用的开放式协议。 简单来说，用这个东西可以实现APP间的聊天功能。 当然，我们不用自己实现一个XMPP，已经有人写好了XMPP Framework 安装官方方法按照官网的安装步骤： 先把最新的XMPPFramework的项目添加到自己的项目中。 添加 CocoaLumberjack 依赖 添加 CocoaAsyncSocket 依赖 添加 KissXML 依赖 添加 libidn 依赖 将以下文件夹添加到项目中 Authentication Categories Core Utilities ………………………… 看到这里各位的心情应该跟我当时是一样的：什么鬼！！！为什么要加那么多东西！！！为什么不能直接支持CocoaPods？？？ 然后，我怀着崩溃的心情，试了下 1pod search XMPPFrameWork 结果 !!!!!! 居然是有的！！！ 啊，你说这作者，明明支持CocoaPods，干嘛不在Readme里面顺便说一声呢？ CocoaPods直接在Podfile里面添加 1pod 'XMPPFramework', '~&gt; 3.6.6' 然后 1pod install 就可以愉快的使用了 如果项目原来有CocoaLumberjack如果你跟我一样原来的项目里面有CocoaLumberjack，那么会踩到一个坑： XMPPFrameWork 需要的的 CocoaLumberjack 版本为 1.9。。。。 然后降了版本安装好之后，你会惊奇的发现： CocoaLumberjack用不了了！！！它的头文件\&lt;CocoaLumberjack/CocoaLumberjack.h&gt;莫名其妙的失踪了！！！ 目前我也不知道这种情况要怎么办…… 代替方案是这样的： 去掉\&lt;CocoaLumberjack/CocoaLumberjack.h&gt;引入DDLog.h可以勉强用用～ 123#import "DDLog.h"static const int ddLogLevel = 0; 使用 首先需要通过调用，下面的东西链接服务器： 其中，JID是一个需要自己构造的对象，这个东西将作为你的唯一ID，一般情况下是这种样子：用户名@服务域名。resource是你发出去的信息的终端的标记可以不填。填了只是便于在数据库搜索用。官方解释: As a fixed length character field, a resource identifier is more easily stored in, searched on, and retrieved from a database. 12XMPPJID *jid = [XMPPJID jidWithUser:@"username" domain:@"domain" resource:@"resource"];[self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&amp;error] 上面构造的JID就是： username@domain 如果成功链接会调用代理方法 1- (void)xmppStreamDidConnect:(XMPPStream *)sender&#123;&#125; 然后通过方法提供密码登录 1[[self xmppStream] authenticateWithPassword:self.password error:&amp;error] 如果成功登录会调用下面这个代理方法 1- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123;&#125; 这时就可以开始正常聊天了～ 发送消息 由于XMPP协议是基于XML的，所以所有发出的消息和接收的消息都是XML格式的 123456789NSXMLElement *body = [NSXMLElement elementWithName:@"body"]; [body setStringValue:message]; NSXMLElement *XMLmessage = [NSXMLElement elementWithName:@"message"]; [XMLmessage addAttributeWithName:@"type" stringValue:@"chat"]; //toUser是接收人的用户名 NSString *to = [NSString stringWithFormat:@"%@@domain", toUser]; [XMLmessage addAttributeWithName:@"to" stringValue:to]; [XMLmessage addChild:body]; [self.xmppStream sendElement:XMLmessage]; 接收消息 收到消息后会调用下面这个代理，可以在里面处理收到的消息。 123- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message &#123; NSString *txt = [[message elementForName:@"body"] stringValue]; &#125; 示例 首先我在我电脑上建了一个open fire客户端。open fire是一个开源的支持XMPP的服务器，安装很简单，基本上是一路next，然后运行的时候链接下自己的手机壳就可以用了，网上很多例子，这里就不说了。其次聊天界面我使用了一个别人写好的（因为自己写的太TM丑了），叫做JSQMessagesViewController，可以直接用CocoaPods安装，很好用。 我究竟是有多懒…… 聊天界面引入1#import "xmpp.h" 然后声明几个属性，其中xmppStream用来储存链接信息，account,password用来储存自己的账户密码，toUser用来存放对方账户的账号。 12@property (strong, nonatomic) XMPPStream *xmppStream;@property (strong, nonatomic) NSString *account,*password,*toUser; 链接服务器：1234567891011121314151617- (void)connect &#123; if (self.xmppStream == nil) &#123; self.xmppStream = [[XMPPStream alloc] init]; [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()]; &#125; if (![self.xmppStream isConnected]) &#123; NSString *username = self.account; XMPPJID *jid = [XMPPJID jidWithUser:username domain:@"localhost" resource:@"iOS"]; [self.xmppStream setMyJID:jid]; [self.xmppStream setHostName:@"localhost"]; NSError *error = nil; if (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&amp;error]) &#123; NSLog(@"Connect Error: %@", error); &#125; &#125;&#125; 注册因为要连接上才可以注册所以需要调用- (void)xmppStreamDidConnect:(XMPPStream *)sende函数 1234567- (void)xmppStreamDidConnect:(XMPPStream *)sender &#123; NSError *error = nil; if (![self.xmppStream registerWithPassword:@"123456" error:&amp;error]) &#123; NSLog(@"Register Error: %@", error); &#125;&#125; 登录12345678- (void)xmppStreamDidConnect:(XMPPStream *)sender&#123; NSError *error = nil; if (![[self xmppStream] authenticateWithPassword:@"123456" error:&amp;error]) &#123; DDLogError(@"Error authenticating: %@", error); &#125;&#125; 设置自己在线12345- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123; XMPPPresence *presence = [XMPPPresence presence]; // type="available" is implicit [[self xmppStream] sendElement:presence];&#125; 发送消息：1234567891011- (void)sendMessage:(NSString *) message toUser:(NSString *) user &#123; NSXMLElement *body = [NSXMLElement elementWithName:@"body"]; [body setStringValue:message]; NSXMLElement *XMLmessage = [NSXMLElement elementWithName:@"message"]; [XMLmessage addAttributeWithName:@"type" stringValue:@"chat"]; NSString *to = [NSString stringWithFormat:@"%@@john.local", user]; [XMLmessage addAttributeWithName:@"to" stringValue:to]; [XMLmessage addChild:body]; [self.xmppStream sendElement:XMLmessage];&#125; 其中 1NSString *to = [NSString stringWithFormat:@"%@@john.local", user]; 是用来构造接收用户的JID的，john.local应该改成服务器域名，这里这个是我本机open fire 自建的域名。 接收消息1234567891011121314- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message &#123; if ([message.type isEqual:@"chat"]) &#123; NSString *txt = message.body; if (txt != nil) &#123; JSQMessage *msg = [[JSQMessage alloc] initWithSenderId:self.toUser senderDisplayName:@"客服" date:[NSDate date] text:txt]; [self.demoData.messages addObject:msg]; [self finishSendingMessageAnimated:YES]; &#125; &#125;&#125; 效果图手机端： 桌面端：（open fire自带的一个桌面客户端，测试用）]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求方法]]></title>
    <url>%2F2016%2F04%2F15%2FHTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在软件学院混到大四了，对于http的请求方法还局限于GET,POST,DELETE,PUT四种。其中绝大部份做过的项目只有GET,POST两种，当然也遇到过所有请求全部用POST的奇葩项目。 今天看了《图解HTTP》也对HTTP请求方法有了进一步了解，介于网上好像也没有很好的介绍HTTP请求方法的资料，我在这里记录下～ method description HTTP vision GET 获取资源 1.0、 1.1 POST 传输实体主体 1.0、 1.1 PUT 传输文件 1.0、 1.1 HEAD 获得报文头部 1.0、 1.1 DELETE 删除文件 1.0、 1.1 OPTIONS 询问支持的方法 1.1 TRACE 追踪路径 1.1 CONNECT 要求用隧道协议链接代理 1.1 LINK 建立和资源之间的联系 1.0 UNLINK 断开链接关系 1.0 HTTP/1.1中可使用的方法GET方法GET方法通常用来请求被URI识别的资源，资源经过服务区端解析后返回。比如：你请求了一个网页，它就给你返回个html； 如果你请求了某个搜索，服务器就把搜索结果返回给你。 POST方法POST方法用来传输实体的主体。 意思就是POST方法是用来向服务器发送内容的。POST和GET很像，GET也可以向服务器传输实体的主体，但是GET主要是用来向服务器获取内容的，而POST不是。 PUT方法PUT方法用来传输文件，要求在请求主报文的主体中包含文件内容，然后保存在指定位置。 但是由于PUT不带验证机制，任何人都可以上传文件。这样就产生了安全问题，所以一般的网站不用这个方法，除非可以配合Web应用的验证机制（spring security）或架构设计采用REST标准的同类web网站，就可能会开放使用PUT方法。 DELETE方法DELETE方法与PUT方法相反，用于删除URI指定的资源。 DELETE同样不带有验证机制，所以一般的网站不用这个方法，除非在网站中加入了验证机制。 HEAD方法HEAD方法用于确认URI的有效性及资源更新时间等，相当于不返回报文主体部分的GET方法。 OPTIONS方法OPTIONS方法用来查询服务器支持的HTTP方法。 比如你发了个OPTIONS请求给服务器，服务器返回了 GET,POST,PUT,DELETE，说明服务器支持这四种方法。 TRACE方法TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。 客户端可以通过TRACE方法查询发送出去的请求是怎样被加工／篡改的。因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认链接过程中发生的一系列操作。 （这个方法一般不用） CONNECT方法CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要是用SSL和TLS协议把通信内容加密后经网络隧道传输。 URI和URLURI:(Uniform Resource Identifier) URL: (Uniform Resource Loccator) 相比起URI，我们更熟悉URL。每次我们访问网页需要在浏览器中输入的网址就是URL。 URI用字符串标示某一互联网资源，而URL表示资源地点。所以URL是URI的子集，但是也可以认为URL就是URI。。 什么是REST标准？REST（Representational State Transfer）描述了一个架构样式的网络系统，比如 web 应用程序。REST并没有一个明确的标准，而更像是一种设计的风格。所以REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 资源是由URI来指定。对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。通过操作资源的表形来操作资源。 参考资料：上野宣. 图解HTTP[M]. 人民邮电出版社, 2014.http://www.cnblogs.com/taven/archive/2009/09/06/1561358.html]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPOI的使用之读写Excel]]></title>
    <url>%2F2016%2F04%2F12%2FNPOI%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%AF%BB%E5%86%99Excel%2F</url>
    <content type="text"><![CDATA[NPOI 是 POI 项目的 .NET 版本。POI是一个开源的Java读写Excel、WORD等微软OLE2组件文档的项目。 使用 NPOI 你就可以在没有安装 Office 或者相应环境的机器上对 WORD/EXCEL 文档进行读写。NPOI是构建在POI 3.x版本之上的，它可以在没有安装Office的情况下对Word/Excel文档进行读写操作。 下载首先到http://npoi.codeplex.com/官网上下载NPOI的dll，有2和4两个不同版本的dll，分别对应不同的.NET版本，我在自己的项目中使用了4版本的.NET。 添加引用右键项目 -&gt;添加-&gt;引用,如图 然后点击浏览，把刚才下载好的dll选中添加到项目中（建议把dll文件夹直接放倒项目根目录下） 操作Excel123456using NPOI;NPOI.HSSF.UserModel.HSSFWorkbook book = new NPOI.HSSF.UserModel.HSSFWorkbook();NPOI.SS.UserModel.ISheet sheet = book.CreateSheet("export");NPOI.SS.UserModel.IRow row = sheet.CreateRow(0); 合并单元格参数分别是：起始行，结束行，起始列，结束列 1sheet.AddMergedRegion(new NPOI.SS.Util.CellRangeAddress(0, 0, 1, 12)); 单元格水平对齐1row.CreateCell(i).CellStyle.Alignment = NPOI.SS.UserModel.HorizontalAlignment.Center; 单元格垂直对齐1row.CreateCell(i).CellStyle.VerticalAlignment = NPOI.SS.UserModel.VerticalAlignment.Center; 单元格自动换行（很不稳定会导致单元格内容突然没有了）1row.CreateCell(i).CellStyle.WrapText = true; 示例导出一个DataGridView的Excel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/// &lt;summary&gt;/// 导出excel/// &lt;/summary&gt;/// &lt;param name="dt"&gt;&lt;/param&gt;/// &lt;param name="filePath"&gt;&lt;/param&gt;private void WriteExcel(string filePath) &#123; if (!string.IsNullOrEmpty(filePath)) &#123; NPOI.HSSF.UserModel.HSSFWorkbook book = new NPOI.HSSF.UserModel.HSSFWorkbook(); NPOI.SS.UserModel.ISheet sheet = book.CreateSheet("export"); NPOI.SS.UserModel.IRow row = sheet.CreateRow(0); int[] columnWidth = &#123; 8, 8, 8, 8, 30, 30, 8, 8, 8, 8 &#125;; for (int i = 0; i &lt; columnWidth.Length; i++) &#123; row.CreateCell(i).CellStyle.Alignment = NPOI.SS.UserModel.HorizontalAlignment.Center; //乘以256是因为Excel中列宽是以256为单位的，详情可以看函数的注释 sheet.SetColumnWidth(i, columnWidth[i] * 256); //乘以256是因为Excel中行高是以20为单位的，详情可以看函数的注释 row.Height = 15 * 20; &#125; sheet.AddMergedRegion(new NPOI.SS.Util.CellRangeAddress(0, 0, 0, 10)); row.GetCell(0).SetCellValue("合并的单元格"); NPOI.SS.UserModel.IRow row2 = sheet.CreateRow(1); row2.Height = 28 * 20; string[] columnName = &#123; "编号", "标题", "标题", "标题", "长……长……的……标……题……", "长……长……的……标……题……", "标题", "标题", "标题", "标题" &#125;; for (int i = 0; i &lt; columnName.Length; i++) &#123; row2.CreateCell(i).CellStyle.VerticalAlignment = NPOI.SS.UserModel.VerticalAlignment.Center; row2.CreateCell(i).SetCellValue(columnName[i]); &#125; //具体信息 for (int i = 0; i &lt; 10; i++) &#123; NPOI.SS.UserModel.IRow rowDetail = sheet.CreateRow(i + 2); rowDetail.Height = 70 * 20; rowDetail.CreateCell(i).CellStyle.WrapText = true; rowDetail.CreateCell(0).SetCellValue((i + 1).ToString()); rowDetail.CreateCell(1).SetCellValue("内容"); rowDetail.CreateCell(2).SetCellValue("内容"); rowDetail.CreateCell(3).SetCellValue("内容"); rowDetail.CreateCell(4).SetCellValue("好……多……好……多……好……多……的……内……容……好……多……好……多……好……多……的……内……容……好……多……好……多……好……多……的……内……容……"); rowDetail.CreateCell(5).SetCellValue("好……多……好……多……好……多……的……内……容……好……多……好……多……好……多……的……内……容……好……多……好……多……好……多……的……内……容……"); rowDetail.CreateCell(6).SetCellValue("内容"); rowDetail.CreateCell(7).SetCellValue("内容"); rowDetail.CreateCell(8).SetCellValue("内容"); rowDetail.CreateCell(9).SetCellValue("内容"); &#125; // 写入到客户端 using(System.IO.MemoryStream ms = new System.IO.MemoryStream()) &#123; book.Write(ms); using(FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write)) &#123; byte[] data = ms.ToArray(); fs.Write(data, 0, data.Length); fs.Flush(); &#125; book = null; &#125; &#125;&#125; 1234567SaveFileDialog sfd = new SaveFileDialog();sfd.Filter = "Excel Documents (*.xls)|*.xls";sfd.FileName = "export.xls";if (sfd.ShowDialog() == DialogResult.OK)&#123; this.WriteExcel(sfd.FileName);&#125; 效果图： 读取ExcelNPOI 使用 HSSFWorkbook 类来处理 xls，XSSFWorkbook 类来处理 xlsx，它们都继承接口 IWorkbook，因此可以通过 IWorkbook 来统一处理 xls 和 xlsx 格式的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void ReadFromExcelFile(string filePath)&#123; IWorkbook wk = null; string extension = System.IO.Path.GetExtension(filePath); try &#123; FileStream fs = File.OpenRead(filePath); if (extension.Equals(".xls")) &#123; //把xls文件中的数据写入wk中 wk = new HSSFWorkbook(fs); &#125; else &#123; //把xlsx文件中的数据写入wk中 wk = new XSSFWorkbook(fs); &#125; fs.Close(); //读取当前表数据 ISheet sheet = wk.GetSheetAt(0); IRow row = sheet.GetRow(0); //读取当前行数据 //LastRowNum 是当前表的总行数-1（注意） int offset = 0; for (int i = 0; i &lt;= sheet.LastRowNum; i++) &#123; row = sheet.GetRow(i); //读取当前行数据 if (row != null) &#123; //LastCellNum 是当前行的总列数 for (int j = 0; j &lt; row.LastCellNum; j++) &#123; //读取该行的第j列数据 string value = row.GetCell(j).ToString(); Console.Write(value.ToString() + " "); &#125; Console.WriteLine("\n"); &#125; &#125; &#125; catch (Exception e) &#123; //只在Debug模式下才输出 Console.WriteLine(e.Message); &#125;&#125; 输出如图：]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RKTagsView]]></title>
    <url>%2F2016%2F04%2F03%2FRKTagsView%2F</url>
    <content type="text"><![CDATA[RKTagsView安利一个神奇的东西：RKTagsView，可以把输入的内容变成一段一段的标签样式。 效果如图： 项目地址 安装cocoapods在PodFile中添加：即可 1pod "RKTagsView" 添加源文件直接把RKTagsView.h,RKTagsView.m两个文件拖到自己项目中也可以。 使用常规使用使用非常简单，新建一个UIView，然后设置这个View的类为 RKTagsView 123456789101112131415161718192021//是否可以编辑self.tagsView.editable = NO; //标签是否可以被选中self.tagsView.selectable = NO; //是否可以同时选择多个标签self.tagsView.allowsMultipleSelection = NO; //标签之间的左右间距self.tagsView.interitemSpacing = 1.0;//标签之间的上下间距self.tagsView.lineSpacing = 1.0;//添加标签[self.tagsView addTag:@"tag"];//移除标签[self.tagsView removeAllTags]; 自定义标签样式自定义需要设置View的代理 1234&lt;RKTagsViewDelegate&gt;self.tagsView.delegate = self; 然后在(UIButton *)tagsView:(RKTagsView *)tagsView buttonForTagAtIndex:(NSInteger)index函数中设置相应的样式，比如下面这个例子就设置了每隔四个标签显示不同颜色的tagsView: 1234567891011121314151617181920212223242526272829- (UIButton *)tagsView:(RKTagsView *)tagsView buttonForTagAtIndex:(NSInteger)index &#123; UIButton *customButton = [UIButton buttonWithType:UIButtonTypeCustom]; customButton.titleLabel.font = tagsView.font; [customButton setTitle:[NSString stringWithFormat:@" %@ ", tagsView.tags[index]] forState:UIControlStateNormal]; customButton.layer.cornerRadius = 3.0; customButton.layer.masksToBounds = YES; customButton.layer.borderWidth = 1.0; switch (index % 4) &#123; case 0: [customButton setTitleColor:[UIColor colorWithRed:66.0/255 green:175.0/255 blue:137.0/255 alpha:1.0] forState:UIControlStateNormal]; customButton.layer.borderColor = [UIColor colorWithRed:66.0/255 green:175.0/255 blue:137.0/255 alpha:1.0].CGColor; break; case 1: [customButton setTitleColor:[UIColor colorWithRed:110.0/255 green:193.0/255 blue:209.0/255 alpha:1.0] forState:UIControlStateNormal]; customButton.layer.borderColor = [UIColor colorWithRed:110.0/255 green:193.0/255 blue:209.0/255 alpha:1.0].CGColor; break; case 2: [customButton setTitleColor:[UIColor colorWithRed:223.0/255 green:162.0/255 blue:42.0/255 alpha:1.0] forState:UIControlStateNormal]; customButton.layer.borderColor = [UIColor colorWithRed:223.0/255 green:162.0/255 blue:42.0/255 alpha:1.0].CGColor; break; default: [customButton setTitleColor:[UIColor colorWithRed:209.0/255 green:33.0/255 blue:96.0/255 alpha:1.0] forState:UIControlStateNormal]; customButton.layer.borderColor = [UIColor colorWithRed:209.0/255 green:33.0/255 blue:96.0/255 alpha:1.0].CGColor; break; &#125; return customButton;&#125; 效果图： 你可以说这样写很丑但是你不可以说我审美有问题……我又不是设计师我怎么知道怎么配色好看🌚🌚🌚]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Category]]></title>
    <url>%2F2016%2F03%2F24%2FCategory%2F</url>
    <content type="text"><![CDATA[开发的时候，如果我们想往一个已经存在的并且很复杂的类里面添加一个方法怎么办呢？翻源码加？源码已经那么复杂了，如果不断往里面添加，代码将变得不可维护。。。那就创建子类喽！问题是，那么多子类，谁会记得调用哪个类的哪个方法……就算你征服了如此复杂的代码，系统顺利跑起来了，一段时间后接手维护代码的人肯定要问候你全家千万遍。 所以，苹果给出了解决这一问题的方法–Category。 Category 是一种往已经存在的类里面添加新函数的方法。对于被扩展的类我们不需要访问他的源码，也不需要创建子类。 这里一般使用约定俗成的习惯，将声明文件和实现文件统一采用 原类名+Category名 的方式命名。使用也非常简单，引入Category的声明文件，然后正常调用即可。 创建Category的方法： New file -&gt; Objective-C File -&gt; (file type -&gt; Category, subclass -&gt; NSXXXX, name -&gt; ……) -&gt; Create~就可以了 举个例子比如，开发中我们经常用到NSUserDefault。每次使用我们都要这样： 1[[NSUserDefaults standardUserDefaults] setValue:status forKey:@"userId"]; 很麻烦，而且不同地方使用如果把key写错了会得不到正确的值，改正这种Debug需要极高的想象力。 但是我们可以用Category解决这个问题： 创建一个NSUserDefault的Category,然后在里面写上一些常用的set和get方法，使用的时候就可以轻易的得到或者设置想要的值，不必担心key值写错。 比如： 123456789101112// NSUserDefaults+CCUserDefaults.h#import &lt;Foundation/Foundation.h&gt;@interface NSUserDefaults (CCUserDefaults)+(void)setUserPassword:(NSString *)password;+(NSString *)userPassword;+(void)setUserAccount:(NSString *)account;+(NSString *)userAccount;@end 123456789101112131415161718192021222324// NSUserDefaults+CCUserDefaults.m#import "NSUserDefaults+CCUserDefaults.h"static NSString * const userPassword = @"password";static NSString * const userAccount = @"account";@implementation NSUserDefaults (CCUserDefaults)+(void)setUserPassword:(NSString *)password &#123; [[NSUserDefaults standardUserDefaults] setValue:password forKey:userPassword];&#125;+(NSString *)userPassword &#123; return [[NSUserDefaults standardUserDefaults] stringForKey:userPassword];&#125;+(void)setUserAccount:(NSString *)account &#123; [[NSUserDefaults standardUserDefaults] setValue:account forKey:userAccount];&#125;+(NSString *)userAccount &#123; return [[NSUserDefaults standardUserDefaults] stringForKey:userAccount];&#125;@end 使用的时候直接使用就可以，方便了很多： 123456//某个controller#import "NSUserDefaults+CCUserDefaults.h"[NSUserDefaults setUserPassword:self.password];[NSUserDefaults setUserAccount:self.account]; 貌似这个例子有点抠脚……]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[winform设置splitContainer固定大小]]></title>
    <url>%2F2016%2F03%2F20%2Fwinform%E8%AE%BE%E7%BD%AEsplitContainer%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[比如，要设置左边的pannel固定大小： 12this.splitContainer1.IsSplitterFixed = false;this.splitContainer1.FixedPanel = FixedPanel.Panel1; 其中 1this.splitContainer1.IsSplitterFixed = false; 用来设置splitContainer1的大小是否可以改变 IsSplitterFixed获取或设置一个值，用以指示拆分器是固定的还是可移动的。如果为false就可以改变，true不可以改变。 究竟为什么我来趟.NET这个坑，明明js写桌面端那么容易]]></content>
      <tags>
        <tag>C＃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS接入微信支付]]></title>
    <url>%2F2016%2F03%2F20%2FiOS%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[iOS接入微信支付微信支付SDK比支付宝的SDK好了不知道多少倍，坑也少了好多，简直是支付类SDK中的良心之作！！ iOS接入支付宝SDK传送门 准备首先要去微信申请一个账号，分别有商户API密钥和商户号 https://open.weixin.qq.com/ 下载SDK目前微信SDK已经升级到了（1.6.2）。但是我现在用的是上一个版本SDK，这里有下载 为什么不用最新的呢？因为最新的SDK里面要求签名加密等操作在服务器上完成然后返回给手机端，然而……额，我这个项目的后台比较菜，不知道签名是怎么回事。而我比他更菜，我懒得自己写md5加密，所以就用了老版本的SDK。老版本SDK自带了各种各样加密方法，网上教程也比较多，所以很容易集成。 当然，微信这么做也是有原因的，你把私钥放到了每一台手机上用来做签名……这样跟泄露了私钥有什么区别～ 运行DEMOSDKSample下的demo跑一遍，没有什么问题，没有支付宝那么坑～～ lib文件夹下payRequsestHandler.h文件中填上APP_ID、APP_SECRET、MCH_ID、PARTNER_ID的值，然后运行demo，试一下能否完成支付，如果可以就可以进行下一步接入工作了。 接入将SDKExport下的libWeChatSDK.a、WXApi.h、WXApiObject.h三个文件拖入工程中，再把lib文件夹拖入工程中。。可能会有报错，ApiXml.m中报错那两行注释掉就好 支付代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// WechatPayManager.h#import &lt;Foundation/Foundation.h&gt;#import "WXApiObject.h"#import "WXApi.h"// 账号帐户资料// 更改商户把相关参数后可测试#define APP_ID @"XXX" //APPID#define APP_SECRET @"XXX" //appsecret,看起来好像没用//商户号，填写商户对应参数#define MCH_ID @"XXX"//商户API密钥，填写相应参数#define PARTNER_ID @"XXX"//支付结果回调页面#define NOTIFY_URL @"http://wxpay.weixin.qq.com/pub_v2/pay/notify.v2.php"#define SP_URL @"http://wxpay.weixin.qq.com/pub_v2/app/app_pay.php"@interface WechatPayManager : NSObject&#123;&#125;//预支付网关url地址@property (nonatomic,strong) NSString* payUrl;//debug信息@property (nonatomic,strong) NSMutableString *debugInfo;@property (nonatomic,assign) NSInteger lastErrCode;//返回的错误码//商户关键信息@property (nonatomic,strong) NSString *appId,*mchId,*spKey;//初始化函数-(id)initWithAppID:(NSString*)appID mchID:(NSString*)mchID spKey:(NSString*)key;//获取当前的debug信息-(NSString *) getDebugInfo;//获取预支付订单信息（核心是一个prepayID）- (NSMutableDictionary*)getPrepayWithOrderName:(NSString*)name price:(NSString*)price device:(NSString*)device;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216// WechatPayManager.m#import "WechatPayManager.h"#import "WXUtil.h"#import "ApiXml.h"@implementation WechatPayManager//初始化函数-(id)initWithAppID:(NSString*)appID mchID:(NSString*)mchID spKey:(NSString*)key&#123; self = [super init]; if(self) &#123; //初始化私有参数，主要是一些和商户有关的参数 self.payUrl = @"https://api.mch.weixin.qq.com/pay/unifiedorder"; if (self.debugInfo == nil)&#123; self.debugInfo = [NSMutableString string]; &#125; [self.debugInfo setString:@""]; self.appId = appID;//微信分配给商户的appID self.mchId = mchID;// self.spKey = key;//商户的密钥 &#125; return self;&#125;//获取debug信息-(NSString*) getDebugInfo&#123; NSString *res = [NSString stringWithString:self.debugInfo]; [self.debugInfo setString:@""]; return res;&#125;//创建package签名-(NSString*) createMd5Sign:(NSMutableDictionary*)dict&#123; NSMutableString *contentString =[NSMutableString string]; NSArray *keys = [dict allKeys]; //按字母顺序排序 NSArray *sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1 compare:obj2 options:NSNumericSearch]; &#125;]; //拼接字符串 for (NSString *categoryId in sortedArray) &#123; if ( ![[dict objectForKey:categoryId] isEqualToString:@""] &amp;&amp; ![categoryId isEqualToString:@"sign"] &amp;&amp; ![categoryId isEqualToString:@"key"] ) &#123; [contentString appendFormat:@"%@=%@&amp;", categoryId, [dict objectForKey:categoryId]]; &#125; &#125; //添加key字段 [contentString appendFormat:@"key=%@", self.spKey]; //得到MD5 sign签名 NSString *md5Sign =[WXUtil md5:contentString]; //输出Debug Info [self.debugInfo appendFormat:@"MD5签名字符串：\n%@\n\n",contentString]; return md5Sign;&#125;//获取package带参数的签名包-(NSString *)genPackage:(NSMutableDictionary*)packageParams&#123; NSString *sign; NSMutableString *reqPars=[NSMutableString string]; //生成签名 sign = [self createMd5Sign:packageParams]; //生成xml的package NSArray *keys = [packageParams allKeys]; [reqPars appendString:@"&lt;xml&gt;\n"]; for (NSString *categoryId in keys) &#123; [reqPars appendFormat:@"&lt;%@&gt;%@&lt;/%@&gt;\n", categoryId, [packageParams objectForKey:categoryId],categoryId]; &#125; [reqPars appendFormat:@"&lt;sign&gt;%@&lt;/sign&gt;\n&lt;/xml&gt;", sign]; return [NSString stringWithString:reqPars];&#125;//提交预支付-(NSString *)sendPrepay:(NSMutableDictionary *)prePayParams&#123; NSString *prepayid = nil; //获取提交支付 NSString *send = [self genPackage:prePayParams]; //输出Debug Info [self.debugInfo appendFormat:@"API链接:%@\n", self.payUrl]; [self.debugInfo appendFormat:@"发送的xml:%@\n", send]; //发送请求post xml数据 NSData *res = [WXUtil httpSend:self.payUrl method:@"POST" data:send]; //输出Debug Info [self.debugInfo appendFormat:@"服务器返回：\n%@\n\n",[[NSString alloc] initWithData:res encoding:NSUTF8StringEncoding]]; XMLHelper *xml = [[XMLHelper alloc] init]; //开始解析 [xml startParse:res]; NSMutableDictionary *resParams = [xml getDict]; //判断返回 NSString *return_code = [resParams objectForKey:@"return_code"]; NSString *result_code = [resParams objectForKey:@"result_code"]; if ( [return_code isEqualToString:@"SUCCESS"] ) &#123; //生成返回数据的签名 NSString *sign = [self createMd5Sign:resParams ]; NSString *send_sign =[resParams objectForKey:@"sign"] ; //验证签名正确性 if( [sign isEqualToString:send_sign])&#123; if( [result_code isEqualToString:@"SUCCESS"]) &#123; //验证业务处理状态 prepayid = [resParams objectForKey:@"prepay_id"]; return_code = 0; [self.debugInfo appendFormat:@"获取预支付交易标示成功！\n"]; &#125; &#125;else&#123; self.lastErrCode = 1; [self.debugInfo appendFormat:@"gen_sign=%@\n _sign=%@\n",sign,send_sign]; [self.debugInfo appendFormat:@"服务器返回签名验证错误！！！\n"]; &#125; &#125;else&#123; self.lastErrCode = 2; [self.debugInfo appendFormat:@"接口返回错误！！！\n"]; &#125; return prepayid;&#125;- (NSMutableDictionary*)getPrepayWithOrderName:(NSString*)name price:(NSString*)price device:(NSString*)device&#123; //订单标题，展示给用户 NSString* orderName = name; //订单金额,单位（分） NSString* orderPrice = price;//以分为单位的整数 //支付设备号或门店号 NSString* orderDevice = device; //支付类型，固定为APP NSString* orderType = @"APP"; //发器支付的机器ip,暂时没有发现其作用 NSString* orderIP = @"196.168.1.1"; //随机数串 srand( (unsigned)time(0) ); NSString *noncestr = [NSString stringWithFormat:@"%d", rand()]; NSString *orderNO = [NSString stringWithFormat:@"%ld",time(0)]; //================================ //预付单参数订单设置 //================================ NSMutableDictionary *packageParams = [NSMutableDictionary dictionary]; [packageParams setObject: self.appId forKey:@"appid"]; //开放平台appid [packageParams setObject: self.mchId forKey:@"mch_id"]; //商户号 [packageParams setObject: orderDevice forKey:@"device_info"]; //支付设备号或门店号 [packageParams setObject: noncestr forKey:@"nonce_str"]; //随机串 [packageParams setObject: orderType forKey:@"trade_type"]; //支付类型，固定为APP [packageParams setObject: orderName forKey:@"body"]; //订单描述，展示给用户 [packageParams setObject: NOTIFY_URL forKey:@"notify_url"]; //支付结果异步通知 [packageParams setObject: orderNO forKey:@"out_trade_no"];//商户订单号 [packageParams setObject: orderIP forKey:@"spbill_create_ip"];//发器支付的机器ip [packageParams setObject: orderPrice forKey:@"total_fee"]; //订单金额，单位为分 //获取prepayId（预支付交易会话标识） NSString *prePayid; prePayid = [self sendPrepay:packageParams]; if(prePayid == nil) &#123; [self.debugInfo appendFormat:@"获取prepayid失败！\n"]; return nil; &#125; //获取到prepayid后进行第二次签名 NSString *package, *time_stamp, *nonce_str; //设置支付参数 time_t now; time(&amp;now); time_stamp = [NSString stringWithFormat:@"%ld", now]; nonce_str = [WXUtil md5:time_stamp]; //重新按提交格式组包，微信客户端暂只支持package=Sign=WXPay格式，须考虑升级后支持携带package具体参数的情况 //package = [NSString stringWithFormat:@"Sign=%@",package]; package = @"Sign=WXPay"; //第二次签名参数列表 NSMutableDictionary *signParams = [NSMutableDictionary dictionary]; [signParams setObject: self.appId forKey:@"appid"]; [signParams setObject: self.mchId forKey:@"partnerid"]; [signParams setObject: nonce_str forKey:@"noncestr"]; [signParams setObject: package forKey:@"package"]; [signParams setObject: time_stamp forKey:@"timestamp"]; [signParams setObject: prePayid forKey:@"prepayid"]; //生成签名 NSString *sign = [self createMd5Sign:signParams]; //添加签名 [signParams setObject: sign forKey:@"sign"]; [self.debugInfo appendFormat:@"第二步签名成功，sign＝%@\n",sign]; //返回参数列表 return signParams;&#125;@end 支付函数调用这个函数即可完成支付～ 12345678910111213141516171819202122232425262728293031323334353637- (void)wxPayWithOrderName:(NSString*)name price:(NSString*)price&#123; //创建支付签名对象 &amp;&amp; 初始化支付签名对象 WechatPayManager* wxpayManager = [[WechatPayManager alloc]initWithAppID:APP_ID mchID:MCH_ID spKey:PARTNER_ID]; //获取到实际调起微信支付的参数后，在app端调起支付 //生成预支付订单，实际上就是把关键参数进行第一次加密。 NSString* device = @"aaaaaa";//[[ defaultManager]userId]; NSMutableDictionary *dict = [wxpayManager getPrepayWithOrderName:name price:price device:device]; if(dict == nil)&#123; //错误提示 NSString *debug = [wxpayManager getDebugInfo]; NSLog(@"%@",debug); return; &#125; NSMutableString *stamp = [dict objectForKey:@"timestamp"]; //调起微信支付 PayReq* req = [[PayReq alloc] init]; req.openID = [dict objectForKey:@"appid"]; req.partnerId = [dict objectForKey:@"partnerid"]; req.prepayId = [dict objectForKey:@"prepayid"]; req.nonceStr = [dict objectForKey:@"noncestr"]; req.timeStamp = stamp.intValue; req.package = [dict objectForKey:@"package"]; req.sign = [dict objectForKey:@"sign"]; BOOL flag = [WXApi sendReq:req]; if (!flag) &#123; NSLog(@"ERROR!"); &#125;&#125; 可能遇到的问题“OBJC_CLASS$_CTTelephonyNetworkInfo” 报错 “Undefined symbols for architecture armv7:”报错 在General-&gt;Linked Frameworks and Libraries中加入以下Libraries: 写的比较仓促，如果发现什么问题请留言，我一定会回复的～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UINavigationController背景图片在iPad或者iPhone6＋上位置不正确]]></title>
    <url>%2F2016%2F03%2F09%2FUINavigationController%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E5%9C%A8iPad%E6%88%96%E8%80%85iPhone6%EF%BC%8B%E4%B8%8A%E4%BD%8D%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE%2F</url>
    <content type="text"><![CDATA[之前调用了方法： 1[self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@"image_nav_bar"] forBarMetrics:UIBarMetricsDefault]; 后布局在iPhone 6 plus上看会变成这样 为了防止这种情况出现应该讲图片做一个拉伸，所以这个方法应该写错这样： 1[self.navigationController.navigationBar setBackgroundImage:[[UIImage imageNamed:@"image_nav_bar"] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0) resizingMode:UIImageResizingModeStretch] forBarMetrics:UIBarMetricsDefault]; 现在背景图片就可以正常显示了～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NavigationBar，NavigationController无法显示title]]></title>
    <url>%2F2016%2F03%2F09%2FNavigationBar%EF%BC%8CNavigationController%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAtitle%2F</url>
    <content type="text"><![CDATA[做项目的时候发现在一个界面里面，设置 self.title = @”XXX”, 但是项目运行的时候发现并没有显示内容。这个问题困扰了我好久。。。直到今天 我用谷歌搜了一下，点开了第一条，找到了解决办法： 调用这一条函数即可： 1[self.navigationController.navigationBar.topItem setTitle:@"XXX"]; 为什么我要一直用百度查呢？我什么我就不突发奇想尝试下谷歌呢？这样问题早就解决了……我真是菜的抠脚]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消除Cocoapods中的警告]]></title>
    <url>%2F2016%2F02%2F26%2F%E6%B6%88%E9%99%A4Cocoapods%E4%B8%AD%E7%9A%84%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[我们在使用CocoaPods的时候经常会发现一些pod会出现一些警告，这时在 Podfile中加入一句inhibit_all_warnings!就可以消除这些pod中的警告。强迫症专用啊！！ 当然，我是无所谓，对于我这种低等级程序猿来说，只要程序能运行就好了～ 比如 加了之后重新pod install就没有了]]></content>
      <tags>
        <tag>IOS</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何根据文字的多少动态的调整TableViewCell的高度]]></title>
    <url>%2F2016%2F01%2F25%2F%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E6%96%87%E5%AD%97%E7%9A%84%E5%A4%9A%E5%B0%91%E5%8A%A8%E6%80%81%E7%9A%84%E8%B0%83%E6%95%B4TableViewCell%E7%9A%84%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[开发中经常会遇到需要动态调整UITableViewCell的高度的问题，这个问题百度到的十分不清楚，但是谷歌到的就十分清楚，在百度没完之前我还是自己还是记录下吧…… 方法一：使用AutoLayout在storyboard中设置label的约束如图所示： 或者: 然后在viewDidLoad中添加 12self.tableView.rowHeight = UITableViewAutomaticDimension;self.tableView.estimatedRowHeight = 44; tableView需要设置为Dynamic Prototypes，上图的约束一条都不能少！！ 方法二：调用heightForRowAtIndexPath12345678910111213141516171819202122232425262728293031#define ScreenFrame [[UIScreen mainScreen]bounds]#define ScreenSize ScreenFrame.size#define FONT_SIZE 15.0f#define CELL_CONTENT_WIDTH ScreenSize.width //CELL_CONTENT_WIDTH 为cell的宽度#define CELL_CONTENT_MARGIN 8.0f //CELL_CONTENT_MARGIN为label距cell两边的宽度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;// 获取当前indexPath下的cell的那个lable的内容 NSDictionary *rowData = _dataArray[indexPath.section]; text = [rowData objectForKey:@"content"]; //CELL_CONTENT_WIDTH 为cell的宽度；CELL_CONTENT_MARGIN为label距cell两边的宽度，相减得到label长度～；后面的20000任意设置 CGSize constraint = CGSizeMake(CELL_CONTENT_WIDTH - (CELL_CONTENT_MARGIN * 2), 20000.0f); //CGSize size = [text sizeWithFont:[UIFont systemFontOfSize:FONT_SIZE] constrainedToSize:constraint lineBreakMode:UILineBreakModeWordWrap]; NSAttributedString *attributedText = [[NSAttributedString alloc]initWithString:text attributes:@&#123; NSFontAttributeName:[UIFont systemFontOfSize:FONT_SIZE] &#125;]; CGRect rect = [attributedText boundingRectWithSize:constraint options:NSStringDrawingUsesLineFragmentOrigin context:nil]; CGSize size = rect.size; CGFloat height = MAX(size.height + 82, 100.0f); return height; &#125; 然后运行，就可以啦 百度药丸～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何添加PCH文件]]></title>
    <url>%2F2016%2F01%2F21%2F%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0PCH%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[PCH，pre-Compile Header（预编译头文件）,由编译器在建立工程时自动生成; 其中存放有工程中已经编译的部分代码; 在以后建立工程时不再重新编译这些代码。以前每个项目中会自动生成，但是这个东西被在Xcode6中被取消了，为了加快编译速度。如何在之后的项目中手动加入这个文件呢？ Xcode7中，点击new file。选中iOS-&gt;other-&gt;PCH File，创建一个新的PCH文件。 然后在Build Setting-&gt;Apple LLVM 7.0 -Language-&gt;Prefix Header中添加PCH文件的文件路径，如图 这样PCH文件就可以正常使用了，可以吧常用的头文件都写在PCH文件里面，避免每个头文件都要import一遍～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS接入支付宝]]></title>
    <url>%2F2016%2F01%2F03%2FiOS%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%2F</url>
    <content type="text"><![CDATA[记得我做的第一个iOS应用就有接入支付宝的功能，然而当时并没有成功接入。一个是因为当时自己大三刚刚开窍菜的抠脚，另一个是因为网上传闻iOS添加支付宝的SDK难用程度已经突破了天际！所以就自动放弃了～ 但是！！我终于在一年后的今天给它弄上了！！现在返回去看其实也不难，虽然坑很多 引用《火星救援》马克说的话： You just begin.You do the math. You solve one problemand you solve the next one,and then the next.And if you solve enough problems, you get to come home. 遇到困难去做就是了，可能有成堆的问题，但是一个问题一个问题的去解决，只要解决的问题足够多，这个困难就过去了。同样，一个你不熟悉的框架或者系统，一开始自己会感到手足无措，完全不知道该怎么办，这时候只需要每天学一个技术，每天看一点文档，慢慢的就会了，然后就熟悉了，最后就可以在别人崇拜的眼光面前摇摇头说：“我也只是略懂啦～”。 准备首先要去支付宝填申请，可以得到一个parnter和一个seller。然后自己要在自己的电脑上生成一组RSA，把公钥交给支付宝，私钥自己留着。具体生成方法支付宝的SDK里面有写，或者可以看这个openssl生成RSA公私钥，两分钟的事。 下载SDK首先要从网上下载SDK。下载地址 运行 demo得到SDK后先运行下他给的iOS端的demo。demo中APViewController.m里面找到下面这几行代码，填上你的parnter、seller和privateKey，然后运行看下能不能支付成功，如果可以的话，说明你的三个参数没有问题，可以准备接入了 1234567891011121314/* *商户的唯一的parnter和seller。 *签约后，支付宝会为每个商户分配一个唯一的 parnter 和 seller。 */ /*============================================================================*//*=======================需要填写商户app申请的===================================*//*============================================================================*/ NSString *partner = @""; NSString *seller = @""; NSString *privateKey = @"";/*============================================================================*//*============================================================================*//*============================================================================*/ 接入首先把SDK包中的几个东西拖到你的项目中去：AlipaySDK.bundle,AlipaySDK.framework,libcrypto.a和libssl.a。 然后把demo中Util文件夹拖入你的项目中：注意！要选择Create groups！！！注意！要选择Create groups！！！注意！要选择Create groups！！！ Util拖进去后应该是黄色的而不是蓝色的！！！ 然后把demo中openssl文件夹拖入你的项目中： 注意这次选Create folder reference！！ 然后把demo中这几个文件拖到你的项目中：Product.h,Product.m,APAuthV2Info.h,APAuthV2Info.m,Order.h,Order.m 现在你的项目里面应该包含这些东西（特别注意下Util文件夹和openssl文件夹的颜色）： 在你要用到支付的地方引入以下头文件 1234#import "Order.h"#import &lt;AlipaySDK/AlipaySDK.h&gt;#import "DataSigner.h"#import "Product.h" 然后参考demo的支付写了下面这个支付函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104- (void)Alipay&#123; /* *点击获取prodcut实例并初始化订单信息 */ // Product *product = [self.productList objectAtIndex:indexPath.row]; Product *product = [[Product alloc] init]; product.subject = @"1"; product.body = @"人在塔在"; product.price = 0.01f+pow(10,-2); /* *商户的唯一的parnter和seller。 *签约后，支付宝会为每个商户分配一个唯一的 parnter 和 seller。 */ /*============================================================================*/ /*=======================需要填写商户app申请的===================================*/ /*============================================================================*/ NSString *partner = @""; NSString *seller = @""; NSString *privateKey = @“私钥”; /*============================================================================*/ /*============================================================================*/ /*============================================================================*/ //partner和seller获取失败,提示 if ([partner length] == 0 || [seller length] == 0 || [privateKey length] == 0) &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"提示" message:@"缺少partner或者seller或者私钥。" delegate:self cancelButtonTitle:@"确定" otherButtonTitles:nil]; [alert show]; &#125; /* *生成订单信息及签名 */ product.price = 0.01f+pow(10,-2);//商品价格 //将商品信息赋予AlixPayOrder的成员变量 Order *order = [[Order alloc] init]; order.partner = partner; order.seller = seller; order.tradeNO = [self generateTradeNO]; //订单ID（由商家自行制定） order.productName = product.subject; //商品标题 order.productDescription = product.body; //商品描述 order.amount = [NSString stringWithFormat:@"%.2f",product.price]; // order.notifyURL = @"http://www.xxx.com"; //回调URL order.service = @"mobile.securitypay.pay"; order.paymentType = @"1"; order.inputCharset = @"utf-8"; order.itBPay = @"30m"; order.showUrl = @"m.alipay.com"; //应用注册scheme,在AlixPayDemo-Info.plist定义URL types NSString *appScheme = @"alisdkdemo"; //将商品信息拼接成字符串 NSString *orderSpec = [order description]; NSLog(@"orderSpec = %@",orderSpec); //获取私钥并将商户信息签名,外部商户可以根据情况存放私钥和签名,只需要遵循RSA签名规范,并将签名字符串base64编码和UrlEncode id&lt;DataSigner&gt; signer = CreateRSADataSigner(privateKey); NSString *signedString = [signer signString:orderSpec]; //将签名成功字符串格式化为订单字符串,请严格按照该格式 NSString *orderString = nil; if (signedString != nil) &#123; orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"", orderSpec, signedString, @"RSA"]; //回调会调用这个函数 [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) &#123; NSLog(@"reslut = %@",resultDic); &#125;]; // [tableView deselectRowAtIndexPath:indexPath animated:YES]; &#125;&#125;- (NSString *)generateTradeNO&#123; static int kNumber = 15; NSString *sourceStr = @"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; NSMutableString *resultStr = [[NSMutableString alloc] init]; srand(time(0)); for (int i = 0; i &lt; kNumber; i++) &#123; unsigned index = rand() % [sourceStr length]; NSString *oneStr = [sourceStr substringWithRange:NSMakeRange(index, 1)]; [resultStr appendString:oneStr]; &#125; return resultStr;&#125; 按照官方的说法，这样子就差不多算是把支付宝接入了；现在点击运行。。。。会惊奇的发现：Boom! sha ka la ka!! 报了超多错！这就是支付宝坑的地方，接下来我们来填坑。 填坑Util/base64.h:63:21: Cannot find interface declaration for ‘NSObject’, superclass of ‘Base64’在base64.h中加入#import &lt;Foundation/Foundation.h&gt; 官方古老的demo加到了PCH中，所以不会报错～结果他说都不说一声！！！坑啊有没有！！！ Util/openssl_wrapper.m:11:9: ‘rsa.h’ file not found 在Build setting中搜索search，找到Header Search Paths，添加$(PROJECT_DIR)/openssl和$(PROJECT_DIR) 如图： “_CNCopyCurrentNetworkInfo”, referenced from:这类错很多，大概有这些： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Undefined symbols for architecture x86_64: "_CNCopyCurrentNetworkInfo", referenced from: -[APayReachability wifiInterface] in AlipaySDK +[internal_DeviceInfo getSSIDInfo] in AlipaySDK +[internal_DeviceInfo getNetworkInfo] in AlipaySDK "_CNCopySupportedInterfaces", referenced from: -[APayReachability wifiInterface] in AlipaySDK +[internal_DeviceInfo getSSIDInfo] in AlipaySDK +[internal_DeviceInfo getNetworkInfo] in AlipaySDK "_CTRadioAccessTechnologyCDMA1x", referenced from: -[AliSecXReachability networkStatusForFlags:] in AlipaySDK "_CTRadioAccessTechnologyEdge", referenced from: -[AliSecXReachability networkStatusForFlags:] in AlipaySDK "_CTRadioAccessTechnologyGPRS", referenced from: -[AliSecXReachability networkStatusForFlags:] in AlipaySDK "_CTRadioAccessTechnologyLTE", referenced from: -[AliSecXReachability networkStatusForFlags:] in AlipaySDK "_OBJC_CLASS_$_CMMotionManager", referenced from: objc-class-ref in AlipaySDK "_OBJC_CLASS_$_CTTelephonyNetworkInfo", referenced from: objc-class-ref in AlipaySDK "_SCNetworkReachabilityCreateWithAddress", referenced from: +[APayReachability reachabilityWithAddress:] in AlipaySDK +[AliSecXReachability reachabilityWithAddress:] in AlipaySDK "_SCNetworkReachabilityCreateWithName", referenced from: +[APayReachability reachabilityWithHostname:] in AlipaySDK +[AliSecXReachability reachabilityWithHostName:] in AlipaySDK "_SCNetworkReachabilityGetFlags", referenced from: -[APayReachability isReachable] in AlipaySDK -[APayReachability isReachableViaWWAN] in AlipaySDK -[APayReachability isReachableViaWiFi] in AlipaySDK -[APayReachability connectionRequired] in AlipaySDK -[APayReachability isConnectionOnDemand] in AlipaySDK -[APayReachability isInterventionRequired] in AlipaySDK -[APayReachability reachabilityFlags] in AlipaySDK ... "_SCNetworkReachabilityScheduleWithRunLoop", referenced from: -[AliSecXReachability startNotifier] in AlipaySDK "_SCNetworkReachabilitySetCallback", referenced from: -[APayReachability startNotifier] in AlipaySDK -[APayReachability stopNotifier] in AlipaySDK -[AliSecXReachability startNotifier] in AlipaySDK "_SCNetworkReachabilitySetDispatchQueue", referenced from: -[APayReachability startNotifier] in AlipaySDK -[APayReachability stopNotifier] in AlipaySDK "_SCNetworkReachabilityUnscheduleFromRunLoop", referenced from: -[AliSecXReachability stopNotifier] in AlipaySDK "std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::__init(char const*, unsigned long)", referenced from: CAliSecXURL::encodeURIComponent(CAliSecXBuffer&amp;) in AlipaySDK "std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::reserve(unsigned long)", referenced from: CAliSecXURL::encodeURIComponent(CAliSecXBuffer&amp;) in AlipaySDK "std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::~basic_string()", referenced from: CAliSecXURL::encodeURIComponent(CAliSecXBuffer&amp;) in AlipaySDK "std::nothrow", referenced from: CAliSecXBuffer::CAliSecXBuffer(unsigned long) in AlipaySDK CAliSecXBuffer::_copy(unsigned char const*, unsigned long) in AlipaySDK CAliSecXBuffer::resize(unsigned long) in AlipaySDK "std::terminate()", referenced from: ___clang_call_terminate in AlipaySDK "operator delete[](void*)", referenced from: CAliSecXBuffer::~CAliSecXBuffer() in AlipaySDK CAliSecXBuffer::release() in AlipaySDK CAliSecXBuffer::~CAliSecXBuffer() in AlipaySDK CAliSecXBuffer::operator=(CAliSecXBuffer const&amp;) in AlipaySDK CAliSecXBuffer::resize(unsigned long) in AlipaySDK alisec_crypto_Hex2Bin(CAliSecXBuffer const&amp;) in AlipaySDK alisec_crypto_Bin2Hex(CAliSecXBuffer const&amp;) in AlipaySDK ... "operator new[](unsigned long, std::nothrow_t const&amp;)", referenced from: CAliSecXBuffer::CAliSecXBuffer(unsigned long) in AlipaySDK CAliSecXBuffer::_copy(unsigned char const*, unsigned long) in AlipaySDK CAliSecXBuffer::resize(unsigned long) in AlipaySDK "___cxa_begin_catch", referenced from: ___clang_call_terminate in AlipaySDK "___gxx_personality_v0", referenced from: +[ASSStorageAccesser saveStorageModel:] in AlipaySDK +[ASSStorageAccesser loadStorageModelFromKeychain] in AlipaySDK +[ASSStorageAccesser loadPreviousApdid] in AlipaySDK +[ASSStorageAccesser getRandomizedID] in AlipaySDK +[ASSStorageAccesser getNewRadomizedID] in AlipaySDK +[ASSStorageAccesser loadLastLoginTime] in AlipaySDK +[ASSStorageAccesser saveCurrentLoginTime:] in AlipaySDK ... "_deflate", referenced from: +[ASSCommonUtils gzipData:] in AlipaySDK +[DTGZipUtil compressGZip:] in AlipaySDK "_deflateEnd", referenced from: +[ASSCommonUtils gzipData:] in AlipaySDK +[DTGZipUtil compressGZip:] in AlipaySDK "_deflateInit2_", referenced from: +[ASSCommonUtils gzipData:] in AlipaySDK +[DTGZipUtil compressGZip:] in AlipaySDK "_kCNNetworkInfoKeyBSSID", referenced from: +[UIDevice(APEX) networkDic] in AlipaySDK "_kCNNetworkInfoKeySSID", referenced from: +[UIDevice(APEX) networkDic] in AlipaySDKld: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 这种问题通过在General-&gt;Link Framework and Libraiies中添加以下framework解决： libz.tbd libc++.tbd Security.framework CoreMotion.Framework CFNetwork.framework CoreTelephony.framework SystemConfiguration.framework 如图： 强迫症可以挪下位置～～ 现在运行，应该就可以了，别的问题我好像也没有遇到～（记得联网！！！！） 交易订单处理失败，请稍候再试。（ALI64）我出现这个问题是因为product.body放了空值，这里不能为空～ 补充下，支付完成的回调需要在AppDelegate.h中的-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation;函数中调用： 12345678if ([url.host isEqualToString:@"safepay"]) &#123; [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123; //这个部分绝对不会运行，不用在这里浪费时间了～ &#125;]; return YES; &#125; 来处理回调，不然应用无法知道有没有支付成功。返回9000代表支付成功。 注意仔细查看本文中Alipay函数的最后几行，在那个地方有个[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback……函数，在这个函数中处理回调的结果！！ AppDelegate.h里面的standbyCallback:\^(NSDictionary \*resultDic) {}];是不会有回调结果的!!!]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过IPV6访问网络]]></title>
    <url>%2F2015%2F12%2F29%2F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87IPV6%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[现在网络用的大多都是ipv4，ipv6还没有普及。但是大多数高等院校（比如我们华南皇家理工学院）已经普及了ipv6，所以通过ipv6翻墙是可以实现的。 当然这个方法也可以做一些别的事情，比如晚上网络突然不能用了…… 各位同学的电脑一定要插网线，路由器是不可以的，大部分路由器是没法设置ipv6的！！！各位同学的电脑一定要插网线!!各位同学的电脑一定要插网线!! windows 7 系统 打开电脑右下角的打开网络和共享中心 点击更改适配器设置 在弹出的页面右键选中本地连接，然后左键点属性。 选中Internet 协议版本6后点击属性（注意要选中后才可以点击） 页面靠上边选择自动获取ipv6地址，下边选使用下面的 DNS 服务器，然后填入服务器地址：2001:778::37。（注意冒号啊，不能多也不能少！ 打冒号的时候别用中文输入法！！！） 勾选退出时验证设置，等一会应该就可以了。通过访问 https://www.google.com 验证（https://www.google.com.hk 好像不可以～） Mac系统 打开电脑左上角的苹果图标，选择系统偏好设置。 选择网络 选择Apple USB Ethernet Adapter-&gt;高级 选择DNS-&gt;+添加一个ipv6 DNS地址：2001:778::37。 点击好-&gt;应用，这时候打开谷歌应该就可以了。通过访问 https://www.google.com 验证（https://www.google.com.hk 好像不可以～） 由于我自己的电脑是苹果电脑，我也不知道windows会有什么问题。至少我在舍友的电脑上试了是可以的，如果有什么问题可以在下边留言，我找时间看看。 DNS服务器列表（注意只能访问支持ipv6的网站，比如谷歌，百度不可以用）123456789101112131415161718192021222324科技网DNS服务器2001:cc0:2fff:2::6CNNIC DNS服务器2001:dc7:1000::1上海交通大学DNS服务器2001:da8:8000:1:202:120:2:1002001:da8:8000:1:202:120:2:101北京邮电大学DNS服务器2001:da8:202:10::362001:da8:202:10::37北京科技大学DNS服务器2001:da8:208:10::6 如果要访问ipv4资源如果要访问ipv4资源需要用到DNS64服务器，它可以将域名解析出ipv6的AAAA记录，然后使用ipv6去访问NAT64服务器，NAT64服务器访问ipv4的资源来返回所需要的结果。 当前Internet上公布的DNS64服务器： 1232001:778::372001:df8:0:7::1 上不了QQ是正常情况，我也不知道为什么，我要问下老师先~windows7可能会上不了，目前不知道为什么；windows10，windows8好像没问题如果不行尝试把ipv4 前面的勾去掉，ipv6的勾一定要钩上 尽量避免用Google chrome浏览器，这个东西不太稳定。是在上不去用IE或者Safari试试 另外评论里的那帮人，你们这样是找不到女朋友的！！！！ 很多学校用的是锐捷登陆系统，虽然我没用过，但是用过的人都说不好：一个是它会限制双网卡，导致笔记本电脑做不了热点；一个是晚上12点准时断网，想查点资料都查不了……这个方法好像也能绕过锐捷登陆系统，我没试过，北校的同学试了可以告诉我一声啊～～]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carthage和CocoaPods]]></title>
    <url>%2F2015%2F12%2F24%2FCarthage%E5%92%8CCocoaPods%2F</url>
    <content type="text"><![CDATA[Carthage CocoaPods Carthage和CocoaPods和都是主流的iOS包管理工具。其中CocoaPods比较主流，因为使用方便，开发者很容易就可以将一个第三方库集成到自己的项目里。 但是CocoaPods会改变项目结构， CocoaPods 会生成一个 Workspace，打开项目需要通过新建的Workspave，不然项目会报错。而Carthage就不会。 Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。 PS：Carthage和CocoaPods在同一个项目里面可以混用！！ CocoaPods安装 安装CocoaPods需要Ruby环境，Ruby是Mac OS X自带的，所以可以直接安装。 输入以下命令就可以安装： 1sudo gem install cocoapods 国内安装会卡住，因为链接被墙了。这时候可以用VPN或者淘宝Ruby镜像来访问。 按照下面的顺序在终端中敲入依次敲入命令： 1gem sources --remove https://rubygems.org/ 等有反应之后再敲入以下命令: 1gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：1$ gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： 123*** CURRENT SOURCES ***http://ruby.taobao.org/ 这时候再运行 1sudo gem install cocoapods 就可以了 使用 举个例子吧 比如你想安装 AFNetworking https://github.com/AFNetworking/AFNetworking 先在终端输入 1$ pod search AFNetworking 可以看到以下结果，说明可以用CocoaPods安装 AFNetworking 或者，可以直接去AFNetworking的Github页面上看，一般支持CocoaPods安装的项目作者都会写到README.md里面 在你需要用到的工厂目录下创建个新文件，文件名交PodFile。 在PodFile中加入 12platform :ios, '8.0'pod 'AFNetworking', '~&gt; 3.0' 然后在终端CD到项目目录下，输入 1$ pod install 这时候文件目录就会变成这样： 现在点击.xcworkspace 才可以正常打开项目。 CarthageCarthage的基本工作流： 创建一个Cartfile，包含你希望在项目中使用的框架的列表。 运行Carthage，将会获取列出的框架并编译它们。 将编译完成的.framework二进制文件拖拽到你的Xcode项目当中。 安装 Carthage提供OS X平台的pkg安装文件，你可以从Github的最新release中找到，按照引导一步步安装即可。 使用 假设项目中要加入AFNetworking 在项目目录下创建一个叫做Cartfile的文件 文件中写入 1github &quot;AFNetworking/AFNetworking&quot; ~&gt; 3.0 然后在控制台中CD到项目目录下，输入carthage update 然后文件目录就会变成这样： 在Carthage-&gt;Build-&gt;iOS找到AFNetworking.framework 将framwork拖入项目中就可以使用了。 参考资料http://www.open-open.com/lib/view/open1436886568084.htmlhttp://blog.csdn.net/iunion/article/details/17010267]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MBProgressHUD]]></title>
    <url>%2F2015%2F12%2F23%2FMBProgressHUD%2F</url>
    <content type="text"><![CDATA[https://github.com/jdg/MBProgressHUD MBProgressHUD 是目前Github上star最多的HUD，支持所有版本的iOS，但是不支持Mac。 效果图 安装Cocoapods 在Podfile里面添加 1pod 'MBProgressHUD', '~&gt; 0.9.2' 或者： Carthage 在Cartfile里面添加 1github "jdg/MBProgressHUD" ~&gt; 0.9.2 或者： Source files 直接把 MBProgressHUD.h和MBProgressHUD.m添加到工程中。 或者: Static library 把MBProgressHUD.xcodeproj拖到工程文件中，Libraries中添加libMBProgressHUD.a，再将MBProgressHUD添加到Target Dependencies list里面。 使用标准情况 1234567891011121314HUD = [[MBProgressHUD alloc] initWithView:self.navigationController.view]; [self.navigationController.view addSubview:HUD]; HUD.delegate = self; HUD.labelText = @"Loading"; HUD.detailsLabelText = @"updating data"; HUD.square = YES; [HUD showWhileExecuting:@selector(myTask) onTarget:self withObject:nil animated:YES];- (void)myTask &#123; // Do something usefull in here instead of sleeping ... sleep(3);&#125; 带进度条的情况 12345678910111213141516171819202122HUD = [[MBProgressHUD alloc] initWithView:self.navigationController.view]; [self.navigationController.view addSubview:HUD]; // Set determinate mode HUD.mode = MBProgressHUDModeAnnularDeterminate; HUD.delegate = self; HUD.labelText = @"Loading"; // myProgressTask uses the HUD instance to update progress [HUD showWhileExecuting:@selector(myProgressTask) onTarget:self withObject:nil animated:YES]; - (void)myProgressTask &#123; // This just increases the progress indicator in a loop float progress = 0.0f; while (progress &lt; 1.0f) &#123; progress += 0.01f; HUD.progress = progress; usleep(50000); &#125;&#125; 更详细的用法可以参考官方的DEMO]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaLumberjack]]></title>
    <url>%2F2015%2F12%2F23%2FCocoaLumberjack%2F</url>
    <content type="text"><![CDATA[https://github.com/CocoaLumberjack/CocoaLumberjack CocoaLumberjack是一款log框架，支持iOS和Mac。最大的好处就是可以把Log分成不同等级，方便调适，从此抛弃NSLog。 安装CocoaPods: 在Podfile中加上： Objective-C 12platform :ios, '7.0'pod 'CocoaLumberjack' Swift 123platform :ios, '8.0'pod 'CocoaLumberjack/Swift'use_frameworks! 或者： Carthage 在Cartfile中加上： 1github &quot;CocoaLumberjack/CocoaLumberjack&quot; 或者手动安装 好麻烦不想写了……官网上有😷😷😷。 大概意思就是把CocoaLumberjack/Lumberjack.xcodeproj拖到项目中，编译然后选自己项目对应的框架。 用法引入 1#import &lt;CocoaLumberjack/CocoaLumberjack.h&gt; Log分为以下几种，分别代表不同的等级 DDLogError DDLogWarn DDLogInfo DDLogDebug DDLogVerbose 严重度：DDLogError&gt;DDLogWarn&gt;DDLogInfo&gt;DDLogDebug&gt;DDLogVerbose 通过下面这个语句可以设置调适的时候在控制台输出哪个等级的Log： 12345678910111213static const DDLogLevel ddLogLevel = DDLogLevelDebug;``` `DDLog`语法跟`NSLog`语法一摸一样```objectivec// Convert from this:NSLog(@"Broken sprocket detected!");NSLog(@"User selected file:%@ withSize:%u", filePath, fileSize);// To this:DDLogError(@"Broken sprocket detected!");DDLogVerbose(@"User selected file:%@ withSize:%u", filePath, fileSize); 比如选了DDLogLevelDebug调试的时候只会在控制台输出Debug,Info,Warn和Error。 swift用法 12345678910111213141516//swiftDDLog.addLogger(DDTTYLogger.sharedInstance()) // TTY = Xcode consoleDDLog.addLogger(DDASLLogger.sharedInstance()) // ASL = Apple System Logslet fileLogger: DDFileLogger = DDFileLogger() // File LoggerfileLogger.rollingFrequency = 60*60*24 // 24 hoursfileLogger.logFileManager.maximumNumberOfLogFiles = 7DDLog.addLogger(fileLogger)...DDLogVerbose("Verbose");DDLogDebug("Debug");DDLogInfo("Info");DDLogWarn("Warn");DDLogError("Error"); Objective-C用法： 123456789101112131415[DDLog addLogger:[DDTTYLogger sharedInstance]]; // TTY = Xcode console[DDLog addLogger:[DDASLLogger sharedInstance]]; // ASL = Apple System LogsDDFileLogger *fileLogger = [[DDFileLogger alloc] init]; // File LoggerfileLogger.rollingFrequency = 60 * 60 * 24; // 24 hour rollingfileLogger.logFileManager.maximumNumberOfLogFiles = 7;[DDLog addLogger:fileLogger];...DDLogVerbose(@"Verbose");DDLogDebug(@"Debug");DDLogInfo(@"Info");DDLogWarn(@"Warn");DDLogError(@"Error"); 如何输出有颜色的Log？首先要去安装一个Xcode插件XcodeColors 安装方法 把项目下载下来，运行，然后重启Xcode。。。。点击Load Bundle就好 然后在项目中加入这两个语句（可以写在- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 里面）： 12345// Standard lumberjack initialization[DDLog addLogger:[DDTTYLogger sharedInstance]];// And we also enable colors[[DDTTYLogger sharedInstance] setColorsEnabled:YES]; 还没完！！！ 然后在Xcode中设置： Xcode中点击Product -&gt; Edit Scheme 点击左边的Run，然后选中Arguments 添加一项新的Environment Variable叫XcodeColors，value写YES。 现在控制台输出的就是带有颜色的Log了，默认 DDLogError : 红色 DDLogWarn : 橙色 自定义颜色 代码中加入： 123456789101112// Let's customize our colors.// DDLogInfo : Pink#if TARGET_OS_IPHONEUIColor *pink = [UIColor colorWithRed:(255/255.0) green:(58/255.0) blue:(159/255.0) alpha:1.0];#elseNSColor *pink = [NSColor colorWithCalibratedRed:(255/255.0) green:(58/255.0) blue:(159/255.0) alpha:1.0];#endif[[DDTTYLogger sharedInstance] setForegroundColor:pink backgroundColor:nil forFlag:DDLogFlagInfo];DDLogInfo(@"Warming up printer"); // Prints in Pink ! ####有个小技巧： 创建一个pch文件，在这个文件里面引入 1#import &lt;CocoaLumberjack/CocoaLumberjack.h&gt; 然后设置log等级 static const DDLogLevel ddLogLevel = DDLogLevelDebug; 整个项目的其它文件就都可以正常使用DDLog了~ 对于如何创建pch文件，以及什么是pch文件有疑问的同学传送门]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JGProgressHUD]]></title>
    <url>%2F2015%2F12%2F22%2FJGProgressHUD%2F</url>
    <content type="text"><![CDATA[https://github.com/JonasGessner/JGProgressHUD JGProgressHUD是HUD(head up Display)中的一种，虽然它在Github上的star不是做多的，但是它功能应该是最花哨的，我比较喜欢～～ 毕竟可以装逼 安装CocoaPods: 把下面这行写进Podfile: 1pod 'JGProgressHUD' Carthage: 把下面这行写进Cartfile: 1github "JonasGessner/JGProgressHUD" &gt;= 1.3.1 Framework (iOS &gt;= 8.0 only): 把JGProgressHUD.xcodeproj拖入工程文件。 把JGProgressHUD.framework 加到工程的General-&gt;Embedded Binaries中。 在Build Settings-&gt;Other Linker Flags中加入-ObjC flag。 使用首先要“import”头文件 Objective-C: 1#import "JGProgressHUD.h" swift: 1import JGProgressHUD 模糊进度显示(其实就是一朵菊花)1234JGProgressHUD *HUD = [JGProgressHUD progressHUDWithStyle:JGProgressHUDStyleDark]; HUD.textLabel.text = @"Loading"; [HUD showInView:self.view]; [HUD dismissAfterDelay:3.0]; 错误显示12345JGProgressHUD *HUD = [JGProgressHUD progressHUDWithStyle:JGProgressHUDStyleDark]; HUD.textLabel.text = @"Error"; HUD.indicatorView = [[JGProgressHUDErrorIndicatorView alloc] init]; //JGProgressHUDSuccessIndicatorView is also available [HUD showInView:self.view]; [HUD dismissAfterDelay:3.0]; 自定义图片显示1234JGProgressHUD *HUD = [JGProgressHUD progressHUDWithStyle:JGProgressHUDStyleDark];HUD.indicatorView = [[JGProgressHUDImageIndicatorView alloc] initWithImage:[UIImage imageNamed:@"my_image.png"]];[HUD showInView:self.view];[HUD dismissAfterDelay:3.0]; 有进度显示12345JGProgressHUD *HUD = [JGProgressHUD progressHUDWithStyle:JGProgressHUDStyleDark];HUD.indicatorView = [[JGProgressHUDPieIndicatorView alloc] initWithHUDStyle:HUD.style]; //Or JGProgressHUDRingIndicatorView[HUD showInView:self.view];[HUD dismissAfterDelay:3.0]; 效果图]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking]]></title>
    <url>%2F2015%2F12%2F21%2FAFNetworking%2F</url>
    <content type="text"><![CDATA[https://github.com/AFNetworking/AFNetworking AFNetworking 是一款备受喜爱的iOS端和Mac OS X端的网络库。它构建于 Foundation URL Loading System之上, 对cocoa的网络层做了扩展。它拥有良好的架构,丰富的api,以及模块化构建方式,使得使用起来非常轻松。 Swift可以使用Alamofire 安装使用CocoaPods安装在Podfile里面加入 1234source 'https://github.com/CocoaPods/Specs.git'platform :ios, '8.0'pod 'AFNetworking', '~&gt; 3.0' 使用Carthage安装在Cartfile中加入: 1github "AFNetworking/AFNetworking" ~&gt; 3.0 3.0版本只支持iOS 7、OS X 10.9以上的版本 使用导入头文件 1#import &lt;AFNetworking.h&gt; 检查网络是否连接123456[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; NSLog(@"Reachability: %@", AFStringFromNetworkReachabilityStatus(status)); &#125;];[[AFNetworkReachabilityManager sharedManager] startMonitoring]; 其中status表示网络状态,通过Wi-Fi链接返回2，用手机流量返回1，无连接为0，为止状态为－1 。 123456typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123; AFNetworkReachabilityStatusUnknown = -1, AFNetworkReachabilityStatusNotReachable = 0, AFNetworkReachabilityStatusReachableViaWWAN = 1, AFNetworkReachabilityStatusReachableViaWiFi = 2,&#125;; 请求JSON数据12345678910111213NSURL *URL = [NSURL URLWithString:@"http://example.com"];AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager GET:URL.absoluteString parameters:nil success:^(NSURLSessionTask *task, id responseObject) &#123; NSLog(@"JSON: %@", responseObject); //如果穿回来的数据带有数组可以这样 //NSArray *data = [responseObject objectForKey:@"data"]; //NSString *name = [data[0] objectForKey:@"name"]; //NSLog(@"name: %@", name);&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123; NSLog(@"Error: %@", error);&#125;]; 其中parameters可以用NSDictionary，如 1NSDictionary *parameters = @&#123;@"foo": @"bar", @"baz": @[@1, @2, @3]&#125;; post数据的话将 GET改为POST就可以了～ 下载文件12345678910111213NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@"http://example.com/download.zip"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) &#123; NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];&#125; completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) &#123; NSLog(@"File downloaded to: %@", filePath);&#125;];[downloadTask resume]; 上传文件123456789101112131415NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) &#123; if (error) &#123; NSLog(@"Error: %@", error); &#125; else &#123; NSLog(@"Success: %@ %@", response, responseObject); &#125;&#125;];[uploadTask resume]; 从2.0迁移到3.0的方法，官方文档]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 强制使用http]]></title>
    <url>%2F2015%2F12%2F21%2FiOS%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8http%2F</url>
    <content type="text"><![CDATA[iOS 9要求App内访问的网络必须使用HTTPS协议，这样就会导致所有的http请求全部失效了。为了让程序正常运行，可以强制程序使用http协议。 方法是 通过修改 info.plist，添加NSAppTransportSecurity-&gt;NSAllowsArbitraryLoads即可。 步骤 点击项目-&gt;info； 任意一栏点＋号添加NSAppTransportSecurity（类型为Dictionary） NSAppTransportSecurity下面添加NSAllowsArbitraryLoads(类型为Boolen,值为YES) 注意所有字段不要多了空格，然后就可以了。]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode常用插件]]></title>
    <url>%2F2015%2F12%2F09%2FXcode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Alcatrazhttps://github.com/alcatraz/Alcatraz Alcatraz是Xcode下的一个包管理插件，其实就是一个“管理插件的插件”。 安装方法是在终端输入 1curl -fsSL https://raw.github.com/alcatraz/Alcatraz/master/Scripts/install.sh | sh 然后重启Xcode，选Load Bundle。重启最好点击Xcode-&gt;Quit Xcode，不然可能会没用 就可以在window-&gt;Package Manager打开Alcatraz。图形化界面，傻瓜式操作。 安装好Alcatraz之后，就可以方便的安装其他插件了。 Amoyly颜色主题，我比较喜欢这个。 VVDocumenterhttps://github.com/onevcat/VVDocumenter-Xcode 文档规范注释工具。以前我从来不写注释，但是，自从用了VVDocumenter，我爱上了写注释。 KSImageNamed-Xcodehttps://github.com/ksuther/KSImageNamed-Xcode 同时支持 Objective-C 和 Swift。再也不用担心图片名字写错了。 SCXcodeMiniMaphttps://github.com/stefanceriu/SCXcodeMiniMap 可以在代码窗口左边产生一个小的代码预览窗口，就像sublime text那样。 XAlignhttps://github.com/qfish/XAlign 代码对齐工具，强迫症专用！！！ ColorSense-for-Xcodehttps://github.com/omz/ColorSense-for-Xcode 自动显示颜色（好像对我来说没什么用） 安装不能通过Alcatraz，需要下载之后在Xcode上运行，官网上有写 XActivatePowerModehttps://github.com/qfish/XActivatePowerMode 装逼神器，妹子在旁边的时候可以打开玩玩，但是用的时候会一卡一卡的……]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X系统上安装树莓派Raspbian系统]]></title>
    <url>%2F2015%2F12%2F03%2FOS-X%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%E6%A0%91%E8%8E%93%E6%B4%BERaspbian%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[首先去官网下载一个Raspbin 下载完成之后得到一个压缩包，解压之后得到一个镜像文件 2015-11-21-raspbian-jessie.img。 然后准备一张SD卡，最好8G以上吧。 图形化界面安装 将SD卡插入Mac上的读卡器。 点击屏幕左上角苹果标志，关于本机-&gt;系统报告,找到USB-&gt;Card Reader-&gt;BSD。找到一个类似于 diskn的数据，比如我的是 disk2。 用磁盘工具抹掉SD卡，SD卡文件格式必须为 FAT32，如果不是自己用磁盘工具重新格式化（launchpad-&gt;其他-&gt;磁盘工具）。 在终端输入 1sudo dd bs=1m if=path_of_your_image.img of=/dev/rdiskn 其中path_of_your_image.img是你放镜像文件的路径，rdiskn中n是你之前看的diskn那个数字，我的是2，所以就是rdisk2 如果命令失效，就用diskn代替rdiskn。 用命令行安装1.打开终端2.输入 1diskutil list 找到你的SD卡的磁盘号，我的是disk2。 3.抹除SD卡 输入来抹除SD卡1diskutil unmountDisk /dev/diskn #n需要替换成数字 例如我的是这样 1diskutil unmountDisk /dev/disk2 4.把镜像拷到SD卡上 1sudo dd bs=1m if=image.img of=/dev/rdiskn #n需要替换成数字 例如我的是 1sudo dd bs=1m if=2015-11-21-raspbian-jessie.img of=/dev/rdisk2 如果出现dd: invalid number &#39;1m&#39;，就把1m换车1M。 时间很慢，大约需要5分多钟，没有进度条，慢慢等喽 官方安装教程]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EI CAPTAIN设置使用三根手指拖动窗口]]></title>
    <url>%2F2015%2F11%2F08%2FEI-CAPTAIN%E8%AE%BE%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%B8%89%E6%A0%B9%E6%89%8B%E6%8C%87%E6%8B%96%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[前几天手贱抹了磁盘，废了好大的劲才把系统重新装回来。结果设置触控板的时候发现，原来系统上的三根手指拖动窗口的选项不见了！！找了很多地方终于在这个网上找到了。(其实一开始就用谷歌哪来那么多事，怪我手贱用百度浪费了好多时间……) 打开系统偏好设置-&gt;辅助功能 找到鼠标与触控板—&gt;触控板选项… 勾选启用拖移-&gt;三指拖移就可以了]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Could not launch “My App” process launch failed： Security]]></title>
    <url>%2F2015%2F11%2F08%2FCould-not-launch-%E2%80%9CMy-App%E2%80%9D-process-launch-failed%EF%BC%9A-Security%2F</url>
    <content type="text"><![CDATA[iOS9真机调试的时候，Xcode会弹出Could not launch &quot;My App&quot; process launch failed: Security。 这时会发现手机上已经安装了你的应用了。点击应用又会弹出 当时我就跪了！！设置那么大！！你让我去哪里找！！！ 把设置遍历了一遍终于找到了： 设置 -&gt; 通用 -&gt; 描述文件 -&gt; “你真机运行的AppleID” 选择信任 然后就可以了。]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo同时部署到Gitcafe和Github上]]></title>
    <url>%2F2015%2F11%2F02%2Fhexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0Gitcafe%E5%92%8CGithub%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[推荐一个可以同时部署到Gitcafe和Github上的hexo插件——hexo-deployer-git 安装方法在hexo的目录下 1npm install hexo-deployer-git --save 使用方法之前需要配置好Github和Gitcafe!! 在_config.yml中，deploy部分改为 123456deploy: type: git message: Site updated repo: github: git@github.com:cydjohn/cydjohn.github.io.git,master gitcafe: git@gitcafe.com:caoyudong/caoyudong.git,gitcafe-pages 然后就可以同时部署到两个地方了。 dns可以修改一下，国外的指向Github，国内的Gitcafe，这样速度会很快 虽然并没有什么人看我博客……]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl加密解密]]></title>
    <url>%2F2015%2F11%2F01%2Fopenssl%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[首先生成公钥私钥 我的电脑是Mac所以自带了openssl，从终端里面可以直接生成 首先生成一个私钥放在私钥文件rsa_private_key.pem中 1openssl genrsa -out rsa_private_key.pem 1024 把RSA私钥转换成PKCS8格式，密码为空就行 1pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocrypt 生成公钥 1rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem C测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;openssl/pem.h&gt;#include &lt;openssl/rsa.h&gt;int main()&#123; // 原始明文 char plain[256]="0123456789"; // 用来存放密文 char encrypted[1024]; // 用来存放解密后的明文 char decrypted[1024]; // 公钥和私钥文件 const char* pub_key="public.pem"; const char* priv_key="private.pem"; // ------------------------------------------------------- // 利用公钥加密明文的过程 // ------------------------------------------------------- // 打开公钥文件 FILE* pub_fp=fopen(pub_key,"r"); if(pub_fp==NULL)&#123; printf("failed to open pub_key file %s!\n", pub_key); return -1; &#125; // 从文件中读取公钥 RSA* rsa1=PEM_read_RSA_PUBKEY(pub_fp, NULL, NULL, NULL); if(rsa1==NULL)&#123; printf("unable to read public key!\n"); return -1; &#125; if(strlen(plain)&gt;=RSA_size(rsa1)-41)&#123; printf("failed to encrypt\n"); return -1; &#125; fclose(pub_fp); // 用公钥加密 int len=RSA_public_encrypt(strlen(plain), plain, encrypted, rsa1, RSA_PKCS1_PADDING); if(len==-1 )&#123; printf("failed to encrypt\n"); return -1; &#125; // 输出加密后的密文 FILE* fp=fopen("out.txt","w"); if(fp)&#123; fwrite(encrypted,len,1,fp); fclose(fp); &#125; // ------------------------------------------------------- // 利用私钥解密密文的过程 // ------------------------------------------------------- // 打开私钥文件 FILE* priv_fp=fopen(priv_key,"r"); if(priv_fp==NULL)&#123; printf("failed to open priv_key file %s!\n", priv_key); return -1; &#125; // 从文件中读取私钥 RSA *rsa2 = PEM_read_RSAPrivateKey(priv_fp, NULL, NULL, NULL); if(rsa2==NULL)&#123; printf("unable to read private key!\n"); return -1; &#125; // 用私钥解密 len=RSA_private_decrypt(len, encrypted, decrypted, rsa2, RSA_PKCS1_PADDING); if(len==-1)&#123; printf("failed to decrypt!\n"); return -1; &#125; fclose(priv_fp); // 输出解密后的明文 decrypted[len]=0; printf("%s\n",decrypted);&#125;]]></content>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言使用Sqlite]]></title>
    <url>%2F2015%2F10%2F28%2FC%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8Sqlite%2F</url>
    <content type="text"><![CDATA[Mac下Xcode中需要引入libsqlite3.0.tbd Windows下需要用到sqlite3.lib sqlite3官网上并没有sqlite3.lib可下载，要用需自编译生成。官网地址 如从sqlite3.7.5版本中得到sqlite3.lib，可用VS的LIB工具链接得到。具体过程如下： 先将sqlite-dll-win64-x64-3090100.rar解压到文件夹sqlite-dll-win64-x64-3090100， 再将VS安装目录下VC中的LIB.EXE，LINK.EXE复制到sqlite-dll-win64-x64-3090100文件夹，(lib.exe，link.exe地址：C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\bin) 在网上下载mspdb60.dll，复制到sqlite-dll-win64-x64-3090100文件夹， 将Program Files (x86)\Microsoft Visual Studio 10.0\Common7\IDE内的 mspdb110.dll复制到sqlite-dll-win64-x64-3090100文件夹。 在命令窗内运行命令进入sqlite-dll-win64-x64-3090100文件夹 执行LIB /DEF:SQLITE3.DEF /MACHINE:IX86或LIB /DEF:SQLITE3.DEF 即可生成sqlite3.lib文件。 然后将sqlite3.lib文件引入项目中 sqlite3.lib下载 或者，使用一个超简单的方法.直接从官网上下载源文件，然后把sqlite3.c, sqlite3.h 放入工程中～ 主要函数sqlite3_open(const char *filename,sqlite3 ppDb)** filename: 数据库文件的名字 ppDb: sqlite的一个handle，之后通过这个handle对数据库做操作 sqlite3_exec(sqlite3*, const char *sql,int (*callback)(void*,int,char**,char**),void *,char **errmsg) sqlite3: 一个已经打开的handle（通过sqlite3_open处理过） sql: 需要执行的sql语句 int (*callback)(void*,int,char**,char**): 一个回调函数 void*: 一个回调参数 **errmsg 错误消息 具体增删查改操作12//c#include "sqlite3.h" 创建数据库文件12345678910111213//csqlite3 *getDatabase()&#123; sqlite3 *db=NULL; int rc; rc = sqlite3_open("test.db", &amp;db); //打开指定的数据库文件,如果不存在将创建一个同名的数据库文件 if( rc )&#123; fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db)); sqlite3_close(db); exit(1); &#125; return db;&#125; 建表12345678910111213//cvoid createTable()&#123; sqlite3 *db = getDatabase(); const char * sql = "CREATE TABLE IF NOT EXISTS testTable(id integer primary key,a text,b text,c text);"; char * pErrMsg = "0"; int result = sqlite3_exec(db, sql, 0, 0, &amp;pErrMsg ); if( result != SQLITE_OK )&#123; fprintf(stderr, "SQL error: %s\n", pErrMsg); sqlite3_free(pErrMsg); &#125; sqlite3_close(db); //关闭数据库&#125; 增1234567891011//cvoid insertIntoDatabase()&#123; sqlite3 *db = getDatabase(); char * pErrMsg = 0; int result = sqlite3_exec(db, "INSERT INTO testTable(a,b,c) VALUES(1,2,3);", 0, 0, &amp;pErrMsg); if(result == SQLITE_OK)&#123; printf("插入数据成功\n"); &#125; sqlite3_close(db); //关闭数据库&#125; 删12345678//cvoid deleteFromTable()&#123; sqlite3 *db = getDatabase(); char *pErrMsg = 0; sqlite3_exec(db, "delete from testTable where id = 2", NULL,NULL, &amp;pErrMsg); sqlite3_close(db);&#125; 查123456789101112131415161718//cint select_callback(void * data, int col_count, char ** col_values, char ** col_Name)&#123; // 每条记录回调一次该函数,有多少条就回调多少次 int i; for( i=0; i &lt; col_count; i++)&#123; printf( "%s = %s\n", col_Name[i], col_values[i] == 0 ? "NULL" : col_values[i] ); &#125; return 0;&#125;void databaseQuery()&#123; sqlite3 *db = getDatabase(); char * pErrMsg = 0; sqlite3_exec(db, "select * from testTable;", select_callback, 0, &amp;pErrMsg); sqlite3_close(db); //关闭数据库&#125; 输出很奇葩，需要根据自己项目做修改 改12345678//cvoid updateTable()&#123; sqlite3 *db = getDatabase(); char *pErrMsg = 0; sqlite3_exec(db, "update testTable set a = 666 where id = 1" , NULL, NULL, &amp;pErrMsg); sqlite3_close(db);&#125;]]></content>
      <tags>
        <tag>C</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openssl从证书中获取公钥]]></title>
    <url>%2F2015%2F10%2F27%2FOpenssl%E4%BB%8E%E8%AF%81%E4%B9%A6%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[1openssl x509 -in ca.crt -pubkey 其中 －in 为输入文件名 结果： 123456789101112131415161718192021222324252627282930313233343536-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvLgG+bUnsMJCgAf/lGWh2vqn3ZgoKHwERvgVmgCdn8LPUwc2/kGf6ucmkHKE+VcZ7qQg7A/2K8PyDvs3K+qSSpkyeC0lhaUxYFJGmSjdeqDkLF+fJ5DcTgqi9sJJfozQN2Uk5ppsN76t4BEW7IW/a8NReMJ18iB3H18wcJQS0ml4pf/O5h3YxArbGl5LE2sWVRFvE9cSn/Vi+zjMP4e8FIMWi6snIhQpXUMQmP7ecCfzEAEtfVDEXa2Dzka+FJpnJNJ2nQXJIEWF55YOOe1D4gJAl9qsI8cVEnZK3fseqHpZ8kKY2SuGyNlsgEf7+DfUT/m3Igg+n2MsoxndtOUiGwIDAQAB-----END PUBLIC KEY----------BEGIN CERTIFICATE-----MIIEnjCCA4agAwIBAgIJAN7TiN2CbZx9MA0GCSqGSIb3DQEBCwUAMIGQMQswCQYDVQQGEwJDTjESMBAGA1UECBMJR3Vhbmdkb25nMRIwEAYDVQQHEwlHdWFuZ3pob3UxEjAQBgNVBAoTCU9wZW5UQ0dBQTELMAkGA1UECxMCQ0ExFTATBgNVBAMTDE9wZW5UQ0dBQSBDQTEhMB8GCSqGSIb3DQEJARYSaW5mb0BvcGVudGNnYWEub3JnMB4XDTE1MTAyNzAxNTk0MVoXDTI1MTAyNDAxNTk0MVowgZAxCzAJBgNVBAYTAkNOMRIwEAYDVQQIEwlHdWFuZ2RvbmcxEjAQBgNVBAcTCUd1YW5nemhvdTESMBAGA1UEChMJT3BlblRDR0FBMQswCQYDVQQLEwJDQTEVMBMGA1UEAxMMT3BlblRDR0FBIENBMSEwHwYJKoZIhvcNAQkBFhJpbmZvQG9wZW50Y2dhYS5vcmcwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC8uAb5tSewwkKAB/+UZaHa+qfdmCgofARG+BWaAJ2fws9TBzb+QZ/q5yaQcoT5VxnupCDsD/Yrw/IO+zcr6pJKmTJ4LSWFpTFgUkaZKN16oOQsX58nkNxOCqL2wkl+jNA3ZSTmmmw3vq3gERbshb9rw1F4wnXyIHcfXzBwlBLSaXil/87mHdjECtsaXksTaxZVEW8T1xKf9WL7OMw/h7wUgxaLqyciFCldQxCY/t5wJ/MQAS19UMRdrYPORr4Ummck0nadBckgRYXnlg457UPiAkCX2qwjxxUSdkrd+x6oelnyQpjZK4bI2WyAR/v4N9RP+bciCD6fYyyjGd205SIbAgMBAAGjgfgwgfUwHQYDVR0OBBYEFDMpinnH9UEjObLR/BukzOSFRadVMIHFBgNVHSMEgb0wgbqAFDMpinnH9UEjObLR/BukzOSFRadVoYGWpIGTMIGQMQswCQYDVQQGEwJDTjESMBAGA1UECBMJR3Vhbmdkb25nMRIwEAYDVQQHEwlHdWFuZ3pob3UxEjAQBgNVBAoTCU9wZW5UQ0dBQTELMAkGA1UECxMCQ0ExFTATBgNVBAMTDE9wZW5UQ0dBQSBDQTEhMB8GCSqGSIb3DQEJARYSaW5mb0BvcGVudGNnYWEub3JnggkA3tOI3YJtnH0wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAZdsMS7WCCAOyER3yVozOQ4R9MLt1LW0RSK1I3JXxMScTHA/bHiFDMvK9CuOOvMZvnYjhHXPpCKIf8fgRTRfBA1lE3VUBEXj2WeH5wzNGwIXXhVUqB4kW1mqDwxfcLRvp7dof8dqFJ0AoCYAj7dUejrb51tzLNaXnr6/AatASMwaIfchjJYT2XdeDMB60aiVlS7NITjUUOiRnW4GtCfxpqonccpUAYpljy0m1eMjvQw0cgxI8FZh95xkZPSKVEOai95PAkeCX3ua8GIFrCbvuupALf/hMA4HpObk6uNn5rlJvvhklTtaotVIkQNCJG7h84Ah2VLUP2HiZVfHb/hADhA==-----END CERTIFICATE-----]]></content>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftyJSON]]></title>
    <url>%2F2015%2F10%2F27%2FSwiftyJSON%2F</url>
    <content type="text"><![CDATA[SwiftyJSON是用swift写的一款处理JSON数据的库。我个人觉得非常好用～ 为什么好用呢？借用下作者的例子：以前，我们需要向下面这样处理JSON数据，来得到一个人的名字： 123456789let JSONObject: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)if let statusesArray = JSONObject as? [AnyObject], let status = statusesArray[0] as? [String: AnyObject], let user = status["user"] as? [String: AnyObject], let username = user["name"] as? String &#123; // Finally we got the username&#125; 很不优雅…… 但是用了SwiftJSON之后这样就可以得到了 12345let json = JSON(data: dataFromNetworking)if let userName = json[0]["user"]["name"].string&#123; //Now you got your value&#125; 而且随便玩，完全不用担心程序崩溃。如果数组访问越界或者数据不存在它自动返回nil 12345678let json = JSON(data: dataFromNetworking)if let userName = json[999999]["wrong_key"]["wrong_name"].string&#123; //Calm down, take it easy, the ".string" property still produces the correct Optional String type with safety&#125; else &#123; //Print the error println(json[999999]["wrong_key"]["wrong_name"])&#125; 安装CocoaPods 将下面这个加到你的Podfile里面： 1pod "SwiftyJSON", "&gt;= 2.2" Carthage 将下面这个加到你的Cartfile里面： 1github &quot;SwiftyJSON/SwiftyJSON&quot; &gt;= 2.2 手动安装 直接将SwiftyJSON.swift拖到工程文件里面 用法初始化 1let json = JSON(data: dataFromNetworking) 1let json = JSON(jsonObject) 123if let dataFromString = jsonString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) &#123; let json = JSON(data: dataFromString)&#125; 获取各种数据 1234567//NSNumberif let id = json["user"]["favourites_count"].number &#123; //Do something you want&#125; else &#123; //Print the error println(json["user"]["favourites_count"].error)&#125; 1234567//Stringif let id = json["user"]["name"].string &#123; //Do something you want&#125; else &#123; //Print the error println(json["user"]["name"])&#125; 1234567//Boolif let id = json["user"]["is_translator"].bool &#123; //Do something you want&#125; else &#123; //Print the error println(json["user"]["is_translator"])&#125; 12345678//Intif let id = json["user"]["id"].int &#123; //Do something you want&#125; else &#123; //Print the error println(json["user"]["id"])&#125;... 或者用xxxValue，如果不确定数据格式的话。 12//If not a Number or nil, return 0let id: Int = json["id"].intValue 12//If not a String or nil, return ""let name: String = json["name"].stringValue 12//If not a Array or nil, return []let list: Array&lt;JSON&gt; = json["list"].arrayValue 12//If not a Dictionary or nil, return [:]let user: Dictionary&lt;String, JSON&gt; = json["user"].dictionaryValue 循环访问数据 1234//If json is .Dictionaryfor (key: String, subJson: JSON) in json &#123; //Do something you want&#125; 在Alamofire里面使用SwiftyJSON 123456789101112Alamofire.request(.GET, url, parameters: parameters) .responseJSON &#123; (req, res, json, error) in if(error != nil) &#123; NSLog("Error: \(error)") println(req) println(res) &#125; else &#123; NSLog("Success: \(url)") var json = JSON(json!) &#125; &#125; 介于swift一直在升级，很多东西会经常变动。这篇文档也可能过一段时间就过时了，有问题可以到SwiftyJSON里面提下issue，我也会经常来更新下博客的～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alamofire]]></title>
    <url>%2F2015%2F10%2F27%2FAlamofire%2F</url>
    <content type="text"><![CDATA[Alamofire 是一款用swift写的用于http网络连接的库，目的是用来在swift中代替OC的AFNetworking。 使用十分简单： 1234//swiftimport AlamofireAlamofire.request(.GET, "http://httpbin.org/get") 安装 须要用swift，项目必须运行在iOS 8或者更高版本iOS。OS X Mavericks或者更高版本OS上。用OC其实也可以，但是折腾很多东西……OC还是直接用AFNetworking吧～ CocoaPods 把下面这些加到Podfile里面然后 pod install： 12345source 'https://github.com/CocoaPods/Specs.git'platform :ios, '8.0'use_frameworks!pod 'Alamofire', '~&gt; 1.2' carthage 把下面这些加到 Cartfile里面： 1github &quot;Alamofire/Alamofire&quot; &gt;= 1.2 或者也可以手动安装……详情见Alamofire 用法 Alamofire所有请求都是是异步的，所以可以放心大胆的用～ 12//swiftimport Alamofire 发起一个连接： 1234567891011121314151617//swiftimport AlamofireAlamofire.request(.GET, "http://httpbin.org/get")``` **收到数据转为string**```swift//swiftAlamofire.request(.GET, "http://httpbin.org/get") .responseString &#123; (_, _, string, _) in println(string) &#125; 收到数据转为JSON 12345//swiftAlamofire.request(.GET, "http://httpbin.org/get") .responseJSON &#123; (_, _, JSON, _) in println(JSON) &#125; 转化结果的方法： response() responseString(encoding: NSStringEncoding) responseJSON(options: NSJSONReadingOptions) responsePropertyList(options: NSPropertyListReadOptions) Alamofire支持的HTTP方法 123456789101112//swiftpublic enum Method: String &#123; case OPTIONS = "OPTIONS" case GET = "GET" case HEAD = "HEAD" case POST = "POST" case PUT = "PUT" case PATCH = "PATCH" case DELETE = "DELETE" case TRACE = "TRACE" case CONNECT = "CONNECT"&#125; 使用时修改第一个参数即可： 123456//swiftAlamofire.request(.POST, "http://httpbin.org/post")Alamofire.request(.PUT, "http://httpbin.org/put")Alamofire.request(.DELETE, "http://httpbin.org/delete") 加参数的网络请求：GET请求： 123//swiftAlamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])// http://httpbin.org/get?foo=bar POST请求： 12345678910111213//swiftlet parameters = [ "foo": "bar", "baz": ["a", 1], "qux": [ "x": 1, "y": 2, "z": 3 ]]Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters)// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 由于大部分网络数据都是JSON格式的，所以Alamofire搭配SwiftyJSON会比较好用 介于swift一直在升级，很多东西会经常变动。这篇文档也可能过一段时间就过时了，可以到Alamofire查看具体的改动，我也会经常来更新下博客的～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openssl产生随机数]]></title>
    <url>%2F2015%2F10%2F27%2FOpenssl%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[终端 1openssl rand[-out file] [-randfile(s)] [-base64] [-hex] num 产生10位的随机数 1rand 10 结果为:M??;?????，全是乱码 可以尝试 1rand -hex 10 结果为02aa218ecc084e5f263f 或者 1rand -base64 10 结果为sNzstP2XbcJ9mw== 来输出不同编码的随机数 或者通过 1rand -out test -hex 10 来输出到test文件上 C语言 C语言有很多函数可以调用: 1int RAND_bytes(unsigned char *buf,int num); 根据加密算法生成随机数，其实也是一个伪随机数，但是，如果在调用此函数之前，设定好随机种子，那么生成的随机数是不能被预先计算出来的。buf：输出，生产的随机数存储的数组； num： 输入，生产的随机数个数； 返回值：1 ，成功， 0 失败； 1void RAND_seed(const void *buf,int num); 随机数生成前设定种子； buf： 输入， 种子保存的数组； num： 输入，种子数据长度； 1void RAND_add(const void *buf,int num,double entropy); 增加随机数生成的不可预知性，将buf数组中num个数据加入PRNG中，entropy是对buf中数据的随机性估计值，如果entropy 和num相等，那么RAND_add函数与Rand_seed函数相同； buf中的数据，一般采用系统中随机性的事件，比如一些交互性数据，用户敲击的键盘值，鼠标滑过的位置等等。 1void RAND_screen(void); RAND_screen也是为Windows系统设计的函数，将当前屏幕数据加入到PRNG中，在windows系统中，对于应用开发者，最好采用RAND_event函数来收集硬件事件，增加PRNG的随机性，需要注意的是，这两个函数，不能在没有交互性的系统比如服务器中使用。 1const char *RAND_file_name(char *buf, size_t num); 在默认路径下，生成随机数种子文件，buf： 保存文件名num： 文件名字符数；如果\$RANDFILE设定，文件名即为\$RANDFILE，如果没有设定，那么文件名是\$HOME/.rnd如果\$HOME或者num的数字太小，不能容纳文件名，那么函数将返回错误。返回值，如果成功，返回buf的地址，如果失败，NULL 1int RAND_load_file(const char *filename, long max_bytes); 从随机数种子文件中读取数据，加入到PRNG中；filename： 随机数种子文件；max_bytes：可以读取的最大字节数；如果max_bytes 的值是-1，将读取整个文件；返回值： 读取的数据个数； 1int RAND_write_file(const char *filename); 将随机数写入种子文件，当前是1024个字节，使用者后面可以调用RAND_load_file读取这些随机数； 返回值： 写入的字节数，如果失败，则写入-1； 1void RAND_cleanup(void); 清除PRNG的状态； 1int RAND_egd(const char *path); 向取随机数种子的Dameon程序EGD要求种子数据，数据长度为255个字节；path： EGD的socket路径；返回值：读取的数据字节数，如果失败，返回-1 1int RAND_egd_bytes(const char *path, int bytes) 向取随机数种子的Dameon程序EGD要求种子数据，数据长度为bytes定义的字节数；path： EGD的socket路径；bytes：请求的字节数；返回值：读取的数据字节数，如果失败，返回-1 1int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes); 向取随机数种子的Dameon程序EGD要求种子数据，数据长度为bytes定义的字节数，如果buf不是空，那么数据保存在buf定义的内存中，否则直接加到PRNG中；path： EGD的socket路径；bytes：请求的字节数；返回值：读取的数据字节数，如果失败，返回-1 关于EGD：//tbc系统中如果没有/dev/*random服务，可以通过edg Deamon服务来实现对随机数种子的获取，edg通过socket界面来通信，一次最多可以获取255个字节，一次连接可以获取多次数据； 示例1234567891011121314151617#include &lt;memory.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;openssl/rand.h&gt;int main(int argc,char ** argv)&#123; unsigned char a[128]; int r; r = RAND_bytes(a, 128); if(r)&#123; int i=0; for(i =0;i&lt;128;i++) &#123; printf("%d",a[i]); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Mac终端里的bogon]]></title>
    <url>%2F2015%2F10%2F19%2F%E4%BF%AE%E6%94%B9Mac%E7%BB%88%E7%AB%AF%E9%87%8C%E7%9A%84bogon%2F</url>
    <content type="text"><![CDATA[打开终端 用户名前会有个 bogon，看着不爽😕，怎么改掉呢？ 通过这个命令，就可以了。注意HostName是大写！！ 1sudo scutil --set HostName 要改的名字 bogon是什么？bogon是指那些不该出现在internet路由表中的地址吧这些地址应该包括： 私有地址如10，172.16-32,192.168….. 还未正式分配出去的地址 Mac 下的终端经常有时候前面的计算机名会错误的显示成 bogon. 这是因为终端会先向 DNS 请求查询当前 IP 的反向域名解析的结果，如果查询不到再显示我们设置的计算机名。而由于我们的 DNS 错误地将保留地址反向的 NS 查询结果返回了 bogon. 其中 bogon 本应该用来指虚假的 IP 地址，而非保留 IP 地址。因此就出现了会时不时地打印 bogon 这种奇怪名字作为计算机名的现象了。]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派GPIO的简单控制]]></title>
    <url>%2F2015%2F10%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[General Purpose Input Output （通用输入/输出）简称为GPIO，或总线扩展器。也就是树莓派上那一堆引脚。 GPIO库 wiringPi C,有Perl,PHP,Ruby,Node.js和Golang的扩展，支持wiringPi Pin 和BCM GPIO两种编号 RPi.GPIO Python, 支持Board Pin和BCM GPIO两种编号 Webiopi，Python，使用BCM GPIO编号 BCM2835, 使用BCM GPIO编号 WiringPi－GO，GO语言，支持以上三种编号 具体情况如下图：Board Pin 编号为板上的自然编号，左边引脚为1、3、5……39；右边引脚为2、4、6……40。RPi.GPIO.setmode(GPIO.BOARD)采用这列编号 BCM GPIO为树莓派主芯片提供商Broadcom的编号方法，相当于调用了WiringPiSetupGpio()或RPi.GPIO.setmode(GPIO.BCM)采用这列编号 Python安装： 新的系统（2015/11月的）好像自带了 1sudo apt-get install python-dev 安装python pip 1sudo apt-get install python-pip 安装python的GPIO库 1sudo apt-get install rpi.gpio 代码示例 1234567891011121314#pythonimport RPi.GPIO as GPIOimport timea = 21GPIO.setmode(GPIO.BCM) GPIO.setup(a,GPIO.OUT)while True: GPIO.output(a,GPIO.HIGH) time.sleep(1) GPIO.output(a,GPIO.LOW) time.sleep(1)GPIO.cleanup() CwiringPi库 安装： 123git clone git://git.drogon.net/wiringPicd wiringPi./build 测试有没有安装好 12$gpio -v$gpio readall 1234567891011121314151617181920212223//c#include &lt;wiringPi.h&gt;// LED Pin - wiringPi pin 0 is BCM_GPIO 17.#define LED 21int main ()&#123; wiringPiSetup () ; pinMode (LED, OUTPUT) ; for (;;) &#123; digitalWrite (LED, HIGH) ; // On delay (500) ; // mS digitalWrite (LED, LOW) ; // Off delay (500) ; &#125; return 0 ;&#125; 编译需要用 gcc -Wall -o test test.c -lwiringPi然后 sudo ./test BCM2835库 安装 下载: &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.35.tar.gz 解压缩: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $tar xvzf bcm2835-1.35.tar.gz 进入压缩之后的目录: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$cd bcm2835-1.35 配置: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $./configure 从源代码生成安装包: &nbsp;&nbsp;&nbsp;&nbsp; $make 执行检查: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $sudo make check 安装 bcm2835库: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $sudo make install 12345678910111213141516171819202122232425//c #include &lt;bcm2835.h&gt; // P1插座第11脚 #define PIN RPI_GPIO_P1_11 int main(int argc, char **argv) &#123; if (!bcm2835_init()) return 1; // 输出方式 bcm2835_gpio_fsel(PIN, BCM2835_GPIO_FSEL_OUTP); while (1) &#123; bcm2835_gpio_write(PIN, HIGH); bcm2835_delay(100); bcm2835_gpio_write(PIN, LOW); bcm2835_delay(100); &#125; bcm2835_close(); return 0; &#125;]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派桌面远程连接]]></title>
    <url>%2F2015%2F10%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%A1%8C%E9%9D%A2%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[可以先通过串口或者HDMI连接树莓派 安装vncserver（记得联网）1sudo apt-get install tightvncserver 开启一个桌面1vncserver:1 关掉一个桌面1vncserver -kill :1 注意 －kill后面有个空格，数字是桌面的编号 安装VNC客户端各个平台下有很多vnc客户端，自己随便下一个就好。 然后通过树莓派的IP地址就可以连上了。 IP地址后面那个数字是桌面的编号，比如我IP是192.168.1.106，编号为1，那就要用 192.168.1.106:1连接。 默认密码是: 12345678 然后就可以通过电脑控制树莓派了。 或者是iPad]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派设置无线上网]]></title>
    <url>%2F2015%2F10%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[树莓派没有无线网卡,你要去某宝买一个USB无线网卡，20～30吧，不算贵～转自http://www.jianshu.com/p/b42e8d3df449 一、查看网卡状态是否正常把无线网卡插到树莓派上，输入命令ifconfig -a查看是否有wlan0的信息，如果有说明网卡状态正常，可以跳过第二步，直接配置无线网络。如果查不到wlan0的信息，则需要安装无线网卡的驱动。 二、查看无线网卡的信息输入命令dmesg | grep usb查看无线网卡的信息，主要是看制造厂家（Manufacturer）。比如，我的网卡信息是 1usb 1-1.3: Manufacturer: Realtek 以Realtek为例，安装无线网卡驱动。 如果现在你的树莓派能联网，输入安装命令就可以安装Realtek的驱动了。 首先搜索Realtek驱动： apt-cache search realtek看到下面信息： 1firmware-realtek - Binary firmware for Realtek wired and wireless network adapters 安装Realtek驱动： 1sudo apt-get install firmware-realtek 如果你的树莓派现在不能上网，那么你可以去镜像站点中下载相关驱动。我推荐阿里云的镜像站点，速度比较快。http://mirrors.aliyun.com/raspbian/raspbian/pool/non-free/f/firmware-nonfree 下载firmware-realtek_0.43_all.deb，用winscp上传到树莓派的/tmp目录中。输入命令安装： 1sudo dpkg -i /tmp/firmware-realtek_0.43_all.deb 三、配置无线网络用编辑器nano打开interfaces文件 1sudo nano /etc/network/interfaces 我的interfaces文件是这样的： 123456789auto loiface lo inet loopbackiface eth0 inet dhcpallow-hotplug wlan0iface wlan0 inet manualwpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp 我们把无线网卡部分全部用#注释掉，然后添加自己的配置信息，最终结果如下： 1234567891011121314auto loiface lo inet loopbackiface eth0 inet dhcpauto wlan0allow-hotplug wlan0iface wlan0 inet manualiface wlan0 inet dhcpwpa-conf /etc/wpa.conf#wpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp 使用nano编辑器，ctrl+o保存，ctrl+x退出。 注意#wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf是注释掉的！！！注意#wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf是注释掉的！！！注意#wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf是注释掉的！！！重要的事情说三次 用编辑器nano创建 /etc/wpa.conf 文件： 1sudo nano /etc/wpa.conf 如果你的wifi没有密码 1234network=&#123;[Tab] ssid=&quot;你的无线网络名称（ssid）&quot;[Tab] key_mgmt=NONE&#125; 如果你的wifi使用WEP加密 12345network=&#123;[Tab] ssid=&quot;你的无线网络名称（ssid）&quot;[Tab] key_mgmt=NONE[Tab] wep_key0=&quot;你的wifi密码&quot;&#125; 如果你的wifi使用WPA/WPA2加密 12345network=&#123;[Tab] ssid=&quot;你的无线网络名称（ssid）&quot;[Tab] key_mgmt=WPA-PSK[Tab] psk=&quot;你的wifi密码&quot;&#125; 注1：所有符号都是半角符号（英文状态下的符号），“[Tab]”表示按一次Tab键 注2：如果你不清楚wifi的加密模式，可以在安卓手机上用root explorer打开 /data/misc/wifi/wpa/wpa_supplicant.conf，查看wifi的信息。 比如，我的wpa.conf文件是这样的： 12345network=&#123; ssid=&quot;1234&quot; key_mgmt=WPA-PSK psk=&quot;MTIzNA1234&quot;&#125; 最后输入命令启用无线网卡： 1sudo ifup wlan0 可以连无线网了。]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过ssh连接树莓派]]></title>
    <url>%2F2015%2F10%2F03%2F%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[我用的是树莓派B型，Mac OS系统，Raspbian 系统 首先确保树莓派和你的电脑在同一局域网下，并且树莓派已经连上局域网。不知道树莓派如何连接局域网的可以查看树莓派设置无线上网 然后，打开终端，通过命令 1ssh pi@你的树莓派的ip地址 就可以连上了，Raspbian系统自带了ssh，有些系统没有要先安装一个。 如何获取到树莓派IP地址正常情况下，我们是不可能知道树莓派的ip地址的。所以只能靠猜，当然也不是漫无目标的猜。 在终端输入arp －a可以得到一个列表，表示当前局域网下的用户的IP地址，当然，不包括树莓派的。树莓派的地址应该是最后一个地址 ＋ 1。比如当前最后一个是 192.168.1.106，那么树莓派的就是192.168.1.107 尝试 1ssh pi@192.168.1.107 也许就可以连上 如果不行就试试108，109，反正总会连上的……这方法实在土，而且菜，可以尝试更好的方法： 安装一个nmap，然后通过命令 1nmap -sP 192.168.1.0/24 就可以列出局域网下所有的用户了，因为nmap会吧局域网下所有IP都扫一遍（好像是）。 连接成功后就可以操作树莓派了（默认密码 raspberry） 或者直接 1ssh pi@raspberrypi.home raspberrypi.home 就是树莓派的地址，今早发现的～]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过USB转串口模块连接树莓派]]></title>
    <url>%2F2015%2F10%2F03%2F%E9%80%9A%E8%BF%87USB%E8%BD%AC%E4%B8%B2%E5%8F%A3%E6%A8%A1%E5%9D%97%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[我的是树莓派B型，Mac OS系统。由于放假回家没有显示器，没有键盘，没法用树莓派，所以研究了下这个方法。当然，还可以通过ssh链接，但是要建立在你的树莓派和你的电脑链接在同一个局域网的情况下。 串口模块首先，你要有个USB转ttl模块，淘宝上有卖，几块钱一个，很便宜，我用的是PL2303 驱动然后，就要去下载相应的驱动来安装。PL2303驱动下载 通过命令 1ls /dev/tty.usb* 来检查驱动是否安装成功了 记得把串口插到USB上，不然会显示 1ls: /dev/tty.usb*: No such file or directory 然后把PL2303连到树莓派上面：GND-&gt;GND; TSD-&gt;RXD;RXD-&gt;TSDTSD-&gt;RXD;RXD-&gt;TSDTSD-&gt;RXD;RXD-&gt;TSD别连反了！ 通过screen连接。打开终端，输入 1screen -v 如果显示没有该命令，就 1brew install screen 然后通过命令 1screen /dev/tty.usbserial 115200 就会看到一个空界面，按Enter键，就会出现Raspberry Pi的登录提示了。树莓派的默认用户名是pi，密码是raspberry 。(一般要等一下，不会立即出来，出不来就多按几次Enter～) 如果直接拔掉串口模块，需要重新连接，需要输入 1ps -x|grep tty 得到进程号，然后通过kill命令关掉那个进程，才可以重新连接。]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dataGridView导出excel]]></title>
    <url>%2F2015%2F09%2F29%2FdataGridView%E5%AF%BC%E5%87%BAexcel%2F</url>
    <content type="text"><![CDATA[非正常方法，简单暴力使用这个函数即可（当然严格意义上来说导出的根本不是excel，只是用excel打开没问题……） 1234567891011121314151617181920212223242526272829303132//C# /// &lt;summary&gt; /// 导出excel /// &lt;/summary&gt; /// &lt;param name="dGV"&gt;&lt;/param&gt; /// &lt;param name="filename"&gt;&lt;/param&gt; private void ToCsV(DataGridView dGV, string filename) &#123; string stOutput = ""; // Export titles: string sHeaders = ""; for (int j = 0; j &lt; dGV.Columns.Count; j++) sHeaders = sHeaders.ToString() + Convert.ToString(dGV.Columns[j].HeaderText) + "\t"; stOutput += sHeaders + "\r\n"; // Export data. for (int i = 0; i &lt; dGV.RowCount - 1; i++) &#123; string stLine = ""; for (int j = 0; j &lt; dGV.Rows[i].Cells.Count; j++) stLine = stLine.ToString() + Convert.ToString(dGV.Rows[i].Cells[j].Value) + "\t"; stOutput += stLine + "\r\n"; &#125; Encoding utf16 = Encoding.GetEncoding("gb2312"); byte[] output = utf16.GetBytes(stOutput); FileStream fs = new FileStream(filename, FileMode.Create); BinaryWriter bw = new BinaryWriter(fs); bw.Write(output, 0, output.Length); //write the encoded file bw.Flush(); bw.Close(); fs.Close(); &#125; 然后在要保存的地方调用下面这堆东西就可以了 12345678910//C# //导出excelSaveFileDialog sfd = new SaveFileDialog();sfd.Filter = "Excel Documents (*.xls)|*.xls";sfd.FileName = "export.xls";if (sfd.ShowDialog() == DialogResult.OK)&#123;//ToCsV(dataGridView1, @"c:\export.xls");ToCsV(this.parameter_grid, sfd.FileName); // Here dataGridview1 is your grid view name&#125; 正常方法微软原生Excel库一个是使用office原生接口，但是这种方法要求太高。如果用户的电脑上没有安装对于版本的office Excel或者用户装了盗版的office都不能使用。。所以这种方法并没有什么卵用。。。 但是！！现在有了一种新的方法，不管用户的电脑上有没有装excel，装了哪个版本的excel，都可以完美的导出excel表格，这个方法就是使用一款神奇的第三方库—NPOI NPOINPOI具体使用方法点这里这里就不详细说了，简单说下怎么用。 下载首先到http://npoi.codeplex.com/官网上下载NPOI的dll，有2和4两个不同版本的dll，分别对应不同的.NET版本，我在自己的项目中使用了4版本的.NET。 添加引用右键项目 -&gt;添加-&gt;引用,如图 然后点击浏览，把刚才下载好的dll选中添加到项目中（建议把dll文件夹直接放倒项目根目录下） 简单使用12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt; /// 导出excel /// &lt;/summary&gt; /// &lt;param name="dt"&gt;&lt;/param&gt; /// &lt;param name="filePath"&gt;&lt;/param&gt; private void WriteExcel(DataGridView dt, string filePath) &#123; if (!string.IsNullOrEmpty(filePath) &amp;&amp; null != dt &amp;&amp; dt.Rows.Count &gt; 0) &#123; NPOI.HSSF.UserModel.HSSFWorkbook book = new NPOI.HSSF.UserModel.HSSFWorkbook(); NPOI.SS.UserModel.ISheet sheet = book.CreateSheet("export"); NPOI.SS.UserModel.IRow row = sheet.CreateRow(0); for (int i = 0; i &lt; dt.Columns.Count; i++) &#123; row.CreateCell(i).SetCellValue(dt.Columns[i].HeaderText); &#125; for (int i = 0; i &lt; dt.Rows.Count; i++) &#123; NPOI.SS.UserModel.IRow row2 = sheet.CreateRow(i + 1); for (int j = 0; j &lt; dt.Columns.Count; j++) &#123; row2.CreateCell(j).SetCellValue(Convert.ToString(dt.Rows[i].Cells[j].Value)); &#125; &#125; // 写入到客户端 using (System.IO.MemoryStream ms = new System.IO.MemoryStream()) &#123; book.Write(ms); using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write)) &#123; byte[] data = ms.ToArray(); fs.Write(data, 0, data.Length); fs.Flush(); &#125; book = null; &#125; &#125; &#125; 通过调用saveFileDialog就可以导出excel了，完美解决～ 1234567891011//导出excel private void button_excel_Click(object sender, EventArgs e) &#123; SaveFileDialog sfd = new SaveFileDialog(); sfd.Filter = "Excel Documents (*.xls)|*.xls"; sfd.FileName = "export.xls"; if (sfd.ShowDialog() == DialogResult.OK) &#123; this.WriteExcel(this.site_grid, sfd.FileName); &#125; &#125;]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks使用教程]]></title>
    <url>%2F2015%2F09%2F24%2FShadowsocks%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Shadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。 Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。 在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。 但是如果人在国外，就可以反过来，通过国内的服务器去下载和访问一些“有版权问题”的资源。由于传输数据被加密过，外国政府一般不可能知道你下载或者访问了什么，只知道你链接了一个中国的服务器(当然，如果用了什么好莱坞电影里面那种黑科技查出来了我也没办法……） Windows端先到这里下载windows客户端https://github.com/shadowsocks/shadowsocks-windows/releases 然后，解压，双击打开 填入地址密码端口号等信息，然后点击确定 然后在通知栏找到小飞机标志，打开全局模式，打开代理就可以正常使用了（如图： Mac端 先从这里下载程序https://github.com/shadowsocks/shadowsocks-iOS/releases 然后双击下载文件，将程序拖入Applications中 之后在lunchpad中找到ShadowsocksX，点击运行，可以在电脑右上角看到这个标志 点击“Servers”-&gt; “Open Server Preferences” 点击“➕”号添加一个服务器 填入地址密码端口号等信息，然后点击OK 然后选全局模式，打开Shadowsocks，就可以用了 服务器是阿里云顶配，100M带宽，下东西嗖嗖嗖的 网易音乐等东西也可以正常用，跟国内一样]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家庭贫困说明]]></title>
    <url>%2F2015%2F09%2F23%2F%E5%AE%B6%E5%BA%AD%E8%B4%AB%E5%9B%B0%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Bazinga12级软件工程 我从大山里来第一次来到广州这种大城市从来没有坐过地铁的我第一次坐地铁就是在广州 家里很穷，开的是最便宜的法拉利 ——F430虽然后面出了新款的458、488、LaFerrari但是由于没钱都没买 家里住的是昆明最偏远的房子，连公交车都没有每次出门都只能开车如果没有车就相当于被困在了这里……家离最近的便利店有5公里路也就是说，如果没有车连饭都没得吃我就是在这种艰苦的环境下长大的 每次放假回家我都会帮父母干很多活每天早上起来要喂鱼然后要打理下花园，把杂草除掉，把树叶捡起来扔掉如果到了暑假,每天下午要坐在院子里不然家里的无花果啊，石榴啊，樱桃啊，都会被外面的小松鼠偷走然后我就又没得吃的了 我很喜欢养宠物我曾经养过两只乌龟，一只兔子，一只鸭子，一条狗和一盆仙人掌最开始养的兔子被我吃了后来养的鸭子也被窝吃了再后来开始养乌龟，但是乌龟得了软骨病死了于是我就决定开始养狗但是有一天狗自己跑路了现在还没找到最后，我想，我养仙人掌总可以吧……我就养了一盆仙人掌每天给它浇水然后它就死了。。由于家庭困难我什么都没有养活过作为独生子我感到十分的孤独 其实云南是个教育很不发达的地方虽然我生活在昆明但是昆明的教育资源其实也不均衡为了改善教育情况云南省政府组织了一次交换生活动通过各种考试和面试可以去美利坚读一年书于是我就幸运的通过了所谓考试和面试然后我惊讶的发现一起过了的好像并不会说英语但是他们有个无与伦比的优势被选了进来那就是有钱他们被分到了白人聚居区平时可以郊游party过着淫乱的生活但是我去的是墨西哥移民聚居区但不管怎样我还是可以去美利坚读书了 然而到了那里我才发现这哪里是美利坚这完全是墨西哥这里的人整天和大麻军火打交道每个月不出点枪击案那简直太不正常了于是我就在担惊受怕中度过了一年也就是这一年造就我坚韧不拔的品质让我学会了在逆境中生存教会了我面对困难要不抛弃不放弃 于是 虽然我大一刚进学校的时候在班上排倒数经过一年的努力我还是排倒数到了大二我决定加倍的努力，好好学习一年后我还是排倒数终于到了大三完成了屌丝逆袭混到了班级前三 所以要不学校发我个国励鼓励下我吧大山里的孩子不容易啊 玩笑而已，不会申请国励，大家别当真]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用破解软件]]></title>
    <url>%2F2015%2F09%2F16%2Fwindows%E5%B8%B8%E7%94%A8%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[其实在天朝还是很幸福的，学习成本太低了，低到不要钱就能搞到所有东西～ win7激活工具下载下来直接点击激活就好 win10激活工具下载下来一键激活 office2010激活工具使用方法：参考百度经验]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C＃使用sqlite数据库]]></title>
    <url>%2F2015%2F09%2F16%2FC%EF%BC%83%E4%BD%BF%E7%94%A8sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[环境：Mac win7虚拟机，vs2013 首先下载安装Sqlite ADO.NET(有很多版本，我用的是1.0.93) 下载下来一路next就可以安装好。 然后在工程里面添加引用system.data.sqlite.dll和SQLite.Interop.dll。我电脑里面这两个文件在C:\Program Files (x86)\System.Data.SQLite\2013\bin。 然后添加using System.Data.SQLite;就可以用了。 具体增删查改操作创建数据库文件在根目录下创建一个sqlite文件 123456789//C#public static SQLiteConnection getDatabase()&#123; SQLiteConnection conn = null; string dbPath = "Data Source =" + Environment.CurrentDirectory + "/test.db"; conn = new SQLiteConnection(dbPath);//创建数据库实例，指定文件位置 return conn; &#125; 建表123456789101112//C#private void createTable()&#123; SQLiteConnection conn = getDatabase(); conn.Open();//打开数据库，若文件不存在会自动创建 string sql = "CREATE TABLE IF NOT EXISTS testTable(id integer primary key,a text,b text,c text);";//建表语句 SQLiteCommand cmdCreateTable = new SQLiteCommand(sql, conn); cmdCreateTable.ExecuteNonQuery();//如果表不存在，创建数据表 conn.Close();&#125; 增12345678910//C#private void insertIntoDatabase() &#123; SQLiteConnection conn = getDatabase(); conn.Open(); SQLiteCommand cmdInsert = new SQLiteCommand(conn); cmdInsert.CommandText = "INSERT INTO testTable(a,b,c) VALUES(1,2,3)";//插入数据 cmdInsert.ExecuteNonQuery(); conn.Close(); &#125; 删123456789101112//C#private void deleteFromDatabase(int a) &#123; SQLiteConnection conn = getDatabase(); conn.Open(); string sql = "delete from testTable where id = " + a; SQLiteCommand cmdInsert = new SQLiteCommand(conn); cmdInsert.CommandText = sql; cmdInsert.ExecuteNonQuery(); conn.Close(); &#125; 查1234567891011121314151617181920//C#public void readNameFromDatabase() &#123; SQLiteConnection conn = getDatabase(); conn.Open();//打开数据库，若文件不存在会自动创建 string sql = "select id name from testTable"; SQLiteCommand cmdQ = new SQLiteCommand(sql, conn); SQLiteDataReader reader = cmdQ.ExecuteReader(); while (reader.Read()) &#123; int id = reader.GetInt32(0); string a = reader.GetString(1); string b = reader.GetString(2); string c = reader.GetString(3); //……………… &#125; conn.Close(); // Console.ReadKey(); &#125; 改123456789101112//C#private void updateDatabase(int a) &#123; SQLiteConnection conn = getDatabase(); conn.Open(); string sql = "update testTable set a = 5,b = 6,c = 7 where id = " + a; SQLiteCommand cmdInsert = new SQLiteCommand(conn); cmdInsert.CommandText = sql; cmdInsert.ExecuteNonQuery(); conn.Close(); &#125; 跟iOS上sqlite用法好像啊……]]></content>
      <tags>
        <tag>sqlite</tag>
        <tag>C＃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加百度统计]]></title>
    <url>%2F2015%2F09%2F16%2Fhexo%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[litten的主题yilia 编辑文件 themes/yilia/_config.yml ,添加一行配置，可以删除原来的google analytics 1baidu_tongji: true 新建 themes/yilia/layout/_partial/baidu_tongji.ejs 内容如下 12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type="text/javascript"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt; 编辑themes/yilia/layout/_partial/head.ejs 在 &lt;/head&gt; 前添加 1&lt;%- partial("baidu_tongji") %&gt; 重新生产部署站点即可。 Light主题 编辑文件 themes/light/_config.yml ,添加一行配置，可以删除原来的google analytics 1baidu_tongji: true 新建 themes/light/layout/_partial/baidu_analytics.ejs 内容如下 12345&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type="text/javascript"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt; 编辑themes/light/layout/_partial/head.ejs 在 &lt;/head&gt; 前添加 1&lt;%- partial("baidu_tongji") %&gt; 重新生产部署站点即可。 其他主题应该都一样吧～我猜的因为我也没试过……不过前段时间出了那件事……Github不能访问……貌似跟这段js有点关系。具体我也不知道，反正我现在开始用腾讯统计了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUICatalog：Invalid asset name supplied：(null)]]></title>
    <url>%2F2015%2F09%2F07%2FCUICatalog%EF%BC%9AInvalid-asset-name-supplied%EF%BC%9A-null%2F</url>
    <content type="text"><![CDATA[今天遇到了个神奇的问题： 122015-09-06 14:32:32.246 B-smart[1056:65917] CUICatalog: Invalid asset name supplied: (null)2015-09-06 14:32:32.246 B-smart[1056:65917] Could not load the &quot;(null)&quot; image referenced from a nib in the bundle with identifier &quot;com.scut.B-smart&quot; 查了下，这个提示的意思是说你用了这个方法：[UIImage imageNamed:name];但是这个name却是空的，所以就报了这个错了。 解决方法，在项目中搜索[UIImage imageNamed:,然后打印看看所谓的name是否为空。找到后替换。]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在自己的app中打开其他app]]></title>
    <url>%2F2015%2F09%2F01%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84app%E4%B8%AD%E6%89%93%E5%BC%80%E5%85%B6%E4%BB%96app%2F</url>
    <content type="text"><![CDATA[这个动作通过iOS URL schemes完成，每个程序都有一个URL schemes。 通过openURL就可以打开相应的应用了。openurl()里面填上对应程序的URL。 12//swiftUIApplication.sharedApplication().openURL(NSURL(string: "…………")!) 12//OC[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"…………"]] 比如拨打电话： 12//swiftUIApplication.sharedApplication().openURL(NSURL(string: "tel://1234567890")!) 打开其他应用的url你所知道好玩有趣的 iOS URL schemes 有哪些？（我只是搬运工） 应用 url QQ的url mqq:// 微信 weixin:// 淘宝 taobao:// 点评 dianping:// dianping://search 微博 sinaweibo:// 名片全能王 camcard:// weico微博 weico:// 支付宝 alipay:// 豆瓣fm doubanradio:// 微盘 sinavdisk:// 网易公开课 ntesopen:// 美团 imeituan:// 京冬 openapp.jdmoble:// 人人 renren:// 我查查 wcc:// 1号店 wccbyihaodian:// 有道词典 yddictproapp:// 知乎 zhihu:// 优酷 youku:// 其中，微信的有 url 功能 weixin://dl/scan 扫一扫 weixin://dl/feedback 反馈 weixin://dl/moments 朋友圈 weixin://dl/settings 设置 weixin://dl/notifications 消息通知设置 weixin://dl/chat 聊天设置 weixin://dl/general 通用设置 weixin://dl/officialaccounts 公众号 weixin://dl/games 游戏 weixin://dl/help 帮助 weixin://dl/feedback 反馈 weixin://dl/profile 个人信息 weixin://dl/features 功能插件 在自己的程序里面添加iOS URL schemes先在info.plist添加如下属性（这个地方和网上的教程有很大的不同，多了很多功能，我也不是很清楚具体代表什么）。点击工程 -&gt;info -&gt;URL Types。 注意, 这里的URL Schemes必填， URL identifier选填。另外，URL Schemes建议都小写，因为之后接收到数据的时候，不区分大小写， 都是转为小写。 然后在Appdelegate.swift中添加如下代码。 1234567891011121314//swift func application(application: UIApplication, handleOpenURL url: NSURL) -&gt; Bool &#123; println(url) if (url.scheme == "urltest")&#123; let text = url.host?.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) var alert:UIAlertView = UIAlertView() alert.addButtonWithTitle("OK") alert.title = "title" alert.message = text alert.show() return true &#125; return false &#125;]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性的特性]]></title>
    <url>%2F2015%2F08%2F19%2F%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[任何属性都有一组特性，用于描述相应存取方法的行为，如下 12//OC@property (nonatomic, readwrite, strong) NSString *name; 多线程特性多线程特性有两种可选类型：nonatomic和atomic，分别代表单线程和多线程。 nonatomic不是默认类型所以在声明属性时必须明确的写出nonatomic。 读/写特性读/写特性也有两种可选类型：readwrite和readonly,分别代表读写和只读。其中readwrite 是默认类型。 内存管理特性内存管理特性有四种可选类型：strong、weak、 copy、 unsafe_unretained，这些类型决定相应的实例变量将如何引用对象。 strong为默认类型。ARC自动＋1。 weak是为了避免引用循环。对象销毁指针也自动销毁。 copy类似于下面这个代码，它会将传入的值先复制一遍，_name指向新的复制的对象。 12345//OC-(void)setName:(NSString *)name&#123; _name = [name copy];&#125; 这样做是因为，如果熟悉指向的对象类有可修改的子类，那么属性可能会指向可修改的子类对象，同时该对象可能会被其他拥有者修改，因此先复制该对象，再将属性指向复制后的对象。 unsafe_unretained这种类型指针指向的对象被销毁时，指针不会自动设置为nil，而是成为空指针，所以不安全。]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控件运动效果]]></title>
    <url>%2F2015%2F08%2F18%2F%E6%8E%A7%E4%BB%B6%E8%BF%90%E5%8A%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[运动效果就是利用加速度传感器，当你在左右摇手机的时候控件也在跟着左右动。（好像除了装逼没什么卵用啊～） 比如将一个_button的添加运动效果： 1234567891011//OC UIInterpolatingMotionEffect *motionEffect; motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; motionEffect.minimumRelativeValue = @(-25); //觉得不明显可以把参数改大一点 motionEffect.maximumRelativeValue = @(25); [_button addMotionEffect:motionEffect]; motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.y" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis]; motionEffect.minimumRelativeValue = @(-25); motionEffect.maximumRelativeValue = @(25); [_button addMotionEffect:motionEffect]; 一定要用真机才看得到效果]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让图片显示为一个圆]]></title>
    <url>%2F2015%2F08%2F18%2F%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9C%86%2F</url>
    <content type="text"><![CDATA[如何把图片显示为一个圆？假设这个UIImageView是一个正方形，也就是长和宽都一样…… 1234//OC CGFloat imageSize = self.imageView.bounds.size.height; self.imageView.layer.masksToBounds = YES; self.imageView.layer.cornerRadius = imageSize/2; 效果图：]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何隐藏NavigationController]]></title>
    <url>%2F2015%2F08%2F13%2F%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8FNavigationController%2F</url>
    <content type="text"><![CDATA[如何隐藏NavigationController？ 隐藏NavigationController只需要调用一个方法就可以了： 12//OCself.navigationController.navigationBar.hidden = YES; 要回复它只用把状态改为NO就好。 ScrollView或TableView向上滑动隐藏NavigationController如果是在一个ScrollView或者是一个TableView里面，想要实现向上滑动隐藏NavigationController，调用这个函数即可： 123456789101112//OC-(void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; if (velocity.y &gt; 0.0) &#123; //向上滑动隐藏导航栏 [self.navigationController setNavigationBarHidden:YES animated:YES]; &#125;else &#123; //向下滑动显示导航栏 [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125;&#125; 其中 12//OC[self.navigationController setNavigationBarHidden:YES animated:YES]; 是带有动画效果的，如果不需要动画效果可以直接用 12//OCself.navigationController.navigationBar.hidden = YES; 不过应该不会有人不想用动画效果吧 效果图： 当然从效果图来看这样实现并不好，因为StatusBar和tableView的内容重合了，现在可以做一点优化。 在viewDidLoad里面添加： 12//OC[self setNeedsStatusBarAppearanceUpdate]; 添加一个函数： 123456//OC- (UIStatusBarStyle)preferredStatusBarStyle&#123; return UIStatusBarStyleLightContent;&#125; 效果图： 那如果要”保留”StatusBar要怎么做呢？ 网上查了一下，有一个思路是把NavigationController的高度降为22，这样看起来就像是保留了StatusBar。 123456789101112131415161718192021222324252627282930313233//OC@property (assign, nonatomic)BOOL isHidden;//…………-(void)showNavigationController&#123; if (self.isHidden) &#123; CGRect frame = self.navigationController.navigationBar.frame; frame.origin.y = 20; [UIView animateWithDuration:0.2 animations:^&#123; self.navigationController.navigationBar.frame = frame; [self.item setTitle:@"item"]; self.title = @"Title"; &#125;]; self.isHidden= NO; &#125;&#125;-(void)hideNavigationController&#123; if (!self.isHidden) &#123; CGRect frame = self.navigationController.navigationBar.frame; frame.origin.y = -24; [UIView animateWithDuration:0.2 animations:^&#123; self.navigationController.navigationBar.frame = frame; // 隐藏navigationController上的控件 [self.item setTitle:@""]; self.title = @""; &#125; completion:nil]; self.isHidden=YES; &#125;&#125; 然后修改下scrollViewWillEndDragging就可以了 12345678910111213//OC-(void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; if (velocity.y &gt; 0.0) &#123; //向上滑动隐藏导航栏 [self hideNavigationController]; &#125;else &#123; //向下滑动显示导航栏 [self showNavigationController]; &#125;&#125; 效果图： 代码下载 Xcode6.4 ##iOS8之后12//objective-cself.navigationController.hidesBarsOnSwipe = YES; 12//swiftself.navigationController!.hidesBarsOnSwipe = true;]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何区分UITableView里的UITextField（UIButton）]]></title>
    <url>%2F2015%2F08%2F13%2F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86UITableView%E9%87%8C%E7%9A%84UITextField%E5%92%8CUIButton%2F</url>
    <content type="text"><![CDATA[如果tableView里面添加了TextField，如何知道每一个TextField的值呢？ 如果是静态的tableView就可以用control－drag大法（从View相应控件按住control键拖到controller上）。 但是如果是动态的呢？ 不能用control－drag，因为cell都是重用的的，这样没发知道是哪一个TextField，就算你这么做了系统也会报错。 这时可以用这个方法：把每个textField的tag赋值，通过不同的Tag区分不同的textField 示例代码首先肯定是要自定义一个custom cell,我是这样定义的：新建一个TableViewCell类继承UITableViewCell，然后在里面定义了label和textField 然后就新建一个UITableView，(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法里面这样定义： 12345678910111213//OC- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell" forIndexPath:indexPath]; cell.label.text = [NSString stringWithFormat: @"%ld ", (long)indexPath.row ]; /** * 每个textField的tag对应每行的序号 */ cell.textFiedl.tag = indexPath.row; cell.textFiedl.delegate = self; cell.textFiedl.text = self.array[indexPath.row]; return cell;&#125; 这样就相当于给每个textField分了不同的tag值。 然后，通过(void)textFieldDidEndEditing:(UITextField *)textField方法获得每次输入完之后对应textField的值： 12345//OC-(void)textFieldDidEndEditing:(UITextField *)textField&#123; self.array[textField.tag] = textField.text; NSLog(@"%@",self.array);&#125; 代码下载（OC Xcode6.4） 当然有人会问了，如果cell里面放了button怎么办？button没有对应的带代理法呀？ 很简单，其实也是通过tag值区分，只是在(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath方法里面加多一行代码，比如我定义了一个saveButton: 123456789101112//OC- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell" forIndexPath:indexPath]; /** * 每个textField的tag对应每行的序号 */ cell.saveButton.tag = indexPath.row; [cell.saveButton addTarget:self action:@selector(saveAction) forControlEvents:UIControlEventTouchUpInside]; return cell;&#125; 这样每次点击了saveButton都会运行一遍saveAction 我们在saveAction里面区分tag值就可以知道点击了哪个button。 12345678//OC-(void)saveAction:(UIButton*)sender&#123; if (sender.tag == 0) &#123; // ……… &#125;&#125; 当然使用前也要自定义一个custom cell]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIAlertController]]></title>
    <url>%2F2015%2F08%2F10%2FUIAlertController%2F</url>
    <content type="text"><![CDATA[ios8新推出了一个东西叫UIAlertController，用来代替以前的UIAlertView和UIActionSheet。 以前UIAlertView和UIActionSheet是这样用的 但是现在不管是UIAlertView还是UIActionSheet，都要通过UIAlertController来实现。（当然以前的UIAlerView和UIActionSheet都还可以用，如果只需要支持IOS8以上点机型可以放心大胆的用UIAlertController。） 首先要声明一个UIAlertController： 12//OCUIAlertController *alertController = nil； 然后初始化，如果需要UIAlertView的效果就初始化为：UIAlertControllerStyleAlert；如果需要UIActionSheet的效果就初始化为：UIAlertControllerStyleActionSheet 1234567//OC//UIAlertView效果初始化alertController = [UIAlertController alertControllerWithTitle:@"Title" message:@"message" preferredStyle:UIAlertControllerStyleAlert];//UIActionSheet效果初始化alertController = [UIAlertController alertControllerWithTitle:@"Title" message:@"message" preferredStyle:UIAlertControllerStyleActionSheet]; 然后以前添加button的各种函数全都没有了，改成了添加action，每一个action对应一个button。 每个UIAlertAction都带有一个handler，可以通过block处理点击事件。以前是用代理，现在不用了，感觉更科学了。 12345678910111213141516171819//OC /** * UIAlertAction 表示一个按钮，同时，这个按钮带有处理事件的block * */ UIAlertAction *action = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123; NSLog(@"点击取消"); &#125;]; [alertController addAction:action]; /** * 添加需要谨慎操作的按钮，文字默认是红色的 */ [alertController addAction:(&#123; UIAlertAction *action = [UIAlertAction actionWithTitle:@"谨慎操作的按钮" style:UIAlertActionStyleDestructive handler:^(UIAlertAction *action) &#123; NSLog(@"谨慎操作的按钮"); &#125;]; action; &#125;)]; 如果要添加输入框要先做个判断，actionSheet是没有办法添加的，强行添加会崩溃 123456789101112131415161718//OC /** * 添加输入框到alertView中，注意，actionSheet是没有办法添加textField的，强行添加会Crash */ if (alertController.preferredStyle == UIAlertControllerStyleAlert) &#123; // 添加用户名输入框 [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123; // 给输入框设置一些信息 textField.placeholder = @"请输入用户名"; textField.textAlignment = NSTextAlignmentCenter; &#125;]; // 添加密码输入框 [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123; textField.placeholder = @"请输入密码"; textField.secureTextEntry = YES; textField.textAlignment = NSTextAlignmentCenter; &#125;]; &#125; 最后显示 12//OC[self presentViewController:alertController animated:YES completion:nil]; actionSheet在iPad上崩溃问题昨天试了下，在iPhone上actionSheet可以很流畅的运行，但是在iPad上运行就会崩溃，报这个错误： Terminating app due to uncaught exception ‘NSGenericException’, reason: ‘Your application has presented a UIAlertController (&lt;UIAlertController: 0x7f9831f2a690&gt;) of style UIAlertControllerStyleActionSheet. The modalPresentationStyle of a UIAlertController with this style is UIModalPresentationPopover. You must provide location information for this popover through the alert controller’s popoverPresentationController. You must provide either a sourceView and sourceRect or a barButtonItem. If this information is not known when you present the alert controller, you may provide it in the UIPopoverPresentationControllerDelegate method -prepareForPopoverPresentation.’ 看得我云里雾里，里面这些controller好像闻所未闻……后来在stackoverflow上找到了解决方案，只需要加一段代码，申明一个UIPopoverPresentationController就可以了： 123456//OC UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Title" message:@"message" preferredStyle:UIAlertControllerStyleActionSheet]; UIPopoverPresentationController *popoverController = alertController.popoverPresentationController; popoverController.sourceView = sender; popoverController.sourceRect = [sender bounds]; [self presentViewController:alertController animated:YES completion:nil]; 如果你的按钮是个barButton要用下面这段代码👇 12345//OCUIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Title" message:@"message" preferredStyle:UIAlertControllerStyleActionSheet];UIPopoverPresentationController *popoverController = alertController.popoverPresentationController;popoverController.barButtonItem = sender[self presentViewController:alertController animated:YES completion:nil]; 效果图： 如何在actionSheet上加一个UIPickerView我在某论坛看到过苹果似乎不建议这么做，但是我还是本着生命在于折腾人生信条折腾了一个： 12345678910111213141516//OC UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"\n\n\n\n\n\n\n\n\n\n\n" message:nil preferredStyle:UIAlertControllerStyleActionSheet]; UIDatePicker *picker = [[UIDatePicker alloc] init]; [picker setDatePickerMode:UIDatePickerModeDate]; [alertController.view addSubview:picker]; [alertController addAction:(&#123; UIAlertAction *action = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123; NSLog(@"OK"); NSLog(@"%@",picker.date); &#125;]; action; &#125;)]; UIPopoverPresentationController *popoverController = alertController.popoverPresentationController; popoverController.sourceView = sender; popoverController.sourceRect = [sender bounds]; [self presentViewController:alertController animated:YES completion:nil]; 苹果并不建议在ActionSheet里面添加UIPickerView，所以才会写出如此诡异的代码……这么写是为了流出足够的面积来放pickerView。 123//OCUIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"\n\n\n\n\n\n\n\n\n\n\n" message:nil preferredStyle:UIAlertControllerStyleActionSheet]; 效果图：]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信空白朋友圈是怎么回事]]></title>
    <url>%2F2015%2F08%2F07%2F%E5%BE%AE%E4%BF%A1%E7%A9%BA%E7%99%BD%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[自从今天下午院草发了一条空白朋友圈，便引来无数跟风者，许多人一边被刷屏，一边好奇这究竟是怎么发出来的。 院草先是误导大家这是个纯手速问题，于是我尝试了下自己的手速，发现完全跟不上 然后经过永盛大神指点，终于发出来了： 于是各路豪杰争先恐后的开始发空白朋友圈 其中不乏不忘装个逼的邹哲鹏 当然也有不明真相的广东省武术冠军，受院草蛊惑，真的怀疑自己手速有问题😂 经过我的研究，其实这不是微信的问题一开始我猜想微信应该是用了苹果标准的开发方法，在navigationController里面添加了一个barButton，然后使用了Xcode自动创建的按钮点击事件。 于是我自己写了一个DEMO，其中写了类似于微信的判断，当没有输入文字的时候禁用barButton。所以没有文字的时候是绝对无法点击按钮显示消息的。 果然，跟微信一样，输入一个字母，按住发送键，然后再删除那个字母，松开发送键，消息还是显示了！！说明我的猜想应该是对的～～ 当然这也不能怪微信，毕竟这是苹果自动创建的方法，谁写都是这样的。没有设计师会考虑到可以用这种方法发送空白消息，也不知道是谁闲的蛋疼发现的这个问题。（当然，不可能是院草李八千，因为他忙着泡妞不会闲） 那么有没有办法防止发送空白消息呢？答案是有的，不然我也不会那么晚来写这篇文章了…… 大概思路就是重写苹果的点击事件。一个点击事件对应一对touchDown和touchUp事件，分别代表手指按下去的状态和手指离开屏幕的状态。我们要做的就是只要手指按下去就立即发送信息，这样无论那人手速有多快都不可能发送空白消息了！！ 但是navigationController的专用控件UIBarButton没有判断Button状态的函数，所以只能用Button代替BarButton。然后重写点击方法 12345678910//swiftoverride func viewDidLoad() &#123; …………… Button.addTarget(self, action: "touchDownAction", forControlEvents: UIControlEvents.TouchDown) ………… …………&#125;func touchDownAction()&#123; //按钮按下时的动作 &#125; 效果： 代码下载（swift1.2 Xcode6.4） 后来借了台安卓机，发现貌似安卓不能发这个，好像每次删除了字符就会刷新button的状态。至于IOS为什么会这样也只是我猜的，是不是真的要看IOS源码才知道，所以一切真相只能等到IOS开源了～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何隐藏键盘]]></title>
    <url>%2F2015%2F08%2F06%2F%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[在手机上每次输入键盘都会自动打开，但是输入完之后键盘确不会自动隐藏。我感觉这是个蛋疼的设计，苹果干嘛不直接写个像UIActionSheet那样的东西，点击背景就可以隐藏键盘。不过IOS是高手设计的，高手写的东西自有它存在的道理，我等渣渣还是以后再去揣摩吧…… 有两种方法可以实现隐藏键盘： 1234//OC[self.view endEditing:true];[textField resignFirstResponder]; 其中[self.view endEditing:true];可以让整个view取消所有第一响应者；[textField resignFirstResponder];只可以让那个相应的textField取消第一响应。 FirstResponder第一响应对象指的是窗口中，应用程序认为最适合处理事件的对象。当点击了textFiled之后，textField就成为了第一响应对象。这时键盘就会弹出来。 然后有几种实现方式 第一种：调用touchesBegan函数1234//OC-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_textField resignFirstResponder];&#125; 第二种：在背景上自定义一个手势1234567891011//OC- (void)viewDidLoad &#123; [super viewDidLoad]; _textField.delegate = self; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector(tapAction)]; [self.view addGestureRecognizer:tap];&#125;- (void)tapAction&#123; [_textField resignFirstResponder];&#125; 现在点击背景就可以隐藏键盘了 第三种：通过点击return键隐藏键盘按下键盘的return键会调用-(void)textFieldDidEndEditing:(UITextField *)textField这个方法，所以通过这个方法也可以实现键盘的隐藏 1234//OC-(void)textFieldDidEndEditing:(UITextField *)textField&#123; [_textField resignFirstResponder];&#125; 或者 1234567//OC-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; if ([string isEqualToString:@"\n"])&#123; [textField resignFirstResponder]; &#125; return YES;&#125; 效果图： 最后注意，textField要设置代理 _textField.delegate = self;]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB]]></title>
    <url>%2F2015%2F08%2F05%2FFMDB%2F</url>
    <content type="text"><![CDATA[IOS中原生的SQLite API十分不友好，对于我这种菜鸟来说简直不能用，于是就有大神写了封装了SQLite API的库，比如FMDB,https://github.com/ccgus/fmdb。 安装方法可以在官网上看，我是直接用了cocoaPods。如果是swift项目要直接把fmdb文件夹下的这些文件拖到你的项目中 然后Xcode会自动新建一个桥接文件（bridge），然后在那个文件添加一行 12//OC#import "FMDB.h" 就可以用了。 OC直接添加#import &quot;FMDB.h&quot;就可以。 用之前需要在General的Linked Frameworks and Libraries里面添加libsqlite3.0.dylib，不然会报错（而且是30多个）！ 创建FMDatabase需要指定一个路径，通过下面这条语句实现。 12//OCFMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/tmp.db"]; 不过既然是用数据库，那一般都是要持久化的存储，那么这个sqlite文件应该放到Document文件夹下。所以一般我是这么创建的（其实貌似也是标准的创建方法）： 1234//OCNSString *documentsDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString* databasePath = [documentsDirectory stringByAppendingPathComponent: @"test.sqlite"]; FMDatabase* db = [FMDatabase databaseWithPath:databasePath]; 1234//swiftlet documentsFolder = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as Stringlet path = documentsFolder.stringByAppendingPathComponent("test.sqlite")let database = FMDatabase(path: path) 里面的@&quot;user.sqlite&quot;，是sqlite文件的名字，随你怎么叫。然后就可以拿着这个db做增删查改的活了。 创建数据库：123456789//OCif (![db open]) &#123; NSLog(@"Could not open db."); &#125;NSString *sql = @"create table test(x text, y text, z text)"; if (![db executeUpdate:sql] ) &#123; NSLog(@"create table failed: %@",[db lastErrorMessage]); &#125; [db close]; 1234567//swift if database.open() &#123; if !database.executeUpdate("create table if not exists test(x text, y text, z text)", withArgumentsInArray: nil) &#123; println("create table failed: \(database.lastErrorMessage())") &#125; database.close() &#125; 增加一行数据：12345678//OC if (![db open]) &#123; NSLog(@"Could not open db."); &#125; if (![db executeUpdate:@"insert into test(x, y, z) values (? , ?, ?)",@"a",@"b",@"c"]) &#123; NSLog(@"insert 1 table failed: %@", [db lastErrorMessage]); &#125; [db close]; 1234567//swift if database.open() &#123; if !database.executeUpdate("create table if not exists test(x text, y text, z text)", withArgumentsInArray: nil) &#123; println("create table failed: \(database.lastErrorMessage())") &#125; database.close() &#125; 注意参数必须是NSObject的子类，所以什么int,double,bool都需要封装 比如官网上的例子： 12345//OC// 错误，42不能作为参数[db executeUpdate:@"INSERT INTO myTable VALUES (?)", 42];// 正确，将42封装成 NSNumber 类[db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:42]]; 删除一行数据：12345678//OCif (![db open]) &#123; NSLog(@"Could not open db."); &#125; if (![db executeUpdate:@"delete from test where x = ?",@"a"]) &#123; NSLog(@"delete failed: %@",[db lastErrorMessage]); &#125; [db close]; 12345678//swiftif database.open()&#123; if !database.executeUpdate("delete from test where x = ?", withArgumentsInArray: ["a"])&#123; println("delete failed: \(database.lastErrorMessage())") &#125; database.close() &#125; 查询：123456789101112//OCif (![db open]) &#123; NSLog(@"Could not open db."); &#125; FMResultSet *rs = [db executeQuery:@"select x, y, z from test"]; while (rs.next) &#123; NSString *x = [rs stringForColumn:@"x"]; NSString *y = [rs stringForColumn:@"y"]; NSString *z = [rs stringForColumn:@"z"]; NSLog(@"x = %@; y = %@; z = %@",x,y,z); &#125; [db close]; 1234567891011121314//swift if database.open()&#123; if let rs = database.executeQuery("select x, y, z from test", withArgumentsInArray: nil) &#123; while rs.next() &#123; let x = rs.stringForColumn("x") let y = rs.stringForColumn("y") let z = rs.stringForColumn("z") println("x = \(x); y = \(y); z = \(z)") &#125; &#125; else &#123; println("select failed: \(database.lastErrorMessage())") &#125; database.close() &#125; 修改：12345678//OC if (![db open]) &#123; NSLog(@"Could not open db."); &#125; if (![db executeUpdate:@"update test set y = ? where x = ?",@"00",@"a"]) &#123; NSLog(@"update falied: %@" , [db lastErrorMessage]); &#125; [db close]; 12345678//swiftif database.open()&#123; if !database.executeUpdate("update test set y = ? where x = ?", withArgumentsInArray: ["00","a"])&#123; println("update failed: \(database.lastErrorMessage())") &#125; database.close() &#125; OC示例下载swift示例下载（swift1.2；Xcode 6.4） 如果各位在用的时候FMDB发现增删查改的时候老是报 “no such table” 这种错，而且拍着胸脯表示自己绝对创建表了！！怎么可能报错说没有表！！！ 那应该是犯了跟我一样的小错误～～ 当然为了搞清楚这是怎么回事我今天从下午三点一直谷歌，百度，stackoverflow，github……到处找原因，甚至还跑去看日语，俄语的博客（当然我看不懂，只是翻翻代码）。然后我惊讶的发现，遇到跟我一样问题的人只是极少数，而且都只是提了问题后续都没有结果！ 经验告诉我，这不会是FMDB的问题只会是我自己的问题，而且是一个特别傻的问题。但是到底是什么问题我还是找不出来…… 于是我就出去理了个发。 俗话说的好，头发长见识短。理完发回来就是晚上九点了，这时的我精神焕发，思路清晰，智商比下午至少提高了7点！再次打开代码，啊！哈！果然！ ###在FMDB中，只有查询操作需要用到executeQuery，其他增删查改操作都是用executeUpdate！！！！ 这么一改果然没问题了……可怜了我的头发，现在感觉自己像个和尚😭]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用C#写一个加法计算器（二）]]></title>
    <url>%2F2015%2F08%2F02%2F%E5%A6%82%E4%BD%95%E7%94%A8C%EF%BC%83%E5%86%99%E4%B8%80%E4%B8%AA%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我用的是VS2013，windows7，苹果虚拟机。 如何用C#写一个加法计算器（一） 代码现在来讲下代码部分怎么写，双击数字 1 那个button，程序会自动跳转到另一个界面，并且帮你创建好了一个函数，这个函数是点击 button1时的监听事件，就是处理当你点了button1之后你希望程序做什么事情代码都可以写在这里。现在我们往里面加一行 textBox1.Text += &quot;1&quot;;: 12345//C#private void button1_Click(object sender, EventArgs e) &#123; textBox1.Text += "1"; &#125; 意思是点击1之后，textBox1的值会从右边多个1（我也说不清楚，自己运行体会下，语文差别怪我）。textBox1是刚刚拖到窗口上的那个textBox，由于我直接用了VS自动帮我取的名字所以这个控件叫做textBox1。补充说一句，所有控件在这里面都相当于是全局变量，在Form1.cs里面随便用的。 然后同理，把剩下的2～0的button的监听函数都改一遍。比如2就是textBox1.Text += &quot;2&quot;;，3就是textBox1.Text += &quot;3&quot;;。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//C# private void button2_Click(object sender, EventArgs e) &#123; textBox1.Text += "2"; &#125; private void button3_Click(object sender, EventArgs e) &#123; textBox1.Text += "3"; &#125; private void button6_Click(object sender, EventArgs e) &#123; textBox1.Text += "4"; &#125; private void button5_Click(object sender, EventArgs e) &#123; textBox1.Text += "5"; &#125; private void button4_Click(object sender, EventArgs e) &#123; textBox1.Text += "6"; &#125; private void button9_Click(object sender, EventArgs e) &#123; textBox1.Text += "7"; &#125; private void button8_Click(object sender, EventArgs e) &#123; textBox1.Text += "8"; &#125; private void button7_Click(object sender, EventArgs e) &#123; textBox1.Text += "9"; &#125; private void button13_Click(object sender, EventArgs e) &#123; textBox1.Text += "0"; &#125; 这里需要注意下，由于拖动控件的顺序不同，button的编号不一定代表button对应数值，如果强迫症的童鞋可以在属性那里改一下。还要说的是，应该有办法写一个监听函数，然后直接获取button上的值就可以知道用户点击哪个button了，但是我不知道那个方法，因为我 其实不会C#有谁知道可以告诉下我。 然后现在因为计算需要，需要声明两个变量来储存用户输入的第一个值和第二个值以及想进行什么运算。所以在类开头声明这三个东西：firstNumber secondNumber operation,分别代表输入的第一个数字，第二个数字，和操作符。 123456789//C# public partial class Form1 : Form &#123; String firstNumber; String secondNumber; String operation; …… …… 然后为了体现良好的编程习惯，变量都应该在程序刚运行到时候初始化，找到public Form1()，添加这些代码。public Form1()是程序自动生成的，每次程序运行都会先运行这个函数(其实我也不确定，IOS是这样所以我觉得windows也应该是这样，都说了其实我不会C#) 123456789//C# public Form1() &#123; InitializeComponent(); firstNumber = "0"; secondNumber = "0"; operation = ""; textBox1.Text = ""; &#125; 然后我们来处理下加减法。我的计算逻辑是这样的，用户先输入一个数字，然后按“＋”或者“－”号，然后再输入一个数字，然后按“＝”得到结果。 所以“＋”和“－”button的处理事件我是这样写的： 12345678910111213141516//C# //加法 private void button10_Click(object sender, EventArgs e) &#123; firstNumber = textBox1.Text; textBox1.Text = ""; operation = "+"; &#125; //减法 private void button11_Click(object sender, EventArgs e) &#123; firstNumber = textBox1.Text; textBox1.Text = ""; operation = "-"; &#125; 思路是这样，先获取用户输入的第一个数字，然后清空输入栏（textBox）内容，同时记下运算符，等待用户输入第二个数字。 ＝button的事件： 1234567891011121314151617181920//C#//等于 private void button12_Click(object sender, EventArgs e) &#123; secondNumber = textBox1.Text; switch (operation) &#123; case "+": textBox1.Text = System.String.Format("&#123;0&#125;", int.Parse(firstNumber) + int.Parse(secondNumber)); break; case "-": textBox1.Text = System.String.Format("&#123;0&#125;", int.Parse(firstNumber) - int.Parse(secondNumber)); break; default: break; &#125; firstNumber = "0"; secondNumber = "0"; operation = ""; &#125; C#的switch可以是字符串所以通过switch可以区分出操作符。然后由于获取到的firstNumber和secondNumber都是字符串格式不能直接进行计算所以要通过int.Parse()函数把它转化成int类型然后计算。计算结果由System.String.Format({0},……)函数转为字符串赋值给textBox显示。最后清空三个全局变量。 最后处理下 AC键，就是清零。那这个很简单，重置所有东西就好了： 12345678//C# private void button14_Click(object sender, EventArgs e) &#123; operation = ""; firstNumber = ""; secondNumber = ""; textBox1.Text = ""; &#125; 最后的效果就是这样： .exe下载地址代码下载地址)]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用C#写一个加法计算器（一）]]></title>
    <url>%2F2015%2F08%2F02%2F%E5%A6%82%E4%BD%95%E7%94%A8C%EF%BC%83%E5%86%99%E4%B8%80%E4%B8%AA%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我用的是VS2013，windows7。 首先，新建个项目。选择 Visual C# -&gt; windows，然后项目名称随意。 然后就会直接来到这个界面 当然有些东西可能跟我的不一样，没关系，继续看就好～～ 窗口中那个Form1就是程序窗口了，鼠标放到上面会出现这种效果，拖动边框可以任意改变它的大小。现在直接点击运行是可以跑的，只是只有个窗口，并没有什么功能…… 界面然后找到工具箱 ，如果界面上没有可以从最上面 视图 一栏找到 从工具箱中找到 Button 控件和 TextBox 控件，直接拖到窗口上（找不到可以尝试下工具箱最上面那个搜索框） 如果要改变Button的显示值，先选中那个要修改的Button，然后在属性栏修改，属性栏一般在VS的最右边，如果找不到可以从最上面 视图 一栏找到。然后修改 Text 的值 为 1。比如，现在把这个button显示值改为1。 如果要修改控件的其他属性都可以在属性栏修改。强烈建议修改（Name）的值, 因为如果只是单纯的拖控件到话，VS会自动帮你命名。第一个Button就会叫做 Button1 ，第二个就会叫做 Button2。 （你上班的时候这么命名会被组长打死 然后现在选中Button1，拖动边界把他调整到自己想要的大小。 然后同理，放更多的button到界面上来，调整为一个计算器的样子，我是调成了这样： 现在运行下就可以得到计算器的界面了，只是无论怎么点击按键都不会有用，因为后面的逻辑还没有加上。 如何用C#写一个加法计算器（二）]]></content>
      <tags>
        <tag>C＃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止输入时键盘遮住视图]]></title>
    <url>%2F2015%2F08%2F01%2F%E9%98%B2%E6%AD%A2%E8%BE%93%E5%85%A5%E6%97%B6%E9%94%AE%E7%9B%98%E9%81%AE%E4%BD%8F%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[写程序的时候如果把输入框放到这种位置，输入的时候键盘必然会挡住输入框 就像这样： 这里面用到了点击背景隐藏键盘的黑科技 所以有一种解决方法是，当点击输入框时，我们把视图升高一部分。然后当输入完成时，将视图回复原来的位置。 实现这个需要实现两个代理： 当开始输入时把界面升高216，因为键盘高度是216 123456789101112//OC- (void)textFieldDidBeginEditing:(UITextField *)textField&#123; [UIView animateWithDuration:0.3f animations:^&#123; CGRect frame = self.view.frame; /** * 键盘高度是216 */ frame.origin.y -= 216; self.view.frame = frame; &#125;];&#125; 输入完成后点击完成，再把界面降216个高度，然后隐藏键盘 1234567891011//OC- (BOOL)textFieldShouldReturn:(UITextField *)textField&#123; [UIView animateWithDuration:0.3f animations:^&#123; CGRect frame = self.view.frame; frame.origin.y +=216; self.view.frame = frame; &#125;]; [textField resignFirstResponder]; return YES;&#125; 效果是这样：]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSArray二维数组的定义]]></title>
    <url>%2F2015%2F08%2F01%2FNSArray%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[初始化使用这个方法[[NSArray alloc] initWithObjects:……,nil]; 123456//OCNSArray *arr = [[NSArray alloc] initWithObjects: [[NSArray alloc] initWithObjects: @"1",@"1",nil], [[NSArray alloc] initWithObjects: @"2",@"2",@"2",nil], [[NSArray alloc] initWithObjects: @"3",@"3",@"3",@"3",nil], ,nil]; 如果要初始化1000项，可以这样： 12345//OCNSMutableArray *arr = [[NSMutableArray alloc] initWithCapacity:1]; for (int i = 0; i&lt;1000; i++) &#123; [arr addObject:@"德玛西亚"]; &#125; 当然换成swift就超级简单了： 123456//swiftvar arr = [ ["1"], ["2","2"], ["3","3","3"] ] 初始化1000项: 12//swiftvar arr = [String](count: 1000, repeatedValue: "德玛西亚") 多维数组： 12//swiftvar arr = [[String]](count: 1000, repeatedValue: [String](count: 10, repeatedValue: "德玛西亚")) 好像每个人都是准备OC转swift，是不是只有我这个奇葩放掉了swift来重新学OC]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIColor的使用]]></title>
    <url>%2F2015%2F08%2F01%2FUIColor%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一般定义一个控件或者一个view的颜色可以这样： 12//OCself.backgroundColor = [UIColor redColor]; 或者这样： 12//OC[view setBackgroundColor:[UIColor redColor]]; 其中redColor是UIColor定义好的，直接用就好了。另外UIColor定义过的还有这些： 123456789101112131415161718192021UIColor blackColorUIColor darkGrayColorUIColor lightGrayColorUIColor whiteColorUIColor grayColorUIColor redColorUIColor greenColorUIColor blueColorUIColor cyanColorUIColor yellowColorUIColor magentaColorUIColor orangeColorUIColor purpleColorUIColor brownColorUIColor clearColorUIColor lightTextColorUIColor darkTextColorUIColor groupTableViewBackgroundColorUIColor viewFlipsideBackgroundColorUIColor scrollViewTexturedBackgroundColorUIColor underPageBackgroundColor 如果要自己定义RGB就需要用到下面的方法： 12//OCself.backgroundColor = [UIColor colorWithRed:226.0/255.0 green:231.0/255.0 blue:237.0/255.0 alpha:1.0]; 其中alpha为透明度。。。 另外如果你发现设置了自定义的RGB控件颜色并没有变，一直都是白色，你可能犯了这个错（忘记除以255……） 12//OCself.backgroundColor = [UIColor colorWithRed:226 green:231 blue:237 alpha:1.0]; 虽然错误很低级，但是我还是被它折腾了一下午 然后顺便再说一个，如果你发现控件颜色一直是黑色，可能犯了这个错： 12//OCself.backgroundColor = [UIColor colorWithRed:226/255 green:231/255 blue:237/255 alpha:1.0]; 注意要除以 255.0 而不是255。因为int/int结果还是int，而它需要一个float值～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读到牛人博客的一点感想]]></title>
    <url>%2F2015%2F07%2F30%2F%E8%AF%BB%E5%88%B0%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[今天看到了一个人的博客，感触真TM大！！！博客地址 首先我是谷歌一个IOS问题偶然间发现他的博客的，文章写的很好，完美的解决了我的问题。但是，关网页的时候瞟到了他的资料： 他居然是94年的！！！比我小了将近一年！！！然后又看到了这个： 我简直不能淡定了！！！一个还在读大学的人居然可以发200多篇原创博客！！而且访问量居然有一百多万次！！！还是在CSDN上！！！ 我之前从来没有想过人与人之间差距会那么大。 当我高考完拿到软件学院的录取通知书的时候，我就暗想自己四年之后也可以成为顶级电脑高手，随随便便在别人电脑里面翻照片。 然而仔细想想自己大一大二完全是在混日子，基本上什么都没学，而大一大二的课又那么的重要，数学、算法、数据结构、编译原理，数据库等等我什么都没学好，看看成绩就知道了，跟没学似的……以至于我现在要花时间去恶补这些科目。可能有一部分环境原因，但其实大部分都是怪我自己，怪自己对这个方向缺乏一个整体的认识，没有一个良好的职业规划，以至于自己两年来毫无目标，也不知道要干什么。 到了大三，一次偶然的机会被师兄拉过去做外包。我被分到跟郑东佳一起做IOS端的一个APP，而我那个时候完全不懂IOS，啥也没做过。师兄让我跟着郑东佳一起做。但是不久后郑东佳表示自己没时间不做了，我就挑起了做APP的大梁。由于不会就只好从头开始学。当时是跟着网易公开课上斯坦福大学的Paul Hegarty学的，IOS7开发，老头讲的很好。但是我只挑着其中一部分课程看了下，然后自己百度了一部分东西就开始写那个APP了。每天晚上都写到1、2点钟。然后在学期末终于写出了个巨恶心的APP，放到了91市场上，拿了2000块钱。然后一次偶然的机会，学院组织的一次app比赛上面用这个东西去参赛还获得了三等奖（吐槽一句，两个学期了，比赛奖金到现在都没发……什么破学院）。 当时我已经相当满足，认为自己几乎是世界上最勤奋的人了，每天花如此多时间如此多精力来做这件事，还拿着笔钱请爸妈吃了顿饭，屁股翘到了天上。其实现在想想，我之所以有这种想法完全是大一大二不良的学习习惯给我造成的错觉！！一个连App Store都没放上去到应用有什么了不起的啊，当时还当宝贝一样满世界去炫耀……当时脑子真是进水了。 到了大三下学期。由于那次学院比赛是一个创业公司赞助的，我就被拉到了这个创业公司当实习生。创业公司嘛，自然没什么老员工，老板是北大光华管理毕业的，对软件开发一窍不通。所谓实习就是他“大概想个东西”，然后我们把他实现。没有需求文档，没有架构设计。甚至到了最后快完成的时候还在往里面加界面。当然，也是来了这个公司之后我才发现自己对于IOS开发其实一窍不通，要学的东西还有很多，然后自己边写APP边学了一些东西。感觉那段时间学的东西比大一大二加起来的还要多好多倍。也是那段时间才知道自己在编程方面欠的债有多少。 那段时间腾讯、华为，阿里巴巴等大企业开始招实习生，我却自以为找到了实习连面试都没报名。其实如果我那怕报名参加了一家企业的面试，我都会知道自己到底有多差，都会被狠狠的删几个耳光，然后加倍努力的学习。但是我没有。虽然学到了很多，但是大三下学期依然是在轻松愉快中度过的，后悔已经来不及。 现在是大三到大四的暑假，而这个暑假已经过去了一半，我感觉自己依然过的浑浑噩噩，一拿起书就犯困，一写代码就想去刷微博，虽然有在学东西，但是毫无效率可言。但是我感觉我有一天一天的在改变，每天都尝试更加专注一点，每天睡觉前都反思下自己。 虽然，大学毕业前想要达到当初的期望几乎是不可能的了， 但是我会更加努力去接近那个目标！！]]></content>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS测试网络是否连接]]></title>
    <url>%2F2015%2F07%2F29%2FiOS%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[先导入一个头文件 12//OC#import &lt;SystemConfiguration/SystemConfiguration.h&gt; 然后通过调用这个函数 12345678910111213141516171819202122//OC/** * 检测是否能上网 * * @return YES说明网络已经连接；NO说明没有网络连接 */- (BOOL) isConnectionAvailable&#123; SCNetworkReachabilityFlags flags; BOOL receivedFlags; SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(CFAllocatorGetDefault(), [@"www.baidu.com" UTF8String]); receivedFlags = SCNetworkReachabilityGetFlags(reachability, &amp;flags); CFRelease(reachability); if (!receivedFlags || (flags == 0) ) &#123; return FALSE; &#125; else &#123; return TRUE; &#125;&#125; 检测函数返回值就知道了。返回true说明有网络连接，返回false说明没有网络连接。 网上找的方法，感觉就是试着访问下百度，连得上就说明网络是可以用的，连不上说明不可以………………仔细想想这个方法好像我很小的时候就会了：打开浏览器，输入百度网址，看得到就说明可以上网，然后关掉百度打开谷歌，嚯嚯嚯我那个时候真是个天才～～]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIAlertView和UIActionSheet]]></title>
    <url>%2F2015%2F07%2F28%2FUIAlertView%E5%92%8CUIActionSheet%2F</url>
    <content type="text"><![CDATA[IOS提示框大概有两种方法，一个是UIAlertView另一个是UIActionsheet。 UIAlertView:123456789101112//swift func showAlertView()&#123; var alert = UIAlertView() alert.title = "Title" alert.message = "message" //设置代理 alert.delegate = self alert.addButtonWithTitle("canel") alert.addButtonWithTitle("OK") alert.cancelButtonIndex = 0 alert.show() &#125; 12345678910111213//OC- (void)showAlerView&#123; UIAlertView *alert = [[UIAlertView alloc] init]; alert.title = @"Title"; alert.message = @"message"; ///设置代理 alert.delegate = self; [alert addButtonWithTitle:@"cancel"]; [alert addButtonWithTitle:@"OK"]; alert.cancelButtonIndex = 0; [alert show];&#125; 设置delegate需要在class后面加UIActionSheetDelegate 12//swiftclass ViewController: UIViewController ,UIAlertViewDelegate 12//OC@interface ViewController : UIViewController&lt;UIAlertViewDelegate&gt; 然后通过这个函数检测用户点击了哪个button 12345678910//swift /** UIAlerViewDelegate :param: alertView 包含所点击按钮的alert view. :param: buttonIndex 所点击的按钮在该alert view中的索引号（index），索引号从0开始 */ func alertView(alertView: UIAlertView, clickedButtonAtIndex buttonIndex: Int) &#123; &#125; 123456789//OC/** * * @param alertView 包含所点击按钮的alert view. * @param buttonIndex 所点击的按钮在该alert view中的索引号（index），索引号从0开始 */- (void) alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; NSLog(@"%ld",(long)buttonIndex);&#125; UIActionSheet:12345678910111213141516//swift func showActionSheet()&#123; var actionSheet = UIActionSheet() //设置代理 actionSheet.delegate = self actionSheet.title = "Title" actionSheet.addButtonWithTitle("cancel") actionSheet.addButtonWithTitle("Action1") actionSheet.addButtonWithTitle("destructiveButton") ///让destructiveButton变为红色,"destructiveButtonIndex" actionSheet.destructiveButtonIndex = 2 actionSheet.cancelButtonIndex = 0 actionSheet.showInView(barButton, animated: true) &#125; 1234567891011121314151617//OC- (void)showActionSheet&#123; UIActionSheet *actionSheet = [[UIActionSheet alloc] init]; ///设置代理 actionSheet.delegate = self; actionSheet.title = @"Title"; [actionSheet addButtonWithTitle:@"cancel"]; [actionSheet addButtonWithTitle:@"Action1"]; [actionSheet addButtonWithTitle:@"destructiveButton"]; ///让destructiveButton变为红色,"destructiveButtonIndex" actionSheet.destructiveButtonIndex = 2; actionSheet.cancelButtonIndex = 0; [actionSheet showInView:self.view]; &#125; 上面那个Title是通过这行代码加上去的，实在恶心…… 12//swiftactionSheet.title = "Title" 一般我不用……仔细一想我好像从来没用过～ 设置delegate需要在class后面加UIActionSheetDelegate 12//swiftclass ViewController: UIViewController ,UIActionSheetDelegate 12//OC@interface ViewController : UIViewController&lt;UIActionSheetDelegate&gt; 然后通过这个函数检测用户点击了哪个button 12345678//swift /** :param: actionSheet 包含所点击按钮的action sheet. :param: buttonIndex 所点击的按钮在该action sheet中的索引号（index），索引号从0开始 */ func actionSheet(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int) &#123; &#125; 123456789//OC/** * * @param actionSheet 包含所点击按钮的action sheet. * @param buttonIndex 所点击的按钮在该action sheet中的索引号（index），索引号从0开始 */-(void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123; &#125; 不过IOS8之后苹果又新出了个叫做UIAlertController的东西统一了UIAlertView和UIActionSheet。 写到现在终于写了一篇我自己稍微知道点的东西了😂，想写点东西怎么就那么难……]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS仿微信黑色弹出窗]]></title>
    <url>%2F2015%2F07%2F17%2FiOS%E4%BB%BF%E5%BE%AE%E4%BF%A1%E9%BB%91%E8%89%B2%E5%BC%B9%E5%87%BA%E7%AA%97%2F</url>
    <content type="text"><![CDATA[效果图： PopoverView.h 12345678910111213#import &lt;UIKit/UIKit.h&gt;@interface PopoverView : UIView-(id)initWithPoint:(CGPoint)point titles:(NSArray *)titles images:(NSArray *)images;-(void)show;-(void)dismiss;-(void)dismiss:(BOOL)animated;@property (nonatomic, copy) UIColor *borderColor;@property (nonatomic, copy) void (^selectRowAtIndex)(NSInteger index);@end PopoveView.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#import "PopoverView.h"#define kArrowHeight 10.f#define kArrowCurvature 6.f#define SPACE 2.f#define ROW_HEIGHT 44.f#define TITLE_FONT [UIFont systemFontOfSize:16]#define RGB(r, g, b) [UIColor colorWithRed:(r)/255.f green:(g)/255.f blue:(b)/255.f alpha:1.f]@interface PopoverView ()&lt;UITableViewDataSource, UITableViewDelegate&gt;@property (nonatomic, strong) UITableView *tableView;@property (nonatomic, strong) NSArray *titleArray;@property (nonatomic, strong) NSArray *imageArray;@property (nonatomic) CGPoint showPoint;@property (nonatomic, strong) UIButton *handerView;@end@implementation PopoverView- (id)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; // Initialization code self.borderColor = [UIColor blackColor]; self.backgroundColor = [UIColor clearColor]; &#125; return self;&#125;-(id)initWithPoint:(CGPoint)point titles:(NSArray *)titles images:(NSArray *)images&#123; self = [super init]; if (self) &#123; self.showPoint = point; self.titleArray = titles; self.imageArray = images; self.frame = [self getViewFrame]; [self addSubview:self.tableView]; &#125; return self;&#125;-(CGRect)getViewFrame&#123; UIWindow *window = [UIApplication sharedApplication].keyWindow; CGRect frame = CGRectZero; frame.size.height = [self.titleArray count] * ROW_HEIGHT + SPACE + kArrowHeight; for (NSString *title in self.titleArray) &#123; CGFloat width = [title sizeWithFont:TITLE_FONT constrainedToSize:CGSizeMake(300, 100) lineBreakMode:NSLineBreakByCharWrapping].width; frame.size.width = MAX(width, frame.size.width); &#125; if ([self.titleArray count] == [self.imageArray count]) &#123; frame.size.width = 10 + 25 + 10 + frame.size.width + 40; &#125;else&#123; frame.size.width = 10 + frame.size.width + 40; &#125; frame.origin.x = self.showPoint.x - frame.size.width/2; frame.origin.y = self.showPoint.y; //左间隔最小5x if (frame.origin.x &lt; 5) &#123; frame.origin.x = 5; &#125; double length; if (window.bounds.size.width &gt; 0) &#123; length = window.bounds.size.width - 5; &#125; NSLog(@"%f",length); //右间隔最小5x if ((frame.origin.x + frame.size.width) &gt; length) &#123; frame.origin.x = length - frame.size.width; &#125; return frame;&#125;-(void)show&#123; self.handerView = [UIButton buttonWithType:UIButtonTypeCustom]; [_handerView setFrame:[UIScreen mainScreen].bounds]; [_handerView setBackgroundColor:[UIColor clearColor]]; [_handerView addTarget:self action:@selector(dismiss) forControlEvents:UIControlEventTouchUpInside]; [_handerView addSubview:self]; UIWindow *window = [UIApplication sharedApplication].keyWindow; [window addSubview:_handerView]; CGPoint arrowPoint = [self convertPoint:self.showPoint fromView:_handerView]; self.layer.anchorPoint = CGPointMake(arrowPoint.x / self.frame.size.width, arrowPoint.y / self.frame.size.height); self.frame = [self getViewFrame]; self.alpha = 0.f; self.transform = CGAffineTransformMakeScale(0.1f, 0.1f); [UIView animateWithDuration:0.2f delay:0.f options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; self.transform = CGAffineTransformMakeScale(1.05f, 1.05f); self.alpha = 1.f; &#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.08f delay:0.f options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; self.transform = CGAffineTransformIdentity; &#125; completion:nil]; &#125;];&#125;-(void)dismiss&#123; [self dismiss:YES];&#125;-(void)dismiss:(BOOL)animate&#123; if (!animate) &#123; [_handerView removeFromSuperview]; return; &#125; [UIView animateWithDuration:0.3f animations:^&#123; self.transform = CGAffineTransformMakeScale(0.1f, 0.1f); self.alpha = 0.f; &#125; completion:^(BOOL finished) &#123; [_handerView removeFromSuperview]; &#125;]; &#125;#pragma mark - UITableView-(UITableView *)tableView&#123; if (_tableView != nil) &#123; return _tableView; &#125; CGRect rect = self.frame; rect.origin.x = SPACE; rect.origin.y = kArrowHeight + SPACE; rect.size.width -= SPACE * 2; rect.size.height -= (SPACE - kArrowHeight); self.tableView = [[UITableView alloc] initWithFrame:rect style:UITableViewStylePlain]; _tableView.delegate = self; _tableView.dataSource = self; _tableView.alwaysBounceHorizontal = NO; _tableView.alwaysBounceVertical = NO; _tableView.showsHorizontalScrollIndicator = NO; _tableView.showsVerticalScrollIndicator = NO; _tableView.scrollEnabled = NO; _tableView.backgroundColor = [UIColor clearColor];// _tableView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth; return _tableView;&#125;#pragma mark - UITableView DataSource-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return 1;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return [_titleArray count];&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *identifier = @"cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier]; &#125; cell.backgroundView = [[UIView alloc] init]; cell.backgroundView.backgroundColor = [UIColor blackColor];//RGB(245, 245, 245); if ([_imageArray count] == [_titleArray count]) &#123; cell.imageView.image = [UIImage imageNamed:[_imageArray objectAtIndex:indexPath.row]]; &#125; cell.textLabel.font = [UIFont systemFontOfSize:16]; cell.textLabel.text = [_titleArray objectAtIndex:indexPath.row]; cell.textLabel.textColor = [UIColor whiteColor]; if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 7.0) &#123; cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0); &#125; return cell;&#125;#pragma mark - UITableView Delegate-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; [tableView deselectRowAtIndexPath:indexPath animated:NO]; if (self.selectRowAtIndex) &#123; self.selectRowAtIndex(indexPath.row); &#125; [self dismiss:YES];&#125;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return ROW_HEIGHT;&#125;// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect&#123; [self.borderColor set]; //设置线条颜色 CGRect frame = CGRectMake(0, 10, self.bounds.size.width, self.bounds.size.height - kArrowHeight); float xMin = CGRectGetMinX(frame); float yMin = CGRectGetMinY(frame); float xMax = CGRectGetMaxX(frame); float yMax = CGRectGetMaxY(frame); CGPoint arrowPoint = [self convertPoint:self.showPoint fromView:_handerView]; UIBezierPath *popoverPath = [UIBezierPath bezierPath]; [popoverPath moveToPoint:CGPointMake(xMin, yMin)];//左上角 /********************向上的箭头**********************/ [popoverPath addLineToPoint:CGPointMake(arrowPoint.x - kArrowHeight, yMin)];//left side [popoverPath addCurveToPoint:arrowPoint controlPoint1:CGPointMake(arrowPoint.x - kArrowHeight + kArrowCurvature, yMin) controlPoint2:arrowPoint];//actual arrow point [popoverPath addCurveToPoint:CGPointMake(arrowPoint.x + kArrowHeight, yMin) controlPoint1:arrowPoint controlPoint2:CGPointMake(arrowPoint.x + kArrowHeight - kArrowCurvature, yMin)];//right side /********************向上的箭头**********************/ [popoverPath addLineToPoint:CGPointMake(xMax, yMin)];//右上角 [popoverPath addLineToPoint:CGPointMake(xMax, yMax)];//右下角 [popoverPath addLineToPoint:CGPointMake(xMin, yMax)];//左下角 //填充颜色 [[UIColor blackColor] setFill]; [popoverPath fill]; [popoverPath closePath]; [popoverPath stroke];&#125;@end import “PopoverView.h” 就可以用了调用： 12345678910- (IBAction)popOverView:(UIBarButtonItem *)sender &#123; CGPoint point = CGPointMake(sender.frame.origin.x + sender.frame.size.width/2, sender.frame.origin.y + sender.frame.size.height); //CGPoint point = CGPointMake(self.view.bounds.size.width -30, self.view.frame.origin.y + 60); NSArray *titles = @[@"item1", @"选项2", @"选项3"]; PopoverView *pop = [[PopoverView alloc] initWithPoint:point titles:titles images:nil]; pop.selectRowAtIndex = ^(NSInteger index)&#123; NSLog(@"select index:%ld", (long)index); &#125;; [pop show];&#125; 可惜不是我写的，看了网上大神后自己改的……那个神奇的keywindow是什么至今不知道]]></content>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacDown]]></title>
    <url>%2F2015%2F07%2F15%2FMacDown%2F</url>
    <content type="text"><![CDATA[我也不知道为什么我会选了这个软件，之前用过Mou，感觉不错，但是后来又删掉了。今天想重新装回Mou，但是从官网上下下来发现运行不了……然后就发现了这个软件，感觉比Mou好用，缘分啊～ MacDown官网上作者也说了为什么又要写一个Markdown编辑器 Why Another Markdown Editor? I like Mou. I write Markdown all the time, and since I use OS X on a daily basis, Mou is my go-to editor whenever I wish to generate something with markup. But I had always wanted something more. It came as a great shock when Chen Luo announced that he felt he could not actively continue the development, and wished to sell the ownership of Mou. No suitable offers surfaced (I honestly do not think there will be, either), and I decided that instead of waiting for others to do something about this, I should act myself. I don’t have nearly enough money to match Chen Luo’s purposed offer, but I do have my own pocket of tricks and some free time. So I started from scratch, spent some weekends hacking together my own solution. And this is the result. 大概意思是他自己也经常用Mou写Markdown，感觉Mou很方便。但是有一天惊讶的发现Mou的作者Chen Luo说自己已经不准备开发了而且想把要把Mou卖了(各种撕逼，评论很精彩啊)。但是作者表示自己包包里面的钱不够买（Mou拍卖底价50W 大洋），但是自己比价闲又有点程序开发基础，于是决定自己做一个，然后MacDown就这么诞生了!! 目前为止感觉跟Mou差不多，很好看，很好用。但是Macdown不要钱啊！！！而且Macdwon开源啊github传送门！！！！凭这两点就足矣完虐Mou了有没有！！！ 下面翻译一下Macdown的官方说明吧Markdown偏好设置（The Markdown Preference Pane）在这里设置markdown转换为html的偏好 文件格式Smartypants插件会根据上下文自动把 (&quot; 和 &#39;) 符号转化成 (“,‘,”和’)。这个功能对于像作者一样排版强迫症很有用。比如 &quot;test&quot;写在上面就自动变成 “test”这样了 Block FormattingTable这是一张表： 标题1 标题2 表格 表格 表格 表格 （中文写这个简直反人类，一定要切换到英文输入法才可以识别！！） 可以通过在|之间加上:符号来控制表格里面文字的排版。 比如：|:------------- |:---------------:| -------------:|这么写分别代表靠左，居中，靠右。 靠左 居中 靠右 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Fenced Code Block代码块长这样: 1print (&apos;Hello world!&apos;) 也可以用这个符号 (~) 代替这个符号(`): 1print(&apos;Hello world!&apos;) 你也可以在第一行末尾加个语言的名字，然后后面的代码酒会自动高亮了。当然你要把Enable highlighting in code blocks勾上（在 Preference—&gt;rendering里面）。 123456789foo = (1,2,3,4)bar = (5,6,7,8)for f,b in zip(foo,bar): print f,b# Prints:# 1 5# 2 6# 3 7# 4 8 他现在支持的语言有这些, 基本上的都支持了。一大堆没见过的…… Language ID Notes actionscript apacheconf Configuration syntax for the Apache HTTP Server. applescript aspnet ASP.NET markup in .aspx files. autohotkey bash brainfuck c c++ Alias to cpp. clike Generic syntax for C-like languages. coffee Alias to coffeescript. coffee-script Alias to coffeescript. coffeescript cpp C++ cs Alias to csharp. csharp C# css dart eiffel erlang fortran fsharp gherkin git Syntax used in Git commit messages. go groovy haml handlebars haskell html Alias to markup. http Syntax used in HTTP requests and responses. ini Windows INI format. jade java javascript jl Alias to julia. js Alias to javascript. json Alias to javascript. jsx julia keyman latex less lolcode makefile markdown markup Generic *ML syntax, e.g. HTML, XML, etc. matlab nasm The Netwide Assembler. nsis obj-c Alias to objectivec. objc Alias to objectivec. objective-c Alias to objectivec. objectivec Objective-C. pascal perl php powershell py Alias to python. python Python 2. r rb Alias to ruby. rest rip ruby rust sas SAS. Not an alias to sass. sass SASS (SASS) scala scheme scss SASS (SCSS) sh Alias to bash. smalltalk smarty sql stylus swift Apple’s Swift programming language. Not the parallel scripting language. twig typescript vhdl wiki xml Alias to markup. yaml YAML Inline Formatting下面这个表代表支持的Inline Formatting 名字 markdown写法 看到的结果 Intra-word emphasis So A*maz*ing So Amazing Strikethrough ~~Much wow~~ Much wow Underline [^under] _So doge_ So doge Quote [^quote] \”Such editor\” Such editor Highlight \==So good\== So good Superscript hoge\^(fuga) hogefuga Autolink http://t.co http://t.co Footnotes [\^4] and [\^4]: [^4] and footnote 4 [^4]:脚注可以随意标记，可以不用数字，也不用按顺序排列。脚注会根据在文章中出现的顺序自动按顺序排列到文章的末尾(像这样写，他会自动显示在文章末尾，网页上显示不了) The Rendering Preference Pane这个板块用来设置页面的样式和颜色 CSS你可以使用不同的CSS来改变html页面的样子，你甚至可以添加自己的CSS。 句法高亮（Syntax Highlighting ）之前写过如何让一个代码块高亮，不会的可以看这里 Fenced Code Block 。你也可以选用不同的主题来设置高亮。 TeX风格的数学公式（TeX-like Math Syntax ）（需要联网） （完全不懂他在说什么……） 复选框（Task List Syntax） Jekyll front-mattermacdown支持 Jekyll，只需要在文件最开始用---标记就好了。例如： 1234---title: &quot;Macdown is my friend&quot;date: 2014-06-06 20:00:00--- Render newline literally通常重起一行需要在上一行末尾打两个空格和一个回车号，你也可以设置为只打一个回车符号。但是不建议你这么做，因为这样写在Macdown上没有任何问题，但是一旦这个文件由其他程序生成那个html界面就扑街了。。。 The General Preferences Pane 从上到下依次是: 改变编辑页内容的时候预览内容也会跟着改变 滑动编辑页的时候预览也会跟着滑动 把编辑页放到右边 显示字符数 更新的时候包括预发行版 编辑页偏好设置（The Editor Preference Pane） Styling编辑器自带文字高亮显示，你也可以自己修改和调整字体的颜色和大小。当然也有一些自带的主题可以选择。你也可以自己添加新的主题，点击Reveal按钮就可以添加了，文件必须是(.styles)类型否则无法添加。编辑器有自动补全功能，如果不需要可以手动关闭。 第一次翻译别人的东西，比我想象中的难多了。本来以为两小时搞定，结果用了一下午，中间还有N多东西不确定……我还是好好学英语吧～]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让Markdown图片居中]]></title>
    <url>%2F2015%2F07%2F15%2F%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一般在MarkDown中通过 &apos;![](url)&apos; 添加图片看到的都是这样的： 但是如果我想让图片居中该怎么做呢？查了点资料之后发现可以这样： 123&lt;div style="text-align: center"&gt;&lt;img src="url"/&gt;&lt;/div&gt; 把这几行代码直接加到markdown里面就可以了，url换成图片的地址，就像这样： 相当于手动嵌入了HTML代码 或者 123&lt;center&gt;![](http://7xkfbb.com1.z0.glb.clouddn.com/15-7-16/95341796.jpg)&lt;/center&gt; 此图片只是为了纪念今天风云微博的优衣库事件～～]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
